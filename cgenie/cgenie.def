# **************************************************************************
# *                 ROM listing Colour BASIC interpreter                   *
# **************************************************************************
#
# This is a ROM listing of the BASIC interpreter for the EACA EG2000
# Colour Genie computer. There are several versions of the Colour BASIC
# interpreter around. This is the most commonly used. 
#
# -------------------------------------------------------------------------
# Conventions:
#
# A,B,C,D,E,
# H,L,BC,DE,
# HL,IX,IY,
# SP,PC                 Identifiers of the Z80 registers
#
# BCDE                  Concatination of BC and DE registers to hold
#                       a single precision value
#
# X                     Accumulator X (from 411DH onwards)
#
# Y                     Accumulator Y (from 4127H onwards)
#
# Exp ( X )             Exponent of value in X
#
# Exp ( Y )             Exponent of value in Y
#
# Exp                   Exponent of any floating point value
#
# Sign                  Sign of a value
#
# VT                    Variable Type
#                       (02 = INT, 03 = STR, 04 = SNG, 08 = DBL)
#
# LP                    Line Pointer (= link)
#
# LN                    Line Number
#
# PTP                   Program Text Pointer
#
# A = B                 A equals B
#
# A -> B                A points to B (contains address of B)
#
# A,n                   Bit n of register A
#
# I:                    List of entry parameters
#
# O:                    List of exit parameters
#
# SUB                   Subroutine
#
# --                    Unused instruction
#
# ---------------------------------------------------------------------------

# ---------------------------------------------------------------------------
# addr	entry type	comment
# ---------------------------------------------------------------------------

0000	CODE	; ---------------------------------------------------------------------------
*		; Start of the BASIC interpreter ROMs
*		; Entry at 0000H after switch on of the computer or after <RST>+<R>
*		; Cold start
0000	CODE	Disable interrupts
0001	CODE	A = 0
0002	CODE	Continue at 0674H
0005	CODE	--
0008	CODE	RST 08H: jump to 4000H and from there to 1C96H
000b	CODE	--
000d	CODE	--
0010	CODE	RST 10H: jump to 4003H and from there to 1D78H
0013	NONE	; DCB Call for Input (AF	DE)
*		;
*		; I: DE = DCB Address
*		; O: A = Input byte
0013	CODE	Save BC
0014	CODE	DCB type: input
0016	CODE	Call DCB
0018	CODE	RST 18H: jump to 4006H and from there to 1C90H
001b	CODE	; DCB Call for Output (AF	DE)
*		;
*		; I: DE = DCB Address
*		; O: A = Output byte
001b	CODE	Save BC
001c	CODE	DCB type: output
001e	CODE	Call DCB
0020	CODE	RST 20H: jump to 4009H and from there to 25D9H
0023	CODE	; DCB Call for Input/Output (AF	DE) (not used)
*		;
*		; I: DE = DCB Address
*		; O: A = Output byte
0023	CODE	Save BC
0024	CODE	DCB type: input/output
0026	CODE	Call DCB
0028	CODE	RST 28H: jump to 400CH (BREAK-vector	 reserved for DOS)
002b	CODE	; Get byte from keyboard (AF	DE)
*		;
*		; I: -
*		; O: A = ASCII code of the key pressed or 00H when no key pressed
002b	CODE	DE -> Keyboard DCB
002e	CODE	Continue at 0013H
0030	CODE	RST 30H: jump to 400FH (reserved for DOS)
0033	CODE	; Output a byte on the screen (AF	DE)
*		;
*		; I: A = ASCII code of the character to print on the screen
*		; O: -
0033	CODE	DE -> Screen DCB
0036	CODE	Continue at 001BH
0038	CODE	RST 38H: jump to 4012H (Interrupt vector	 reserved for DOS)
003b	CODE	; Output a byte on the printer (AF	DE)
*		;
*		; I: A = ASCII code of the character to print on the printer
*		; O: -
003b	CODE	DE -> Printer DCB
003e	CODE	Continue at 001BH
0040	CODE	Input of a line (see 05D9H)
0043	CODE	--
0046	CODE	Jump to DCB call
0049	CODE	; Wait for keypress (AF	DE)
*		;
*		; I: -
*		; O: A = ASCII code of key pressed
0049	CODE	Get byte from keyboard
004c	CODE	Key pressed ? (A <> 0)
004d	CODE	Yes: return
004e	CODE	No: again
0050	BYTES	; Decoding table for keyboard routine
*		; ASCII codes of corresponding keys
0050	BYTES	RETURN
0051	BYTES	RETURN SHIFT
0052	BYTES	CLEAR
0053	BYTES	CLEAR SHIFT
0054	BYTES	BREAK
0055	BYTES	BREAK SHIFT
0056	BYTES	UP ARROW
0057	BYTES	UP ARROW SHIFT
0058	BYTES	DOWN ARROW
0059	BYTES	DOWN ARROW SHIFT
005a	BYTES	LEFT ARROW
005b	BYTES	LEFT ARROW SHIFT
005c	BYTES	RIGHT ARROW
005d	BYTES	RIGHT ARROW SHIFT
005e	BYTES	SPACE BAR
005f	BYTES	SPACE BAR SHIFT
0060	CODE	; Delay loop (AF	BC)
*		;
*		; I: BC = counter (delay time = BC * 11.3 microseconds)
*		; O: -
0060	CODE	Decrement counter
0062	CODE	Counter zero ?
0063	CODE	No: loop
0066	CODE	; RESET entry after pressing both <RST> keys
0066	CODE	BC -> entry back into BASIC
0069	CODE	Continue at 05CAH
006c	CODE	; Start 4 (continuation of 05C7H)
*		; Prepare RAM for BASIC
006c	CODE	Set stackpointer
006f	CODE	Copy ROM area of 18F7H
0072	CODE	to 191CH into RAM area
0075	CODE	from 4080H to 40A6H
0078	CODE	Continue at 0140H
007b	CODE	; Start 6 when no ROM cartridge with a BASIC program is present
*		; (continuation of 0149H)
007b	CODE	HL -> start of BASIC program
0081	CODE	<MOD SEL> pressed ?
0083	CODE	Yes: continue at 008EH
0085	CODE	Save pointer in system RAM
0088	CODE	FCLS
008b	CODE	; Start 6 when a ROM cartridge with a BASIC program is present
*		; (continuation of 014CH)
008b	CODE	Save pointer to start of program in system RAM
008e	CODE	HL -> (start of line buffer-3) Mark start:
0091	CODE	':'
0094	CODE	00H
0096	CODE	'.'
0099	CODE	Save line buffer pointer in system RAM
009c	CODE	DE -> error routine Block Disk BASIC vectors
009f	CODE	28 vectors
00a1	CODE	HL -> vector table in RAM Construct vectors: 28 times a JP 013BH in RAM
00a4	CODE	JP opcode
00a7	CODE	LSB of error routine address
00a9	CODE	MSB of error routine address
00ab	CODE	Next vector Remaining DOS vectors are blocked with a RET
00ad	CODE	21 vectors
00af	CODE	Insert RET opcode
00b1	CODE	Reserve 2 bytes RAM space
00b2	CODE	so that the RET can be changed
00b3	CODE	to a JP instruction
00b4	CODE	Next vector
00b6	CODE	HL -> start of BASIC program
00b9	CODE	Adjust pointer
00ba	CODE	Mark start - 1 with 00H
00bb	CODE	Initialize CRTC
00be	CODE	Set stack pointer
00c1	CODE	Test ROM cartridge present
00c4	CODE	CLS
00c7	CODE	HL -> 'MEM SIZE'
00ca	CODE	Print text
00cd	CODE	Print '?' and wait for input <BREAK> pressed ?
00d0	CODE	Yes: repeat input
00d2	CODE	Get next non-space character
00d3	CODE	Only <RETURN> entered ?
00d4	CODE	No: an number was entered	 continue a 00E9H
00d6	CODE	Yes: HL -> start of RAM
00d9	CODE	HL + 1
00da	CODE	HL = 0000 ?
00db	CODE	(Complete memory tested)
00dc	CODE	Yes: continue at 00FAH
00de	CODE	Take byte from memory
00df	CODE	Save it in B
00e0	CODE	Complement A
00e1	CODE	Put it back in memory
00e2	CODE	Is it really in RAM ?
00e3	CODE	Restore original value
00e4	CODE	Yes: next byte No: HL -> end of RAM + 1
00e6	CODE	Subtract 256 bytes for SHAPE table
00e7	CODE	Continue at 00FAH
00e9	CODE	; Enter number at MEM SIZE?
00e9	CODE	Evaluate entered number
00ec	CODE	Only digits entered ?
00ed	CODE	No: ?SN Error
00f1	CODE	HL = MEM SIZE - 1
00f2	CODE	A = test byte
00f4	CODE	Save original byte
00f5	CODE	Testbyte to (HL)
00f6	CODE	Is it really saved ?
00f7	CODE	Put original value back
00f8	CODE	No: again!
00fa	CODE	; Store memory boundaries
*		; HL -> highest available memory location - 1
00fa	CODE	HL - 1
00fb	CODE	DE = 4414H
00fe	CODE	Compare HL with DE MEM SIZE < 4414H ?
00ff	CODE	Yes: ?OM Error
0102	CODE	DE = -50
0105	CODE	Store TOPMEM
0108	CODE	HL = HL - 50: CLEAR 50
0109	CODE	Save start address of string space
010c	CODE	NEW and CLEAR
010f	CODE	HL -> 'COLOUR BASIC'
0112	CODE	Print text
0115	CODE	Jump to BASIC active command mode
0118	ASCII	; Text 'MEM SIZE'
0120	BYTES	End of string
0121	ASCII	; Text 'COLOUR BASIC'
012d	BYTES	Newline
012e	BYTES	End of string
012f	SPACE	; Unused ROM space
012f	SPACE	--
0132	CODE	; X = CHECK ( Bit	 Address)
*		; -------------------------
0132	CODE	Continue at 016BH
0135	CODE	; SET Bit	 Address
*		; ----------------
0135	CODE	Continue at 014FH
0138	CODE	; RESET Bit	 Address
*		; ------------------
0138	CODE	Continue at 015DH
013b	CODE	; Entry with Disk BASIC vectors disabled
013b	CODE	E = Errorcode for ?SN Error without EDIT call
013d	CODE	Continue at error routine
0140	CODE	; Start 5 (Continuation of 0078H)
0140	CODE	Copy
0142	CODE	HL -> ROM catridge
0145	CODE	ROM cartridge with
0148	CODE	a BASIC program present ?
0149	CODE	No: continue at 007BH
014c	CODE	Yes: continue at 008BH
014f	CODE	; Continuation of SET routine of 0135H
014f	CODE	Get bitnr. and address
0152	CODE	A = bit mask
0154	CODE	Shift A until specified bit
0155	CODE	is set in A
0157	CODE	Adjust because B was bitnr + 1
0158	CODE	B = bit mask
0159	CODE	Take byte from memory
015a	CODE	Set bit
015b	CODE	Put byte back in memory
015d	CODE	; Continuation of RESET routine of 0138H
016b	CODE	; Continuation of CHECK routine of 0132H
016b	CODE	Get next non-space caharacter
016c	CODE	Next byte must be
016d	ASCII	a '('
016e	CODE	Get bitnr and address
0171	CODE	Save PTP
0172	CODE	Get byte from memory
0173	CODE	and specified bit in C-flag
0174	CODE	Loop
0176	CODE	HL = -1 (TRUE) Bit set ?
0179	CODE	Yes: continue at 017CH
017b	CODE	HL = 0 (FALSE)
017c	CODE	Write HL to X as INT
017f	CODE	Restore PTP
0180	CODE	Next byte must be
0181	ASCII	')'
0183	CODE	; SUB for SET	 RESET and CHECK
*		; Get bit number and address form program text
*		;
*		; I: HL = PTP
*		; O: B = Bit number + 1
*		;    DE = Address
0183	CODE	A = Bit number
0186	CODE	Out of range ?
0188	CODE	Yes: ?FC Error
018b	CODE	Save bit number
018c	CODE	Both parameters separated by
018d	ASCII	a comma ?
018e	CODE	DE = address
0191	CODE	Restore bit number
0192	CODE	Put it in B
0193	CODE	B = bit number + 1
0195	SPACE	; Unused ROM space
0195	SPACE	--
019d	CODE	; X = INKEY$
*		; ----------
019d	CODE	Get next non-space character
019e	CODE	Save PTP
019f	CODE	Has a key already been pressed
01a2	CODE	before ?
01a3	CODE	Yes	 pass value and return
01a5	CODE	No: key pressed now ?
01a9	CODE	No: null string as result
01ab	CODE	Save key code
01ac	CODE	Delete last key code
01b0	CODE	Reserve a byte in
01b1	CODE	string space
01b4	CODE	A = key code
01b5	CODE	HL -> memory for new string
01b8	CODE	Save string
01b9	CODE	Set VT to STR
01bc	CODE	; No key pressed
*		; Return a null string as result
01bc	CODE	HL -> null string
01bf	CODE	Set as result
01c2	CODE	Set VT to STR
01c7	CODE	Restore PTP
01c9	CODE	; CLS statement
*		; -------------
01c9	CODE	A = cursor home
01cb	CODE	Output A
01ce	CODE	A = clear screen from cursor pos. to end
01d3	CODE	; RANDOM statement
*		; ----------------
01d3	CODE	A = refresh register
01d5	CODE	Put it in system RAM
01d9	CODE	; Issue a level change to cassette port
01d9	CODE	A = last written value
01dc	CODE	Toggle bit 0
01de	CODE	Output value to cassette port
01e0	CODE	and save it is system RAM
01e4	CODE	; blink '*'
01e4	CODE	Get '*' or ' ' from screen
01e7	CODE	Swap '*' and ' '
01e9	CODE	Put it back on screen
01ed	CODE	; Read one byte from cassette (AF)
*		;
*		; I: -
*		; O: A = byte read from cassette port
01ed	CODE	Exchange registers
01ee	CODE	Read 8 bits
01f0	CODE	Put byte to 0
01f2	CODE	Read bit and shift into D
01f5	CODE	Next bit
01f7	CODE	A = complete byte read
01f8	CODE	Exchange registers
01fa	CODE	; Read one bit from cassette and shift into D
01fa	CODE	Save counter Wait for clock pulse:
01fb	CODE	Test port FFH
01fd	CODE	Mask level
01ff	CODE	and save in E
0200	CODE	Test port FFH
0202	CODE	Mask level
0204	CODE	Compare with previous level
0205	CODE	Put result in C-flag
0206	CODE	Search clock pulse
0208	CODE	A = 1
0209	CODE	A = new level value
020a	CODE	Store it in E for compare
020b	CODE	A = delay time
020e	CODE	Put it in B
020f	CODE	Delay loop
0211	CODE	Now take new input level
0215	CODE	and compare it with previous level. A = 1 if a level change is recognized.
0216	CODE	Shift D
0218	CODE	and add new value
0219	CODE	Result in D
021a	CODE	Restore counter
021c	CODE	; Write the same byte twice to cassette
021c	CODE	Write first byte
021f	CODE	; Write one byte to cassette (AF)
*		;
*		; I: A = byte to be written
*		; O: A = byte written
021f	CODE	Save registers
0220	CODE	Save byte
0221	CODE	8 bits to write
0223	CODE	D = byte
0224	CODE	Issue clock pulse
0227	CODE	A = delay value
022a	CODE	B = A
022b	CODE	Delay loop
022d	CODE	A = byte
022e	CODE	Shift next bit into C-Flag
022f	CODE	And save shifted value in D
0230	CODE	Bit = 1: Issue level change
0233	CODE	A = delay value
0236	CODE	B = A
0237	CODE	Delay loop
0239	CODE	Decrement bit counter All bits done ?
023a	CODE	No: loop	 issue next bit
023c	CODE	Restore byte value
023d	CODE	Restore registers
023f	CODE	; Write leader and sync on cassette
023f	CODE	write 255 times
0241	CODE	the byte AAH
0243	CODE	on cassette tape
0248	CODE	Sync = 66H
024a	CODE	Write on cassette tape
024c	CODE	; Search for leader and sync
024c	CODE	Save registers
024f	CODE	HL -> colour code table
0252	CODE	DE = 0000H
0255	CODE	A = present colour value
0258	CODE	DE = offset in table
0259	CODE	HL -> colour code
025a	CODE	A = colour code from table
025b	CODE	Store in colour RAM at the
025e	CODE	location for both asterisks
0261	CODE	B = counter = 128 C = byte to search for
0264	CODE	Read bit from cassette	 shift into D and load in A
0267	CODE	Byte found ?
0268	CODE	No: search again
026a	CODE	Yes: invert all bits in C
026c	CODE	so search for 55H now
026d	CODE	Result in C
026e	CODE	Continue search until 128 times AAH found
0270	CODE	Search sync (66H)
0273	CODE	Found ?
0275	CODE	No: continue seach
0277	CODE	A = '*'
0279	CODE	Put both asterisks on screen
027f	CODE	Restore registers
0283	SPACE	; Unused ROM space
0283	SPACE	--
02ac	CODE	; Read start address of loaded program from tape (for SYSTEM)
02ac	CODE	Read 2 bytes (start address)
02af	CODE	and store it in system RAM
02b2	CODE	; SYSTEM statement
*		; ----------------
02b2	CODE	DOS
02b5	CODE	Put stack in keyboard buffer to get it out of the way
02b8	CODE	Start new line
02bb	CODE	A = '*'
02bd	CODE	Print it
02c0	CODE	Ask for filename
02c3	CODE	Back to BASIC if <BREAK> key pressed
02c6	CODE	Get next non-space character Anything entered ?
02c7	CODE	No: ?SN Error
02ca	CODE	Is it a '/' ?
02cc	CODE	Yes: continue at 031DH
02ce	CODE	No: search for leader and sync
02d1	CODE	Get first byte from tape
02d4	CODE	Is it a SYSTEM program ?
02d6	CODE	No: continue search
02d8	CODE	6 characters for filename
02da	CODE	Get character from buffer
02db	CODE	End of line ?
02dc	CODE	Yes: load program
02de	CODE	No: load filename character
02e1	CODE	Same as in specified name ?
02e2	CODE	No: search next file
02e4	CODE	Yes: pointer + 1
02e5	CODE	Check next filename char.
02e7	CODE	Blink right asterisk
02ea	CODE	Read block marker from tape
02ed	CODE	End found ?
02ef	CODE	Yes: get start address and issue '*?' again
02f1	CODE	Start of block ?
02f3	CODE	No: search new byte
02f5	CODE	Read block length
02f8	CODE	B = block length
02f9	CODE	HL = block address
02fc	CODE	Calculate checksum
02fd	CODE	Store in C
02fe	CODE	Read byte
0301	CODE	Store it in memory
0302	CODE	Memory pointer + 1
0303	CODE	Add to checksum
0304	CODE	Store result in C
0305	CODE	Load next byte from block
0307	CODE	Block is done: get checksum
030a	CODE	Same as calculated checksum ?
030b	CODE	Yes: load next block
030d	CODE	No: A = 'C'
030f	CODE	Indicate checksum error
0312	CODE	Continue loading anyway
0314	CODE	; SUB for SYSTEM
*		; Load address (block address or start address) from tape
*		;
*		; I: -
*		; O: HL = address read from tape
0314	CODE	Load LSB from tape
0317	CODE	L = LSB of address
0318	CODE	Load MSB from tape
031b	CODE	H = MSB of address
031d	CODE	; Issue '/' with SYSTEM
031d	CODE	DE -> text
031e	CODE	HL = start address
0321	CODE	Load DE
0322	CODE	Get next non-space character Start address entered ?
0323	CODE	Yes: new value into DE
0326	CODE	Restart SYSTEM if rubbish was entered
0328	CODE	Load address into HL
0329	CODE	Execute program
032a	CODE	; Output of A on screen	 printer or cassette (AF	HL)
*		;
*		; I: A = ASCII value of the byte to be output
*		;    (409CH) = output flag: 00H = screen	 01H = printer	 80H = cassette
032a	CODE	Save BC
032b	CODE	C = output byte
032c	CODE	DOS
032f	CODE	Test flag
0333	CODE	Byte back in A
0334	CODE	Restore  BC
0335	CODE	Continue at 0564H
0338	SPACE	; Unused ROM space
0338	SPACE	--
033a	CODE	; Output A on screen and increment POS (40A6H)
033a	CODE	Save registers
033b	CODE	Save byte
033c	CODE	Output byte
033f	CODE	Calculate new POS value
0342	CODE	and save it in system RAM
0345	CODE	Restore byte
0346	CODE	Restore registers
0348	CODE	; Calculate new POS (AF	DE)
*		; I: -
*		; O: A = new POS value
0348	CODE	Save PTP
0349	CODE	HL = cursor address
034c	CODE	DE -> start of screen memory
034f	CODE	C-flag = 0
0350	CODE	Continue at 04D9H
0353	SPACE	; Unused ROM space
0353	SPACE	--
0355	CODE	; Calculate new POS (as 0348H)
0355	CODE	continue at 309DH
0358	CODE	; Keyboard scan (AF)
*		; (as 002B but with DOS and saving DE)
0358	CODE	DOS
035b	CODE	Save DE
035c	CODE	Scan keyboard
035f	CODE	Restore DE
0361	CODE	; Input of a line with max. 240 characters in line buffer (AF	DE	HL)
*		;
*		; I: -
*		; O: C-flag = 1: <BREAK> key pressed.
*		;    HL -> start of line buffer - 1
0361	CODE	A = 00H
0362	CODE	Delete last key code
0365	CODE	POS = 0
0368	CODE	DOS
036b	CODE	Save BC
036c	CODE	HL -> start of line buffer
036f	CODE	B = max. number of characters
0371	CODE	Enter line
0374	CODE	Save flags
0375	CODE	C = number of entered chars.
0376	CODE	BC = length of line
0378	CODE	HL -> last character + 1
0379	CODE	Terminate line with 00H
037b	CODE	HL -> start of line buffer
037e	CODE	Restore flags
037f	CODE	Restore BC
0380	CODE	Adjust HL for RST 10H <BREAK> pressed ?
0381	CODE	Yes: return
0382	CODE	C-flag = 0
0384	CODE	; Wait for key pressed (AF)
*		; (as 0049H but with DOS and save DE)
0384	CODE	Get key
0387	CODE	New key pressed ?
0388	CODE	Yes: return
0389	CODE	No: wait for key pressed
038b	CODE	; End output to printer (AF)
*		;
*		; I: -
*		; O: PPOS = 0 (Printer POS)
038b	CODE	Set output flag
038c	CODE	to screen output
038f	CODE	A = PPOS
0392	CODE	Zero ?
0393	CODE	Yes: return
0394	CODE	No: CR to printer
0396	CODE	Save DE
0397	CODE	Output CR
039a	CODE	Restore DE
039c	CODE	; Print one character on printer and  intercept control characters
039c	CODE	Save registers
039f	CODE	Save character in C
03a0	CODE	E = 00H for new PPOS
03a2	CODE	Is it a Form Feed ?
03a4	CODE	Yes: PPOS to 0 and print character
03a6	CODE	Is it a Line Feed ?
03a8	CODE	No: continue test
03aa	CODE	Convert LF into CR
03ac	CODE	Store it in C
03ad	CODE	Is it a Carriage Return ?
03af	CODE	Yes: PPOS to 0 and print character
03b1	CODE	No: get PPOS
03b4	CODE	and increment
03b5	CODE	Store in E
03b6	CODE	Save new PPOS
03b7	CODE	in system RAM
03ba	CODE	A = character to print
03bb	CODE	Print it
03be	CODE	Restore registers
03c2	CODE	; DCB call (AF) (see 0046H)
*		;
*		; I: A = character (when output)
*		;    B = DCB type
*		;    DE -> DCB
*		; O: A = character (when input)
03c2	CODE	Save registers
03c6	CODE	IX -> DCB
03c8	CODE	Adjust stack
03c9	CODE	HL = new return address
03cc	CODE	Put it in stack
03cd	CODE	Save character in C
03ce	CODE	Load DCB type
03cf	CODE	Mask unused bits
03d0	CODE	Same as indicated type ?
03d1	CODE	No: false DCB type	 set A to 00H and back to program (4033H is used by DOS)
03d4	CODE	DCB type = output ?
03d6	CODE	HL = address of DCB routine
03dc	CODE	Execute DCB routine
03dd	CODE	; End of DCB routine
03dd	CODE	Restore registers
03e3	CODE	; Keyboard routine (called by DCB)
03e3	CODE	ROM catrigde present ? Yes: start ROM program
03e6	CODE	Scan keyboard
03e9	CODE	<CTRL> and <MOD SEL> pressed ?
03eb	CODE	No: continue at 03FAH
03ed	CODE	FGR
03f0	CODE	Scan keyboard
03f3	CODE	<BREAK> pressed ?
03f5	CODE	No: wait for <BREAK>
03f7	CODE	LGR
03fa	CODE	HL -> temporary memory
03fd	CODE	BC = first keyboard address
0400	CODE	Line counter = 0
0402	CODE	Scan keyboard
0403	CODE	Result in E
0404	CODE	Set only the bits for those keys	 that have changed since last scan
0405	CODE	Store new code for next scan
0406	CODE	Set only the bit for the key key that was newly pressed since last scan
0407	CODE	Was a key pressed ? Yes: find ASCII code of key
0409	CODE	No: line counter + 1
040a	CODE	Buffer pointer  + 1
040b	CODE	Update keyboard address
040d	CODE	Scan next keyboard address
040f	CODE	Scan keyboard
0412	CODE	<RPT> pressed ?
0414	CODE	Yes: continue at 04D4H
0417	CODE	A = 00H
0419	CODE	; Find ASCII code of key
0419	CODE	Bit value to E
041a	CODE	HL = flag byte
041d	CODE	Scan keyboard
0420	CODE	<MOD SEL> pressed ?
0422	CODE	Yes: continue at 04C9H
0425	CODE	<CTRL> pressed ?
0427	CODE	Yes: continue at 04D0H
042a	CODE	Was the key in the last keyboard address and was not intercepted ?
042c	CODE	Line counter = 7 ?
042d	CODE	Yes: the key pressed was the <SHIFT> key (code = 00H)
042f	CODE	Multiply D by 8
0430	CODE	* 2
0431	CODE	* 2
0432	CODE	* 2
0433	CODE	Because there are 8 keys per keyboard address
0434	CODE	C = mask for calculation
0436	CODE	A = bit mask
0437	CODE	Mask key code Key newly pressed ?
0438	CODE	Yes: continue at 043FH
043a	CODE	Increment D to establish value of key in keyboard matrix
043b	CODE	Shift mask for next test
043f	CODE	; D now indicates the value of the key in the keyboard matrix
*		; @ has value 00H	 A has value 01H etc.	 upto the space bar which has
*		; a value of 37H
043f	CODE	Scan keyboard
0442	CODE	Save value in B
0443	CODE	A = matrix value
0444	CODE	Matrix value + 40H gives correct ASCII code for the kes '@' to 'F4' (ASCII codes 40H to 5FH)
0446	CODE	Value in range ?
0448	CODE	No: continue at 045DH
044a	CODE	<SHIFT> pressed ?
044c	CODE	No: key code is ok
044e	CODE	Add 20H to get lower case
0450	CODE	Save value
0451	CODE	Scan keyboard
0454	CODE	<SHIFT> + down arrow pressed ?
0456	CODE	Restore value
0457	CODE	No: key code is ok
0459	CODE	Convert value to control code
045b	CODE	Continue at 047FH
045d	CODE	; Numbers	 special characters or control characters were pressed:
*		; A has a value between 60H (for '0') and 77H (for space bar)
045d	CODE	Control character pressed ?
045f	CODE	Yes: continue at 0471H
0461	CODE	Adjust code
0463	CODE	'	' '-' '.' or '/' pressed ?
0465	CODE	No: correct ASCII code is in A	 continue at 0469H
0467	CODE	Yes: With these keys	 the symbols are swapped. This has to be corrected with XOR 10H (see ASCII table)
0469	CODE	<SHIFT> pressed ?
046b	CODE	No: pass on ASCII code
046d	CODE	Yes: exchange codes from
0471	CODE	; Control key pressed
*		; Take ASCII code from table at 0050H
0471	CODE	A = A * 2 as table offset
0472	CODE	<SHIFT> pressed ?
0474	CODE	No: offset is ok
0476	CODE	Adjust offset
0477	CODE	HL -> table with ASCII codes
047a	CODE	DE = offset
047d	CODE	Set pointer on key code
047e	CODE	A = key code
047f	CODE	; The correct ASCII code in now in A. Only the <MOD SEL> key has to be
*		; checked.
047f	CODE	HL = flag byte
0482	CODE	<MOD SEL> active ? (graphic characters)
0484	CODE	No: finish routine
0486	CODE	ASCII code < 2BH
0488	CODE	Yes: these keys have no graphic character
048a	CODE	ASCII code between 2BH	 2FH
048c	CODE	No: check further
048e	CODE	Yes: subtract 2BH
0490	CODE	and add C0H so that '+' gets code C0H and '/' gets code C4H
0492	CODE	Code smaller than ':' ?
0494	CODE	Yes: no graphic character
0496	CODE	Code bigger than 'Z' ?
0498	CODE	Yes: clear <F1> - <F4>
049a	CODE	':' to 'Z' becomes 05H to 24H
049c	CODE	Add C0H for graphic char.
049e	CODE	<F1> - <F4> ?
04a0	CODE	Yes: finish routine
04a2	CODE	<SHIFT>+<F1> - <SHIFT>+<F4> ?
04a4	CODE	Yes: finish routine
04a6	CODE	''' to 'z' becomes 25H to 3FH
04a8	CODE	Add C0H for graphic char.
04aa	CODE	; Now A contains the right ASCII code from 01H to FFH
04aa	CODE	Save ASCII code for repeat
04ad	CODE	Save for delay loop
04ae	CODE	Call delay loop for
04b1	CODE	debouncing purposes
04b4	CODE	Restore ASCII code
04b5	CODE	<RETURN> pressed ?
04b7	CODE	Yes: deactivate <MOD SEL>
04b9	CODE	<BREAK pressed ?
04bb	CODE	Yes: deactivate <MOD SEL>
04bd	CODE	Done when <BREAK> not pressed
04be	CODE	RST 28H when <BREAK> pressed (used by DOS)
04c0	CODE	; Deactivate <MOD SEL>
04c0	CODE	HL -> flag byte
04c3	CODE	Clear MOD SEL flag
04c5	CODE	<BREAK> pressed ?
04c7	CODE	Continue at 04DBH
04c9	CODE	; <MOD SEL> pressed
04c9	CODE	Set bit 6 (MOD SEL flag)
04cb	CODE	Toggle MOD SEL flag
04cc	CODE	Save it in system RAM
04cd	CODE	Return no value
04ce	CODE	Finish routine
04d0	CODE	; <CTRL> pressed
04d0	CODE	Set CTRL flag
04d2	CODE	Pass no value
04d4	CODE	; <RPT> pressed
04d4	CODE	A = last character code
04d7	CODE	Use it for further processing
04d9	CODE	; Compute POS (continuation of 0350H)
04d9	CODE	HL = screen position of cursor
04db	CODE	DE = number of chars/line
04de	CODE	Clear C-flag
04df	CODE	Subtract 40 from HL
04e1	CODE	until HL < 0
04e3	CODE	Adjust HL: HL = cursor position within line
04e4	CODE	A = POS
04e5	CODE	Restore PTP
04e7	CODE	; Printer routine (activated by DCB call)
04e7	CODE	A = ASCII code of character to be printed.
04e8	CODE	Null character ?
04e9	CODE	Yes: Just wait for printer
04eb	CODE	Vertical Tab character ?
04ed	CODE	Yes: incorporate line counter
04ef	CODE	Form Feed character ?
04f1	CODE	No: Print character
04f3	CODE	A = maximum number of lines
04f4	CODE	per page. A = 0 ?
04f7	CODE	Yes: send 00H to printer
04f9	CODE	A = max. number of lines/page
04fc	CODE	minus number of already printed lines.
04ff	CODE	B = number of lines remaining until next page
0500	CODE	Printer ready ?
0503	CODE	No: wait for printer
0505	CODE	C = Line Feed (0AH)
0507	CODE	Output C to printer
050a	CODE	Until next line
050c	CODE	Line counter = 0
050e	CODE	; Print character
050e	CODE	Printer ready ?
0511	CODE	No: wait for printer
0513	CODE	Print character in C
0516	CODE	was it a Carriage Return
0518	CODE	No: done
0519	CODE	Increment line counter
051c	CODE	A = number of printed lines
051f	CODE	Page full ?
0522	CODE	Printed character back in A
0523	CODE	No: done
0524	CODE	Line counter = 0
0529	CODE	; Printer ready ? (AF)
*		;
*		; I: -
*		; O: Z-flag = 1 when printer is ready
0529	CODE	Select register 7
052b	CODE	of the PSG
052d	CODE	Set port A to output
052f	CODE	and port B to input
0531	CODE	Select port B
0535	CODE	Get printer status
0537	CODE	Mask status bits
0539	CODE	and set Z-flag
053c	CODE	; C to printer without checking
053c	CODE	Select register 7
053e	CODE	of the PSG
0540	CODE	I/O port A on output and
0542	CODE	I/O port B on input
0544	CODE	Select register 14 (port A)
0548	CODE	Output byte
054b	CODE	Put both ports on output
0553	CODE	To port B
0557	CODE	Output 00H
055a	CODE	Then to port B
055e	CODE	Ouput 01H and indicate to
0560	CODE	printer that a byte has been send
0562	CODE	Character back in A
0564	CODE	; Output routine (continuation of 0335H)
0564	CODE	Output to cassette ? Yes: continue at 021FH Output to printer ?
0567	CODE	Yes: continue at 039CH
056a	CODE	Output to screen
056d	CODE	; Start 2 (continuation of 06ACH)
056d	CODE	Set stack pointer
0570	CODE	Clear port 255 (NBGRD	 CHAR 1
0571	CODE	and LGR)
0573	CODE	Clear colour memory
0580	CODE	C = port address
0582	CODE	Parameters for NTSC standard
0584	CODE	(have no effect in PAL)
058d	CODE	HL -> colour code table (probably meant for the NTSC version)
0590	CODE	DE -> CRTC table for PAL standard
059c	CODE	HL -> colour code table
05a0	CODE	Continue at 05B4H
05a2	CODE	; Unused routine (only for computers with NTSC standard)
05b4	CODE	; Start 3 (continuation of 05A0H)
05b4	CODE	Save HL
05b5	CODE	HL -> CRTC table
05b6	CODE	DE -> system RAM
05b9	CODE	BC = table size (35 bytes)
05bc	CODE	Copy table into sytem RAM
05be	CODE	Restore HL
05bf	CODE	DE -> colour code table
05c2	CODE	BC = table size (16 colours)
05c5	CODE	Copy into system RAM
05c7	CODE	Continue at 006CH
05ca	CODE	; Reset 2 (continuation of 0069H)
05ca	CODE	A = 0;
05cb	CODE	A = 0;
05cd	CODE	Read keyboard
05d0	CODE	<R> pressed ?
05d2	CODE	Yes: cold start
05d5	CODE	No: warm start
05d8	CODE	--
05d9	CODE	; Input of one line incl. cursor control	 FKEY evaluation und presentation
*		; of the entered character on screen (AF	 BC	 DE	 HL).
*		; The input is terminated by <RETURN> or <BREAK>.
*		; The End Of Line is indicated in the buffer by a 0DH character
*		;
*		; I: HL -> input buffer to store the entered characters.
*		;    B = Maximum number of characters allowed to be entered.
*		;        (more characters are not accepted. The input must be terminated
*		;        by <RETURN> or <BREAK>)
*		; O: HL -> start of input buffer
*		;    DE = 401DH (from 0033H call)
*		;    B  = number of entered characters
*		;    C  = B from start
*		;    A  = last character entered (0DH or 01H)
*		;    C-flag = 1 when input was terminated with <BREAK>
05d9	CODE	Save buffer address
05da	CODE	A = Cursor on
05dc	CODE	Output character
05df	CODE	C = max. number of characters
05e0	CODE	Continue at 3000H for FKEY evaluation
05e3	CODE	Control key entered ?
05e5	CODE	No: store character
05e7	CODE	<RETURN> ?
05e9	CODE	Yes: continue at 0662H
05ec	CODE	<CLEAR> ?
05ee	CODE	Yes: continue at 0619H
05f0	CODE	<BREAK> ?
05f2	CODE	Yes: continue at 0661H
05f4	CODE	Set new return address
05f7	CODE	to 05E0H
05f8	CODE	Backspace (arrow left) ?
05fa	CODE	Yes: continue at 0630H
05fc	CODE	Delete line (shift-arrow left) ?
05fe	CODE	Yes: continue at 062BH
0600	CODE	TAB (arrow right) ?
0602	CODE	Yes: continue at 0646H
0604	CODE	Shift-arrow right ? (32 characters/line in GENIE I)
0606	CODE	Yes: continue at 0641H
0608	CODE	New Line (arrow down) ?
060a	CODE	No: control character has no function	 get new character
060b	CODE	Remove return address from stack
060c	CODE	Store character in buffer
060d	CODE	Entering of characters
060e	CODE	still allowed ?
060f	CODE	No: get new character
0611	CODE	Get character from buffer
0612	CODE	Buffer pointer + 1
0613	CODE	Output character
0616	CODE	Character counter - 1
0617	CODE	Get next character
0619	CODE	; <CLEAR> pressed
0619	CODE	CLS
061c	CODE	Restart character counter
061d	CODE	HL -> start of buffer
061e	CODE	Save pointer again
061f	CODE	Get next character
0622	CODE	; Delete line
0622	CODE	Delete character
0625	CODE	Buffer pointer - 1
0626	CODE	A = last character
0627	CODE	Increment buffer pointer
0628	CODE	Has a new line already been started ?
062a	CODE	Yes: then only delete until here
062b	CODE	; <Shift>+<arrow left> pressed
062b	CODE	Have characters been
062c	CODE	entered already ?
062d	CODE	Yes: delete line
0630	CODE	; <arrow left> pressed
0630	CODE	Character counter still on
0631	CODE	initial value ?
0632	CODE	Yes: done
0633	CODE	Buffer pointer - 1
0634	CODE	Get previous character
0635	CODE	New line started ?
0637	CODE	Buffer pointer + 1
0638	CODE	Yes: return
0639	CODE	No: buffer pointer + 1
063a	CODE	A = backspace character
063c	CODE	Output byte
063f	CODE	Character counter + 1
0641	CODE	; <SHIFT>+<arrow right> pressed
0641	CODE	17H was code for switching to 32 characters/lines
0643	CODE	Output byte (has no effect on the Colour Genie)
0646	CODE	; <arrow right> pressed
0646	CODE	A = POS
0649	CODE	Calculate last TAB position
064b	CODE	Negate value
064c	CODE	adjust to 2 complement
064d	CODE	+8 gives number of characters until next TAB position
064f	CODE	E = counter
0650	CODE	Is it allowed to enter more
0651	CODE	characters ?
0652	CODE	No: return
0653	CODE	A = space character
0655	CODE	Put it in buffer
0656	CODE	Buffer pointer + 1
0657	CODE	Save DE
0658	CODE	Output byte
065b	CODE	Restore DE
065c	CODE	Character counter - 1
065d	CODE	TAB counter - 1
065e	CODE	Return when done
065f	CODE	Next character in buffer
0661	CODE	; <BREAK> pressed
0661	CODE	Set C-flag = 1 and treat it further like <RETURN>
0662	CODE	; <RETURN> pressed
0662	CODE	Save flags
0663	CODE	A = Carriage Return
0665	CODE	Put it in buffer
0666	CODE	Output byte
0669	CODE	A = cursor off
066b	CODE	Output character
066e	CODE	Calculate the number of
066f	CODE	entered characters
0670	CODE	Result in B
0671	CODE	Restore flags
0672	CODE	HL -> start of buffer
0674	CODE	; Start 1
0674	CODE	CHAR 2	 NBGRD and LGR
0676	CODE	Output to port
0678	CODE	Save port status
067b	CODE	HL -> start of block
067e	CODE	DE -> destination system RAM
0681	CODE	BC = 54 bytes
0684	CODE	Initialize system RAM
0686	CODE	Repeat until A = 00H
068a	CODE	Clear the next 39 bytes
0690	CODE	HL -> function key defaults
0693	CODE	DE -> function key RAM space
0696	CODE	BC = size to copy
0699	CODE	Copy function key definitions
069b	CODE	Set SCALE = 1
06a0	CODE	Set pointer on table with
06a3	CODE	Colour BASIC statements in system RAM
06a6	CODE	Set pointer on vector table
06a9	CODE	in system RAM
06ac	CODE	Continue at 05D6H
06af	CODE	Take first byte of ROM cartridge space
06b2	CODE	Program there ?
06b4	CODE	Yes: execute program
06b7	CODE	Take first byte of ROM cartridge space
06ba	CODE	Program there ?
06bc	CODE	Yes: execute program
06c0	CODE	Take first byte of ROM cartridge space
06c3	CODE	Program there ?
06c5	CODE	Yes: execute program
06cb	SPACE	; Unused ROM space
06cb	SPACE	--
06d2	CODE	; The following block of code is copied into system RAM at 4000H to initialize
*		; the vectors and DCBs located there
06d2	CODE	RST 08H vector
06d5	CODE	RST 10H vector
06d8	CODE	RST 18H vector
06db	CODE	RST 20H vector
06de	CODE	RST 28H vector (BREAK vector)
06e1	CODE	RST 30H vector
06e4	CODE	RST 38H vector
06e7	BYTES	Initialization data for
06e8	WORDS	constructing keyboard DCB
06ef	BYTES	Initialization data for
06f0	WORDS	constructing screen DCB
06f7	BYTES	Initialization data for
06f8	WORDS	constructing printer DCB
06ff	CODE	constructing printer DCB
0702	CODE	constructing printer DCB
0705	CODE	False DCB vector
0708	CODE	; X = X + 0.5 (SNG)
0708	CODE	HL -> Constant 0.5
070b	CODE	; X = X + (HL)
070b	CODE	BCDE = (HL)
070e	CODE	X = X + BCDE
0710	CODE	; X = (HL) - X (SNG)
0710	CODE	BCDE = (HL)
0713	CODE	; X = BCDE - X (SNG)
0713	CODE	X = -X
0716	CODE	; X = BCDE + X (SNG)
0716	CODE	A = Exp (BCDE)
0717	CODE	BCDE = 0 ?
0718	CODE	Yes: result already in X
0719	CODE	A = Exp (X)
071c	CODE	X = 0 ?
071d	CODE	Yes: X = BCDE
0720	CODE	A = Exp (X) - Exp (BCDE) Largest value in X ?
0721	CODE	Yes: continue at 072FH
0723	CODE	A = -A
0724	CODE	A is the difference of the exponents
0725	CODE	Save DE
0726	CODE	(SP) = X (2nd operand on stack)
0729	CODE	Restore DE
072a	CODE	X = BCDE (1st operand)
072d	CODE	BCDE = 2nd operand
072f	CODE	X is now the operand with the biggest exponent A contains the differnce between the exponents. Difference bigger than 24 ? (difference between the operands bigger than 2^24)
0731	CODE	Yes: BCDE is too small	 the sum would not change X
0732	CODE	Save exponent difference
0733	CODE	Adjust mantissas
0736	CODE	H	 7 = 0	 if signs are not equal
0737	CODE	Restore exponent difference
0738	CODE	Shifting CDE to the right by A bits: bring mantissa of BCDE on the same exponent as X
073b	CODE	A	7 = 0 when unequal signs
073c	CODE	HL -> X Signs equal ?
073f	CODE	No: continue at 0754H
0742	CODE	Add mantissas Overflow ?
0745	CODE	No: continue at 0796H
0748	CODE	HL -> Exp (X)
0749	CODE	Exp (X) + 1 (adjust Exp for overflow) exponent overflow ?
074a	CODE	Yes: ?OV Error
074d	CODE	Divide Mantissa by 2
074f	CODE	because exponent incremented
0752	CODE	Round CDE and store in X
0754	CODE	; Unequal signs
0754	CODE	B = -B
0757	CODE	Subtract Mantissa
075f	CODE	Subtract MSBs
0761	CODE	Underflow ?
0762	CODE	; SFLOAT: Convert CDEB in 2-exp format and store in X
*		;         The mantissa is shifted to the left by one bit until
*		;         the highest bit = 1 and the exponent is as small as possible
0762	CODE	Invert Mantissa (CDEB) when over or underflow
0765	CODE	HL = LSBs
0766	CODE	Manstissa now in CDHL
0767	CODE	A = 00H
0768	CODE	B = counter
0769	CODE	A = MSB
076a	CODE	MSB = 0 ?
076b	CODE	No: continue shifting
076d	CODE	C << D << H << L << 00H
076e	CODE	(Shift Mantissa left bytewise)
076f	CODE	until MSB <> 0
0772	CODE	Counter - 8 (8 bits shifted)
0774	CODE	Counter = -32 ?
0776	CODE	No: continue shifting Shifted 4 times: Mantissa is now 0	 result = 0
0778	CODE	; X = 0 (SNG)
0778	CODE	A = 00H
0779	CODE	Exp (X) = 00H	  X = 0
077d	CODE	; Shift Mantissa CDHL bitwise to the left until highest bit = 1
077d	CODE	Counter - 1 (shift 1 bit)
077e	CODE	HL = HL * 2 (= shift left)
0780	CODE	D = D * 2	 C-flag = overflow
0782	CODE	C = C + C + C-flag
0785	CODE	Highest bit of C = 1 ? No: continue shifting
0788	CODE	A = negative number of times that has been shifted
0789	CODE	Mantissa = CDEB
078b	CODE	Anything shifted ?
078c	CODE	Yes: continue at 0796H
078e	CODE	HL -> Exp (X)
0791	CODE	A = new exponent
0792	CODE	Save exponent; old exponent to small ?
0793	CODE	Yes: X = 0 exponent = 0 ?
0795	CODE	Yes: return
0796	CODE	; Round CDEB and store in X
*		; Exp (X) and sign are kept
0796	CODE	A = LSB
0797	CODE	HL -> Exp (X)
079a	CODE	Highest bit of LSB = 1 ?
079b	CODE	Yes: round up CDE
079e	CODE	B = Exp (X)
07a0	CODE	A = Sign flag
07a1	CODE	Clear sign bit
07a4	CODE	BCDE is negative in case sign flag was 00H
07a5	CODE	X = BCDE
07a8	CODE	; Round CDE and write overflow to Exp (X)
07a8	CODE	LSB + 1 Overflow ?
07a9	CODE	No: return
07aa	CODE	Next byte + 1 Overflow ?
07ab	CODE	No: return
07ac	CODE	MSB + 1 Overflow ?
07ad	CODE	No: return
07ae	CODE	Set highest bit of Mantissa
07b0	CODE	and increment Exp (X) Overflow ?
07b1	CODE	No: return
07b2	CODE	; ?OV Error
07b2	CODE	E = error code for ?OV error
07b4	CODE	Continue at error routine
07b7	CODE	; CDE = CDE + (HL) (SNG)
*		; Fixed point (Mantissa) addition
07b7	CODE	A = (HL)
07b8	CODE	A = E + (HL)
07b9	CODE	E = E + (HL)
07ba	CODE	Next byte
07bc	CODE	Now add with carry
07be	CODE	Last byte
07c3	CODE	; Invert Mantissa of CDEB and Sign flag (4125H)
07c3	CODE	HL -> Sign flag
07c6	CODE	A = Sign Flag
07c7	CODE	Invert
07c8	CODE	and store
07c9	CODE	A = 00H
07ca	CODE	L = 00H
07cc	CODE	B = 00H - B
07cd	CODE	A = 00H
07ce	CODE	E = 00H - E - C-flag
07d0	CODE	Same with D
07d3	CODE	and with C
07d7	CODE	; Shift CDE by A bits to the right. B becomes LSB
07d7	CODE	Overflow on 00H
07d9	CODE	More as 8 shifts ?
07db	CODE	No: shift bitwise Yes: shift bytewise
07e0	CODE	00H >> C >> D >> E >> B
07e2	CODE	Loop
07e4	CODE	; Shift bitwise
07e4	CODE	Reverse SUB and adjust by 1
07e6	CODE	L = counter
07e7	CODE	A = 00H
07e8	CODE	Counter - 1 Counter = 0 ?
07e9	CODE	Yes: return
07ea	CODE	Shift right CDE by one bit
07ed	CODE	Shift D
07f0	CODE	Shift E
07f3	CODE	Shift B
07f5	CODE	Overflow in B
07f6	CODE	Loop
07f8	BYTES	; Constant 1 (SNG)
07fc	BYTES	; Table of SNG coefficients for LOG function
07fc	BYTES	3 Coefficients
07fd	BYTES	0.598979 approx.
07fe	BYTES	2 / ( 5*LOG(2) )
0801	BYTES	0.961471 approx.
0802	BYTES	2 / ( 3*LOG(2) )
0805	BYTES	2.88539  approx.
0806	BYTES	2 / ( 1*LOG(2) )
0809	CODE	; X = LOG ( X )
*		; -------------
*		; Calculates the natural logarithm of X
*		;
*		; I: X = numerical value (<> 0)
*		; O: X = LOG (numerical value)
0809	CODE	TEST2
080c	CODE	Argument = 0 ?
080d	CODE	Yes: ?FC Error
0810	CODE	HL -> Exp (argument)
0813	CODE	A = Exp (argument)
0814	CODE	BCDE = 0.707107 = SQR(2)/2
081a	CODE	Conversion Arg = x * 2 ^ n; Exp (Arg) - 128 = n (B is 128)
081b	CODE	save n
081c	CODE	X = x (set Exp to 80H)
081d	CODE	Save BCDE
081f	CODE	X = X + BCDE = X+1/2*SQR(2)
0822	CODE	Restore BCDE
0824	CODE	Exp(BCDE) + 1 BCDE = BCDE * 2 + SQR(2)
0825	CODE	X = BCDE / X = SQR(2) / X
0828	CODE	HL -> 1.0
082b	CODE	X = (HL) - X = 1.0 - X
082e	CODE	HL -> numeric table
0831	CODE	Compute row1
0834	CODE	BCDE = -0.5
083a	CODE	X = BCDE + X = X - 0.5
083d	CODE	Restore n
083e	CODE	X = X + n and multiply with LOG(2)
0841	CODE	; X = X * LOG(2)
0841	CODE	BCDE = 0.693147 = LOG(2)
0847	CODE	; SMUL: X = BCDE * X
*		; Multiply two single precision numbers
*		;
*		; I: BCDE = 1st factor
*		;    X    = 2nd factor
*		; O: X    = product
0847	CODE	TEST2
084a	CODE	X = 0: result = 0
084b	CODE	Flag = 0 (MUL indication)
084d	CODE	Process exponent
0850	CODE	Save CDE (1st factor) in
0851	CODE	system RAM from 414FH onwards
0858	CODE	BCDE = 00000000H
085d	CODE	Put new return address
0860	CODE	to 0765H
0861	CODE	Put new return address twice
0864	CODE	to 0869H
0866	CODE	HL -> 2nd factor
0869	CODE	A = next byte of mantissa of the 2nd factor
086a	CODE	Pointer + 1
086b	CODE	Byte = 00H ?
086c	CODE	Yes: continue at 0892H
086e	CODE	Save pointer
086f	CODE	L = counter for 8 bits
0871	CODE	Shift next bit into C-flag
0872	CODE	Save byte in H
0873	CODE	A = MSB Bit set by last shift ?
0874	CODE	No: continue at 0881H
0876	CODE	Save HL
0877	CODE	CDE = CDE + 1st factor
087c	CODE	Restore HL
0880	CODE	A = MSB
0881	CODE	CDEB one bit to the right
0883	CODE	Shift D
0886	CODE	Shift E
0889	CODE	Shift B
088c	CODE	Counter - 1
088d	CODE	Byte back into A
088e	CODE	Check next bit
0890	CODE	HL -> X
0891	CODE	RET twice to 0896H and once to 0765H
0892	CODE	; SUB for SMUL
*		; Shift CDEB 1 byte to the right and fill with 00H
0892	CODE	00H >> C >> D >> E >> B
0897	CODE	; SDIV10: X = X / 10
*		; Divides number in X BY 10
*		;
*		; I: X = single precision number
*		; O: X = number / 10
0897	CODE	(SP) = X
089a	CODE	HL -> 10
089d	CODE	; X = (SP) / (HL)
089d	CODE	X = BCDE = (HL)
08a0	CODE	; X = (SP) / X
08a0	CODE	BCDE = (SP)
08a2	CODE	; SDIV: X = BCDE / X
*		; Divides 2 single precision numbers
*		;
*		; I: BCDE = dividend
*		;    X = divisor
*		; O: X = quotient
08a2	CODE	TEST2 X = 0 ?
08a5	CODE	Yes: ?/0 Error
08a8	CODE	Flag = FFH (DIV marker)
08aa	CODE	Process exponent and sign
08ad	CODE	Adjust exponents
08af	CODE	HL -> MSB (X)
08b0	CODE	Store divisor in RAM
08b1	CODE	MSB at 4089H
08b6	CODE	1st LSB at 4085H
08bb	CODE	2nd LSB at 4081H
08be	CODE	BHL = CDE
08bf	CODE	BHL = mantissa of dividend
08c0	CODE	A = 00H
08c1	CODE	CDE = 000000H
08c2	CODE	(Result is computed in CDE)
08c4	CODE	(408C) = 00H
08c7	CODE	Save dividend
08c9	CODE	A = 2nd LSB of dividend
08ca	CODE	BHL = BHL - X (subtract mantissa of dividend and divisor) A = (408CH)
08cd	CODE	A = A - C-flag (subtract borrow from last subtract from MSB
08cf	CODE	Invert C-flag
08d0	CODE	Yes: continue at 08D9H
08d2	CODE	No: write MSB back
08d5	CODE	Remove dividend from stack
08d7	CODE	C-flag = 1: jump is not
08d8	CODE	executed
08d9	ENTRY	Dividend back to BHL
08da	ENTRY	(C-flag = 0 because of 08D0H)
08db	CODE	A = MSB of result
08dc	CODE	Bit 7 of A = 1 ?
08dd	CODE	(S-flag is influenced)
08de	CODE	Shift C-flag to bit 7 of A for round routine
08df	CODE	Yes: done	 round CDE upwards (if C-flag was 1) and write result in X
08e2	CODE	Shift back and shift C-flag into result
08e3	CODE	(C << C << E << C-flag)
08ec	CODE	Shift dividend 1 bit left
08ee	CODE	Overflow from HL to B
08f0	CODE	Overflow of dividend-shift
08f3	CODE	to 408CH (MSB of dividend)
08f7	CODE	CDE = 000000H ?
08fa	CODE	No: process next bit Yes:
08fc	CODE	Save HL
08fd	CODE	HL -> Exp (X)
0900	CODE	X = X / 2 Underflow ?
0901	CODE	Restore HL first
0902	CODE	No: process next bit
0904	CODE	Yes: ?OV Error
0907	CODE	; SUB for SMUL	 SDIV	 DMUL and DDIV
*		; Process exponents and signs
*		; Entry for DDIV
0907	CODE	Flag = FFH
0909	CODE	--
090a	ENTRY	; Entry for DMUL
090a	ENTRY	Flag = 00H
090b	CODE	HL -> MSB (Y)
090e	CODE	C = MSB (Y)
090f	CODE	HL -> Exp (Y)
0910	CODE	DMUL: A = Exp (Y) DDIV: A = -Exp (Y) - 1
0911	CODE	B = Exp
0912	CODE	Continue as with SMUL
0914	CODE	; Entry for SMUL (L=00H) and SDIV (L=FFH)
0914	CODE	A = Exp (BCDE)
0915	CODE	BCDE = 0 ?
0916	CODE	Yes: result = 0
0918	CODE	A = flag
0919	CODE	HL -> Exp (X)
091c	CODE	SMUL: A = EXP (X) SDIV: A = -Exp (X) - 1
091d	CODE	SMUL: A = Exp (Y) + Exp (X) SDIV: A = Exp (Y) - Exp (X) -1
091e	CODE	B = new Exp
091f	CODE	Shift C-flag into A	 bit 7
0920	CODE	XOR with B A	 bit 7 = 0 when an overflow or underflow occurs to C-flag and A	 bit 7 at the addition of the exponents. (if both exponents were positive (i.e. > 80H)	 only an oveflow to C-flag occurs; A	 bit 7 becomes 0! )
0921	CODE	A = new exponent
0922	CODE	Under/overflow: continue at 0936H
0925	CODE	Add offset to Exp
0927	CODE	Store new exponent in Exp (X) exponent = 0 ?
0928	CODE	Yes: done	 continue ar 0890H
092b	CODE	Adjust mantissas
092e	CODE	Save signflag
092f	CODE	HL = 4124H
0931	CODE	; Entry from Exp (X) when X > 127 or LSB (X) > 7DH
*		; If X < 0	 then set X = 0 else ?OV Error
0931	CODE	TEST2
0934	CODE	If X < 0 then A positive          else A negative
0935	CODE	Remove RET address
0936	CODE	Set flags
0937	CODE	Remove RET address
0938	CODE	A positive then X = 0
093b	CODE	Else ?OV Error
093e	CODE	; SMUL10: X = X * 10
*		; Multiplies number in X with 10
*		;
*		; I: X = single precision number
*		; O: X = number * 10
093e	CODE	BCDE = X
0941	CODE	BCDE = 0 ?
0943	CODE	Yes: result = 0
0944	CODE	Exp + 2: BCDE = BCDE * 4 Exp overflow ?
0946	CODE	Yes: ?OV Error
0949	CODE	Set Exp in BCDE
094a	CODE	X = X + BCDE = X + 4*X = 5 * X
094d	CODE	HL -> Exp (X)
0950	CODE	Exp (X) + 1: X = X * 2 Overflow ?
0951	CODE	No: done	 return
0952	CODE	?OV Error
0955	CODE	; TEST2: SNG function for X
*		; Test single or double precision number in X if smaller	
*		; equal or greater than zero
*		; ?TM Error when X contains a STR
*		;
*		; I: X = single or double precision number to be tested
*		; O: if X < 0: A = FFH	 C-flag = 1	 Z-flag = 0	 S-flag = 1
*		; O: if X = 0: A = 00H	 C-flag = 0	 Z-flag = 1	 S-flag = 0	 P/V-flag = 1
*		; O: if X > 0: A = 01H	 C-flag = 0	 Z-flag = 0	 S-flag = 0
0955	CODE	A = Exp (X)
0958	CODE	X = 0 ?
095a	CODE	A	7 = sign
095d	CODE	--
095e	ENTRY	; Entry from compare routines
095f	CODE	C-flag = sign
0960	CODE	A = FFH if X<0 else A = 00H X < 0 ?
0961	CODE	Yes: return
0962	CODE	X > 0: A = 01H
0964	CODE	; FLOATA: convert A single precision number
*		;
*		; I: A = number
*		; O: X = numerical value of A in single precision
0964	CODE	B = Exp for 2 ^ 8
0966	CODE	LSBs = 0
0969	CODE	; FLOAT: convert a binary number into single precision
*		; 1. Binary number of 8 bits:
*		;    I: B = 88H (Exp for 2 ^ 8)
*		;       A = binary value
*		;       DE = 0000H
*		; 2. Binary number of 16 bits: (see also CINT)
*		;    I: B = 90H (Exp for 2 ^ 16)
*		;       A = MSB of 16 bit value
*		;       D = LSB of 16 bit value
*		;       E = 0000H
*		; 3. Binary number of 24 bits:
*		;    I: B = 98H (Exp for 2 ^ 24)
*		;       A = MSB of 24 bit value
*		;       DE = LSBs of 24 bit value
*		; O: X = single precision number
0969	CODE	HL -> Exp (X)
096c	CODE	C = 8 bit value
096d	CODE	Set exponent
096e	CODE	B = 00H (becomes LSB at 0762H)
0970	CODE	HL -> sign-flag
0971	CODE	Set sign-flag to 80H
0973	CODE	Sign-bit to C-flag (for 0762H)
0974	CODE	SFLOAT conversion CDEB to X
0977	CODE	; X = ABS (X)
*		; -----------
0977	CODE	TEST1
097a	CODE	Yes: return
097b	CODE	TSTTYP INT type ?
097c	CODE	Yes: continue at 0C5BH STR type ?
097f	CODE	Yes: ?TM error
0982	CODE	; SDNEG: X = -X
*		; Negate number in X
*		;
*		; I: X = single of double precision number
*		; O: X = negated number
0982	CODE	HL -> MSB of X
0985	CODE	A = MSB of X
0986	CODE	Invert sign bit
0988	CODE	Store MSB of X
098a	CODE	; X = SNG (X)
*		; -----------
098a	CODE	TEST1
098d	CODE	L = SNG(value) (FFH 00H 01H)
098e	CODE	Highest bit to C-flag
098f	CODE	A = 00 when positive result else A = FFH
0990	CODE	Now HL = A
0991	CODE	Write HL to X as INT
0994	CODE	; TEST1: As SNG function	 but result in A
*		; Test number in X if smaller	 equal or greater than zero
*		; ?TM Error when X contains a STR
*		;
*		; I: X = number to be tested
*		; O: if X < 0: A = FFH	 C-flag = 1	 Z-flag = 0	 S-flag = 1
*		; O: if X = 0: A = 00H	 C-flag = 0	 Z-flag = 1	 S-flag = 0	 P/V-flag = 1
*		; O: if X > 0: A = 01H	 C-flag = 0	 Z-flag = 0	 S-flag = 0
0994	CODE	TSTTYP STR type ?
0995	CODE	Yes: ?TM Error INT type ?
0998	CODE	No: SNG or DBL so TEST2
099b	CODE	HL = X (INT)
099e	CODE	HL = 0000 ?
09a0	CODE	Yes: return
09a1	CODE	A = MSB of X if H < 0 then A	 bit 7 = 1          else A	 bit 7 = 0
09a4	CODE	; (SP) = X (SNG)
*		; (Save value in X)
09a4	CODE	Save HL
09a5	CODE	HL = LSB (X)
09a8	CODE	Put LSBs on stack
09a9	CODE	Save RET address
09aa	CODE	Same with MSB and Exp
09af	CODE	Restore HL
09b1	CODE	; X = BCDE = (HL) (SNG)
09b1	CODE	BCDE = (HL)
09b4	CODE	; X = BCDE (SNG)
09b4	CODE	HL = LSBs
09b5	CODE	Store in X
09b8	CODE	HL = MSB and Exp
09ba	CODE	Store in X
09bd	CODE	Restore HL
09bf	CODE	; BCDE = X (SNG)
09bf	CODE	HL -> X
09c2	CODE	; BCDE = (HL) (SNG)
09c2	CODE	E = LSB
09c4	CODE	D = LSB + 1
09c6	CODE	C = MSB
09c8	CODE	B = Exp
09cb	CODE	; (HL) = X (SNG)
09cb	CODE	DE -> X
09ce	CODE	B = size of SNG variable
09d0	CODE	Continue at 09D7H
09d2	CODE	; (DE) = (HL)
*		; Copy memory from (HL) to (DE)	 counter = (40AFH)
09d3	CODE	; As above but from (DE) to (HL)
09d3	CODE	A = variable type in X
09d6	CODE	; Copy routine: copies A bytes from (DE) to (HL)
09d6	CODE	Save in B as counter
09d7	CODE	; Copy B bytes from (DE) to (HL)
09d7	CODE	Copy byte from (DE)
09d8	CODE	to (HL)
09d9	CODE	Origin pointer + 1
09da	CODE	Destiniation pointer + 1
09db	CODE	All bytes done ?
09dc	CODE	No: next byte
09df	CODE	; Sign processing for basic arithmatic operations
*		; Set proper mantissas of X and BCDE (highest bit to 1)
*		; and adjust sign
*		;
*		; I: X = single or double precision number
*		;    BCDE = single or double precision number
*		; 0: Correct mantissa of X and BCDE (highest bit = 1)
*		;    If both signs are the same then A	 bit 7 = 1 else A	 bit 7 = 0
09df	CODE	HL -> MSB of X
09e2	CODE	A = MSB of X
09e3	CODE	C-flag and A	 bit 0 = Sign X
09e4	CODE	C-flag = 1
09e5	CODE	A	 bit 7 = C-flag = 1	 C-flag = A	 bit 0 = sign
09e6	CODE	Correct Mantissa
09e7	CODE	Invert C-flag
09e8	CODE	A	 bit 0 = inverted sign
09ea	CODE	HL = 4125H (sign-flag)
09eb	CODE	Save sign flag
09ec	CODE	Same with BCDE but leave sign
09f2	CODE	XOR both signs
09f4	CODE	; X = Y (SNG	DBL)
09f4	CODE	HL -> LSB of Y
09f7	CODE	; X = (HL) (SNG	DBL)
09f7	CODE	DE = address of copy routine (HL) to (DE)
09fa	CODE	Continue at 0A02H
09fc	CODE	; Y = X (SNG	DBL)
09fc	CODE	HL -> LSB of Y
09ff	CODE	; (HL) = X (SNG	DBL)
09ff	CODE	DE = address of copy routine (DE) to (HL)
0a02	CODE	Put address on stack as new RET address
0a03	CODE	DE -> X (SNG)
0a06	CODE	TSTTYP SNG ?
0a07	CODE	Yes: ok
0a08	CODE	DE -> X (DBL)
0a0c	CODE	; CP X 	 BCDE (SNG)
*		;
*		; I: -
*		; O: if X < BCDE then A = FFH	 C-flag = 1	 Z-flag = 0	 S-flag = 1
*		;    if X = BCDE then A = 00H	 C-flag = 0	 Z-flag = 1	 S-flag = 0
*		;    if X > BCDE then A = 01H	 C-flag = 0	 Z-flag = 0	 S-flag = 0
0a0c	CODE	BCDE = 0 ?
0a0e	CODE	Yes: TEST2
0a11	CODE	Set new RET address to TEST2
0a15	CODE	TEST2
0a18	CODE	A = MSB (BCDE) X = 0 ?
0a19	CODE	Yes: goto TEST2 (only test BCDE)
0a1a	CODE	HL -> MSB (X)
0a1d	CODE	Compare signs
0a1e	CODE	A = MSB (BCDE)
0a1f	CODE	Goto TEST2	 when both signs are not equal (only test BCDE)
0a20	CODE	Compare X and BCDE bytewise
0a23	CODE	A	 bit 7 = C-flag
0a24	CODE	XOR with sign of BCDE
0a25	CODE	Continue at TEST2
0a26	CODE	; SUB for CP
*		; Compare X and BCDE bytewise
0a26	CODE	Compare Exp
0a29	CODE	If not equal: return
0a2e	CODE	1st LSB
0a32	CODE	2nd LSB
0a34	CODE	Subtract	 so that A = 00H in case E = (HL)
0a36	CODE	Remove RET address (0A23H)
0a37	CODE	Remove RET address (095E)
0a38	CODE	Return with A = 00H	 Z-flag = 1
0a39	CODE	; CP HL 	 DE (INT)
*		;
*		; I: -
*		; O: if HL < DE then A = FFH	 C-flag = 1	 Z-flag = 0	 S-flag = 1
*		;    if HL = DE then A = 00H	 C-flag = 0	 Z-flag = 1	 S-flag = 0
*		;    if HL > DE then A = 01H	 C-flag = 0	 Z-flag = 0	 S-flag = 0
0a39	CODE	Compare signs
0a3b	CODE	A = MSB (HL)
0a3c	CODE	If signs are not equal: continue at TEST2
0a3f	CODE	Compare MSBs
0a40	CODE	If not equal: goto TEST2
0a43	CODE	Compare LSBs
0a44	CODE	Subtract	 so that A = 00H in case E = L
0a45	CODE	If not equal: goto TEST2
0a49	CODE	; CP X 	 (DE) (DBL)
*		;
*		; I: -
*		; O: if X < (DE) then A = FFH	 C-flag = 1	 Z-flag = 0	 S-flag = 1
*		;    if X = (DE) then A = 00H	 C-flag = 0	 Z-flag = 1	 S-flag = 0
*		;    if X > (DE) then A = 01H	 C-flag = 0	 Z-flag = 0	 S-flag = 0
0a49	CODE	HL -> Y
0a4c	CODE	Copy (DE) to (HL)
0a4f	CODE	DE -> Exp (Y)
0a52	CODE	A = Exp (Y)
0a53	CODE	Y = 0 ?
0a54	CODE	Yes: execute TEST2
0a57	CODE	Set new RET address
0a5a	CODE	to TEST2
0a5b	CODE	TEST2
0a5e	CODE	DE = MSB (Y)
0a5f	CODE	A = MSB (Y)
0a60	CODE	C = MSB (Y) (for TEST2) X = 0 ?
0a61	CODE	Yes: TEST2 using Y
0a62	CODE	HL -> MSB (X)
0a65	CODE	Compare signs
0a66	CODE	A = MSB (Y) Signs not equal ?
0a67	CODE	Yes: TEST2
0a68	CODE	DE = Exp (Y)
0a69	CODE	HL = Exp (X)
0a6a	CODE	B = counter for 8 bytes
0a6c	CODE	Compare X and Y bytewise
0a6e	CODE	Byte from X = Byte from Y ? No: contineu at 0A23H
0a71	CODE	Pointer on Y - 1
0a72	CODE	Pointer on X - 1
0a73	CODE	Counter - 1
0a74	CODE	Compare next byte from X and Y
0a76	CODE	Remove RET address (095EH)
0a78	CODE	; CP X 	 Y (DBL)
*		;
*		; I: -
*		; O: if X < Y then A = FFH	 C-flag = 1	 Z-flag = 0	 S-flag = 1
*		;    if X = Y then A = 00H	 C-flag = 0	 Z-flag = 1	 S-flag = 0
*		;    if X > Y then A = 01H	 C-flag = 0	 Z-flag = 0	 S-flag = 0
0a78	CODE	Compare X and Y
0a7b	CODE	If X <> Y then goto TEST2
0a7f	CODE	; X = CINT (X)
*		; ------------
0a7f	CODE	TSTTYP
0a80	CODE	HL -> X INT type ?
0a83	CODE	Yes: return STR type ?
0a84	CODE	Yes: ?TM Error DBL type ?
0a87	CODE	Yes: convert to SNG
0a8a	CODE	Set new return address
0a8d	CODE	to 07B2H (= ?OV Error)
0a8e	CODE	A = Exp (X)
0a91	CODE	Exp > (2 ^ 16) ? (16 bit)
0a93	CODE	Yes: continue at 0AA3H
0a95	CODE	DE = INT (X)
0a98	CODE	HL = INT value
0a99	CODE	Remove new return address
0a9a	CODE	; This routine writes the contents of HL into the X register as INT
*		;
*		; I: HL = integer value
*		; O: X = integer value
*		;    A = VT of X (INT)
0a9a	CODE	Write HL in X
0a9d	CODE	; Set VT to INT
0a9d	CODE	A = type code INT
0a9f	CODE	Save VT
0aa3	CODE	; Continuation of CINT (X)
*		; X = -32768 ? (Is it still within the INT format ?)
0aa3	CODE	BCDE  = -32768
0aa9	CODE	Compare X and BCDE X = BCDE ?
0aac	CODE	No: ?OV Error
0aad	CODE	HL = -32768
0aaf	CODE	Remove RET address and set X = HL
0ab1	CODE	; X = CSNG (X)
*		; ------------
0ab1	CODE	TSTTYP SNG type ?
0ab2	CODE	Yes: return INT type ?
0ab3	CODE	Yes: continue at 0ACCH STR type ?
0ab6	CODE	Yes: ?TM Error DBL type:
0ab9	CODE	BCDE = X
0abc	CODE	VT = SNG
0abf	CODE	BCDE = 0 ?
0ac1	CODE	Yes: ok
0ac2	CODE	Adjust mantissas
0ac8	CODE	B = 3rd LSB (X) with DBL
0ac9	CODE	X = BCDE and round
0acc	CODE	; X = CSNG (X) (INT)
0acc	CODE	HL = INT value
0acf	CODE	; X = CSNG (HL) (INT)
0acf	CODE	VT = SNG
0ad2	CODE	A = MSB (HL)
0ad3	CODE	D = LSB (HL)
0ad4	CODE	E = 00H
0ad6	CODE	B = 90H (Exp = 2 ^ 16)
0ad8	CODE	SFLOAT (X)
0adb	CODE	; X = CDBL (X)
*		; ------------
0adb	CODE	TSTTYP DBL type ?
0adc	CODE	Yes: return STR type ?
0add	CODE	Yes: ?TM Error INT type ?
0ae0	CODE	Yes: CSGN
0ae6	CODE	Set 4 LSBs to zero
0aec	CODE	; Set VT to DBL
0aec	CODE	A = type code for DBL
0aee	CODE	--
0aef	ENTRY	; Set VT to SNG
0aef	ENTRY	A = type code for SNG
0af1	CODE	VT = A
0af4	CODE	; Test if X is string type. If not: ?TM Error else return
0af4	CODE	TSTTYP STR type ?
0af5	CODE	Yes: return
0af6	CODE	E = error code for ?TM Error
0af8	CODE	Continue at error routine
0afb	CODE	; SUB for INT	 FIX	 CINT
*		; I: X = SNG value with Exp <= 98H (2 ^ 24)
*		;    (so with fractional part)
*		;    A = Exp (X)
*		; O: DE = INT value of X
0afb	CODE	BCDE = A
0aff	CODE	Zero ?
0b00	CODE	Yes: return with DE = 0000H
0b01	CODE	Save HL
0b02	CODE	BCDE = X
0b05	CODE	Adjust mantissas
0b08	CODE	A	 bit 7 = Sign of BCDE or X
0b09	CODE	H	 bit 7 = Sign (X) X negative ?
0b0a	CODE	Yes: round BCDE
0b0d	CODE	A = Exp (2 ^ 24) (24 bit mantissa	 no fraction)
0b0f	CODE	A = 98H - Exp (X)
0b10	CODE	Shift CDE to the right for A bits (B becomes LSB) Shift out franctional part
0b13	CODE	A	 bit 7 = Sign (X)
0b14	CODE	C-flag = sign X negative ?
0b15	CODE	Yes: round up X
0b18	CODE	Clear LSB X negative ?
0b1a	CODE	Yes: Invert CDEB
0b1d	CODE	Restore HL
0b1f	CODE	; Round down BCDE
0b1f	CODE	Round LSBs
0b20	CODE	Test LSBs
0b21	CODE	Was DE = 0000H ?
0b22	CODE	Yes: then A now is 00H
0b23	CODE	Done when LSBs <> 0
0b24	CODE	Round MSBs
0b26	CODE	; X = FIX (X)
*		; -----------
0b26	CODE	TSTTYP INT type ?
0b27	CODE	Yes: return
0b28	CODE	TEST2 X < 0 ?
0b2b	CODE	No: X = INT(X)
0b2e	CODE	X = -X
0b31	CODE	X = INT(X)
0b34	CODE	X = ABS (X) and RET
0b37	CODE	; X = INT (X)
*		; -----------
0b37	CODE	TSTTYP INT type ?
0b38	CODE	Yes: return DBL type ?
0b39	CODE	Yes: continue at 0B59H STR type ?
0b3b	CODE	Yes: ?TM Error
0b3d	CODE	; X = INT (X) (SNG)
*		;
*		; I: X = single precision value
*		; O: X = single precision value without fractional part
*		;    A = LSB of integer value of X
0b3d	CODE	X = CINT (X) (SNG)
0b40	CODE	HL -> Exp (X)
0b43	CODE	A = Exp (X)
0b44	CODE	Exp >= (2 ^ 24) ? Yes: X has no fraction
0b46	CODE	A = LSB of X
0b49	CODE	Done when Exp (X) >= 98H
0b4a	CODE	A = Exp (X)
0b4b	CODE	Remove fractional part
0b4e	CODE	Set Exp to 2 ^ 24
0b50	CODE	A = LSB
0b51	CODE	Save LSB
0b52	CODE	A = MSB
0b53	CODE	Sign to C-flag
0b54	CODE	SFLOAT conversion CDEB to X
0b57	CODE	LSB back to A
0b59	CODE	; X = INT (X) (DBL)
0b59	CODE	HL -> Exp (X)
0b5c	CODE	A = Exp (X)
0b5d	CODE	Exp (X) < (2 ^ 16)
0b5f	CODE	Yes: execute CINT Exp (X) = (2 ^ 16)
0b62	CODE	No: continue at 0B78H
0b64	CODE	C = 90H (Exp = 2 ^ 16!)
0b65	CODE	HL = MSB (X)
0b66	CODE	A = MSB (X)
0b67	CODE	A = 00H	 if X = -32768
0b69	CODE	Test remaining 6 bytes
0b6b	CODE	Pointer - 1
0b6c	CODE	Test byte
0b6d	CODE	Counter - 1
0b6e	CODE	Next byte
0b70	CODE	All bytes = 00H ?
0b71	CODE	HL = -32768 (INT value)
0b74	CODE	Yes: Write HL to X as INT
0b77	CODE	A = Exp (X) = 90H (because of 0B64H)
0b78	CODE	Exp >= (2 ^ 56) ? (56 bit mantissa)
0b7a	CODE	Yes: no fractional part
0b7b	CODE	Save Exp
0b7c	CODE	BCDE = X (SNG)
0b7f	CODE	Adjust mantissas
0b82	CODE	A	 bit 7 = Sign of X or BCDE
0b83	CODE	HL -> Exp (X)
0b84	CODE	Set Exp to 2 ^ 56
0b86	CODE	Save sign X negative ?
0b87	CODE	Yes: round X
0b8a	CODE	HL -> MSB (X)
0b8d	CODE	A = Exp for 2 ^ 56
0b8f	CODE	Compute Exp-difference
0b90	CODE	(HL) - (HL-7) (corresponds with X) and shift A bits to the right: shift out the fractional part
0b93	CODE	Restore sign X negative ?
0b94	CODE	Yes: round up mantissa of X
0b97	CODE	A = 00H
0b98	CODE	Clear LSB-underflow of X
0b9b	CODE	Restore Exp in A
0b9c	CODE	Done when CALLed from 12B8H (Otherwise C-flag = 1 because of 0B7AH)
0b9d	CODE	Continue at DFLOAT
0ba0	CODE	; Round down mantissa of X (DBL)
0ba0	CODE	HL -> X
0ba3	CODE	A = byte of X
0ba4	CODE	Round down
0ba5	CODE	Was the byte 00H ?
0ba6	CODE	Pointer + 1
0ba7	CODE	Yes: next byte
0baa	CODE	; SUB for array size calculation with DIM
*		; DE = DE * BC
0baa	CODE	Save PTP
0bab	CODE	Result = 0000H
0bae	CODE	BC = 0 ?
0bb0	CODE	Yes: return with result = 0
0bb2	CODE	A = counter for 16 bit
0bb4	CODE	Shift result to the left Overflow ?
0bb5	CODE	Yes: ?BS Error
0bb8	CODE	Save HL
0bb9	CODE	Highest bit of DE to C-flag
0bba	CODE	Restore HL
0bbb	CODE	Jump when bit = 0
0bbd	CODE	Add BC to result Overflow ?
0bbe	CODE	Yes: ?BS Error
0bc1	CODE	Counter - 1
0bc2	CODE	Next bit
0bc4	CODE	Result in DE
0bc5	CODE	Restore PTP
0bc7	CODE	; ISUB: X = HL = DE - HL (INT)
*		;
*		; I: DE = Original value
*		;    HL = Subtractor
*		; O: HL = Difference when in INT range
*		;    X  = difference (automatic conversion to SNG format when result not
*		;    in INT range)
0bc7	CODE	A = MSB of HL
0bc8	CODE	C-flag - sign of HL
0bc9	CODE	If HL >= 0 then A = 00H            else A = FFH
0bca	CODE	B = A
0bcb	CODE	HL = = HL	 C-flag = 1
0bce	CODE	A = 00H (C = 00H by 0C51H)
0bcf	CODE	if HL was >= 0 then A = FFH
0bd0	CODE	Continue at IADD (do a DE = DE + (-HL)
0bd2	CODE	; IADD: X = HL = DE + HL (INT)
*		;
*		; I: DE = 1st sum argument
*		;    HL = 2nd sum argument
*		; O: HL = sum when in INT range
*		;    X  = sum (automatic conversion to SNG format when result not
*		;    in INT range)
0bd2	CODE	Calculate sign-flag
0bd3	CODE	(See ISUB)
0bd5	CODE	If HL >= 0 then B = 00H            else B = FFH
0bd6	CODE	Save 2nd sum argument
0bd7	CODE	Calculate sign of 2nd arg.
0bda	CODE	Perform addition
0bdb	CODE	Process sign-flags and
0bdc	CODE	overflow
0bdd	CODE	A	 bit 7 is set	 when an overflow occurs in case of both are equal or when no overflow occurs in case of both signs are not equal A	 bit 7 = 0 ?
0bde	CODE	Yes: result is ok No:
0be1	CODE	Save sign flag of 2nd arg.
0be2	CODE	HL = 1st sum argument
0be3	CODE	X = CSNG (HL)
0be6	CODE	Restore sign flag
0be7	CODE	Restore 2nd sum argument
0be8	CODE	(SP) = X = 1st argument
0beb	CODE	DE = 2nd argument
0bec	CODE	X = SFLOAT (DE)
0bef	CODE	X = X + (SP) (addition in SNG format)
0bf2	CODE	; IMUL: X = HL = DE * HL (INT)
*		;
*		; I: DE = multiplicant
*		;    HL = multiplicator (both values in INT format)
*		; O: HL = product when in INT range
*		;    X  = product (automatic conversion to SNG format when result not
*		;    in INT range)
0bf2	CODE	HL = 0000H ?
0bf4	CODE	Yes: Result = 0
0bf7	CODE	Save multiplicator
0bf8	CODE	Save multiplicant
0bf9	CODE	Clear sign	 make both numbers positive
0bfc	CODE	Save sign flag (B	 bit 7 = 0 in case both signs are equal)
0bfd	CODE	BC = HL
0bff	CODE	Result = 0
0c02	CODE	A = counter for 16 bits
0c04	CODE	Shift result to the left Overflow ?
0c05	CODE	Yes: continue at 0C26H
0c07	CODE	Next bit form De to C-flag
0c0a	CODE	Jump if bit not set
0c0c	CODE	Add BC to result if bit set Overflow ?
0c0d	CODE	Yes: continue at 0C26H
0c10	CODE	Counter - 1
0c11	CODE	Next bit
0c13	CODE	Restore sign flag
0c14	CODE	Restore multiplicant
0c15	CODE	Result negative ?
0c17	CODE	Yes: continue at 0C1FH
0c1a	CODE	Restore multiplicator
0c1b	CODE	A = sign-flag
0c1c	CODE	Set sign of result
0c1f	CODE	; Overflow into bit 15 (sign bit)
*		; Because both factors were made positive	 the result must also be positive.
*		; This means that the 16th bit must be 0.
0c1f	CODE	A = 00H when H = 80H
0c21	CODE	HL = 8000 = 32768 ? (no sign)
0c22	CODE	Yes: continue at 0C37H No:
0c24	CODE	HL = multiplicant
0c25	CODE	--
0c26	ENTRY	; Overflow at IMUL
*		; Convert both factors to SNG format and then perform a SMUL
0c26	ENTRY	B = sign-flag
0c27	ENTRY	HL = Multiplicant
0c28	CODE	X = CSNG (HL)
0c2b	CODE	HL = Multiplicator
0c2c	CODE	(SP) = X
0c2f	CODE	X = CSNG (HL)
0c32	CODE	BCDE = (SP)
0c34	CODE	X = BCDE * X (SNG)
0c37	CODE	; The result is 32768 (unsigned)
0c37	CODE	A = sign-flag
0c38	CODE	Signs not equal ?
0c39	CODE	Correct stack
0c3a	CODE	Yes: result = 8000H = -32768 No: result = +32768
0c3d	CODE	Save DE
0c3e	CODE	X = CSNG (HL) = -32768
0c41	CODE	Restore DE
0c42	CODE	X = -X (result = +32768)
0c45	CODE	; Sign test at IMUL:
*		; Clear sign at DE and HL (make both positive)
*		;
*		; I: DE = multiplicant
*		;    HL = multiplicator
*		; O: DE = ABS (multiplicator)
*		;    HL = ABS (multiplicant)
*		;    If both signs are equal then B	 bit 7 = 0
*		;                            else B	 bit 7 = 1
0c45	CODE	Sign from HL
0c46	CODE	XORed with sign from D
0c47	CODE	Result in B	 bit 7
0c48	CODE	HL = ABS (HL)
0c4b	CODE	Same with DE
0c4c	CODE	HL >= 0 ?
0c4e	CODE	Yes: ok
0c51	CODE	; X = HL = -HL (INT)
*		;
*		; I: HL = INT value
*		; O: HL = negative INT value
*		;    X = HL and VT = INT
0c51	CODE	A = 00H
0c52	CODE	C = 00H
0c54	CODE	L = 00H - L
0c55	CODE	A = 00H
0c57	CODE	H = 00H - H - C-flag
0c58	CODE	Write HL to X as INT
0c5b	CODE	; X = -X (INT)
*		; Conversion to SNG	 when X = -32768. This because +32768 is no longer
*		; in the INT range.
0c5b	CODE	HL = X
0c5e	CODE	X = HL = -HL
0c61	CODE	HL used to be -32768 ?
0c65	CODE	No : value ok
0c66	CODE	DE = value
0c67	CODE	VT = SNG
0c6a	CODE	A = 0
0c6b	CODE	B = Exp (2 ^ 24)
0c6d	CODE	SFLOAT (X)
0c70	CODE	; X = X - Y = X + (-Y) (DBL)
0c70	CODE	HL -> MSB (Y)
0c73	CODE	A = MSB (Y)
0c74	CODE	Y = -Y
0c76	CODE	Store MSB (Y)
0c77	CODE	; X = X + Y (DBL)
0c77	CODE	HL -> Exp (Y)
0c7a	CODE	A = Exp (Y)
0c7b	CODE	Exp (Y) = 0 ?
0c7c	CODE	Yes: X is the result
0c7d	CODE	B = Exp (Y)
0c7f	CODE	C = MSB (Y)
0c80	CODE	DE -> Exp (X)
0c83	CODE	A = Exp (X)
0c84	CODE	X = 0 ? (Exp (X) = 0)
0c85	CODE	Yes: X = Y
0c88	CODE	A = Exp (X) - Exp (Y) Exp (X) >= Exp (Y)
0c89	CODE	Yes: continue at 0CA1H No: swap X and Y
0c8b	CODE	A = -A
0c8c	CODE	A + 1 for 2 complement
0c8d	CODE	Save Exp-difference
0c8e	CODE	Swap 8 bytes
0c90	CODE	HL -> Exp (Y)
0c91	CODE	Save pointer
0c92	CODE	Swap bytes from (DE)
0c93	CODE	and (HL)
0c97	CODE	Pointer - 1
0c98	CODE	Pointer - 1
0c99	CODE	Counter - 1
0c9a	CODE	Next byte
0c9c	CODE	Restore pointer on Exp (X)
0c9d	CODE	B = Exp (X)
0c9f	CODE	C = MSB (X)
0ca0	CODE	Restore Exp-difference In X now the larger argument
0ca1	CODE	Exp-diff. > (2 ^ 56)
0ca3	CODE	Yes: Y is too small	 the sum would not alter X
0ca4	CODE	Save Exp-difference
0ca5	CODE	Adjust mantissas
0ca8	CODE	HL -> Exp (X)
0ca9	CODE	Set Exp to 0
0cab	CODE	B = sign-flag
0cac	CODE	Restore Exp-difference
0cad	CODE	HL -> Y
0cb0	CODE	Shift (HL) upto (HL-7) A bits to the right. This results in the same exponent for X and Y
0cb3	CODE	Copy underflow
0cb6	CODE	to X
0cb9	CODE	A = sign-flag
0cba	CODE	Equal signs ?
0cbb	CODE	No: continue at 0CCFH
0cbe	CODE	Add mantissas Overflow ?
0cc1	CODE	No: continue at 0D0EH
0cc4	CODE	Overflow: HL -> Exp (X)
0cc5	CODE	Exp (X) + 1 Overflow ?
0cc6	CODE	Yes: ?OV Error
0cc9	CODE	X = X / 2	 because the Exp + 1 means an X * 2
0ccc	CODE	Continue at 0D0EH
0ccf	CODE	; Unequal signs: subtract mantissas
0ccf	CODE	Subtract mantissas
0cd2	CODE	HL -> sign-flag Onderflow ?
0cd5	CODE	Yes: negate mantissa of X
0cd8	CODE	; DFLOAT (DBL)
*		; Shift DBL-mantissa to  the left until the highest bit of the mantissa
*		; is 1 and the exponent is as small as possible
0cd8	CODE	A = 00H
0cd9	CODE	B = shift-counter
0cda	CODE	A = MSB (X)
0cdd	CODE	MSB = 0 ?
0cde	CODE	No: test bits of MSB Yes: Shift X by 1 byte to the left
0ce0	CODE	HL -> underflow (X)
0ce3	CODE	C = counter for 8 bytes
0ce5	CODE	Get new byte
0ce6	CODE	Use old byte
0ce7	CODE	old byte = new byte
0ce8	CODE	Pointer + 1
0ce9	CODE	Counter - 1
0cea	CODE	Next byte
0cec	CODE	A = shift-counter
0ced	CODE	Subtract 8 (for 8 bits)
0cef	CODE	-64 reached ? (already 8 bytes shifted ?)
0cf1	CODE	No: test MSB again
0cf3	CODE	Yes: all bytes of X were 00H Set X = 0
0cf6	CODE	; Continue shifting bitwise
0cf6	CODE	Shift-counter - 1
0cf7	CODE	HL -> Underflow (X)
0cfa	CODE	Shift X by 1 bit to the left
0cfd	CODE	A = new MSB	 bit 7 = 1 ?
0cfe	CODE	No: shift again
0d01	CODE	A = shift-counter
0d02	CODE	Anything shifted ?
0d03	CODE	No: X ready
0d05	CODE	HL -> Exp (X)
0d08	CODE	Subtract number of shifted
0d09	CODE	bits from exponent Overflow ?
0d0a	CODE	No: X = 0
0d0d	CODE	Done when exponent = 0
0d0e	CODE	A = underflow byte
0d11	CODE	A	 bit 7 = 1
0d12	CODE	Yes: round up X
0d15	CODE	HL -> sign-flag
0d18	CODE	A = sign-flag
0d19	CODE	Mask sign. A	 bit 7 = 1 when equal sign
0d1c	CODE	HL -> MSB (X)
0d1d	CODE	XOR with MSB (X)
0d1e	CODE	Save new MSB incl. sign
0d20	CODE	; Round up X (DBL)
0d20	CODE	HL -> LSB of X (DBL)
0d23	CODE	B = mantissa size of DBL
0d25	CODE	Increment LSB Overflow ?
0d26	CODE	No: return
0d27	CODE	Next byte
0d28	CODE	Counter - 1 All mantissa bytes done ?
0d29	CODE	No: increment next mantissa byte
0d2b	CODE	Increment Exp (X) Overflow ?
0d2c	CODE	Yes: ?OV Error
0d2f	CODE	HL -> MSB mantissa
0d30	CODE	Set mantissa to negative
0d33	CODE	; Add mantissas of X and Y. Result in X
0d33	CODE	HL -> LSB of Y (DBL)
0d36	CODE	DE -> LSB of X (DBL)
0d39	CODE	C = mantissa size of DBL
0d3b	CODE	A = 0
0d3c	CODE	A = mantissa byte X
0d3d	CODE	A = A + mantissa byte Y       + C-flag
0d3e	CODE	Store result in X
0d3f	CODE	Pointer to X + 1
0d40	CODE	Pointer to Y + 1
0d41	CODE	Counter - 1 All mantissa bytes done ?
0d42	CODE	No	 add next mantissa bytes
0d45	CODE	; Subtract mantissas of X and Y. Result in X
0d45	CODE	HL -> LSB of Y (DBL)
0d48	CODE	DE -> LSB of X (DBL)
0d4b	CODE	C = mantissa size of DBL
0d4d	CODE	A = 0
0d4e	CODE	A = mantissa byte X
0d4f	CODE	A = A - mantissa byte Y       - C-flag
0d50	CODE	Store result in X
0d51	CODE	Pointer to X + 1
0d52	CODE	Pointer to Y + 1
0d53	CODE	Counter - 1 All mantissa bytes done ?
0d54	CODE	No	 add next mantissa bytes
0d57	CODE	; Negate mantissa of X (incl. underflow) and sign
0d57	CODE	A = sign-flag
0d58	CODE	Negation
0d59	CODE	Save sign-flag
0d5a	CODE	HL -> underflow (X)
0d5d	CODE	Negate 9 bytes
0d5f	CODE	A = 00H
0d60	CODE	C = 00H
0d61	CODE	A = C
0d62	CODE	A = A - (HL) - C-flag
0d63	CODE	Save difference
0d64	CODE	Pointer + 1
0d65	CODE	Counter - 1
0d66	CODE	Next byte
0d69	CODE	; Shift (HL) upto (HL-7) by A bits to the right
0d69	CODE	Save MSB
0d6a	CODE	Save pointer
0d6b	CODE	More than 8 bits to shift ?
0d6d	CODE	No: shift bits at 0D7DH
0d6f	CODE	Restore pointer
0d70	CODE	And save it again
0d71	CODE	Fill 8 bytes mantissa with 00H
0d74	CODE	C = new byte
0d75	CODE	(HL) = old byte
0d76	CODE	Old byte = new byte
0d77	CODE	Pointer - 1
0d78	CODE	Counter - 1
0d79	CODE	Shift next byte
0d7b	CODE	Shift anything more ?
0d7d	CODE	; Shift bitwise
0d7d	CODE	Reverse the SUB 08H
0d7f	CODE	D = counter
0d80	CODE	A = 00H
0d81	CODE	Restore pointer
0d82	CODE	Counter - 1
0d83	CODE	RET when done
0d84	CODE	Save pointer
0d85	CODE	8 bytes mantissa (with underflow)
0d87	CODE	A = byte
0d88	CODE	shift right (incl. C-flag)
0d89	CODE	Save byte
0d8a	CODE	Pointer - 1
0d8b	CODE	Counter - 1
0d8c	CODE	Next byte
0d8e	CODE	Any more to shift ?
0d90	CODE	; Shift mantissa of X one bit to the right
0d90	CODE	HL -> mantissa
0d93	CODE	D = counter for 1 bit
0d95	CODE	Continue at 0D84H
0d97	CODE	; Shift (HL) to (HL+7) one bit to the right
0d97	CODE	8 bits Mantissa (with underflow)
0d99	CODE	A = byte
0d9a	CODE	shift incl. carry
0d9b	CODE	Store byte
0d9c	CODE	Pointer + 1
0d9d	CODE	Counter - 1
0d9e	CODE	Shift next byte
0da1	CODE	; DMUL: X = X * Y (DBL)
*		;
*		; I: X = 1st factor (DBL)
*		;    Y = 2nd factor (DBL)
*		; O: X = product (DBL)
0da1	CODE	TEST2 X = 0 ?
0da4	CODE	Yes: return
0da5	CODE	process exponent and sign
0da8	CODE	Save mantissa of 1st factor in 414AH and clear mantissa of X
0dab	CODE	Underflow of X = 0
0dac	CODE	DE -> LSB of 1st factor
0dad	CODE	Process 7 bytes mantissa
0daf	CODE	A = byte from mantissa
0db0	CODE	Pointer + 1
0db1	CODE	No bit set ?
0db2	CODE	Save pointer
0db3	CODE	Yes: shift X 1 byte to the right and get next byte from 1st factor
0db5	CODE	8 bits per byte
0db7	CODE	Save counter
0db8	CODE	Test next bit Bit = 1 ?
0db9	CODE	Save byte first
0dba	CODE	Yes: add mantissa of X and Y
0dbd	CODE	Shift mantissa of X one bit to the right (next position)
0dc0	CODE	Restore byte
0dc1	CODE	Restore counter
0dc2	CODE	Bit counter - 1
0dc3	CODE	Test next bit
0dc5	CODE	Restore pointer
0dc6	CODE	Byte counter - 1
0dc7	CODE	Test next byte
0dc9	CODE	Continue at DFLOAT
0dcc	CODE	; Shift mantissa of X one byte to the right
0dcc	CODE	HL -> mantissa of X
0dcf	CODE	Shift one byte to the right
0dd2	CODE	Back to DMUL
0dd4	BYTES	; Constant 10 (DBL	 SNG)
0dd4	BYTES	Constant 10 (DBL)
0dd8	BYTES	Constant 10 (SNG)
0ddc	CODE	; X = X / 10 (DBL)
0ddc	CODE	DE -> Constant 10 (DBL)
0ddf	CODE	HL -> Y
0de2	CODE	Copy (DE) to (HL): Y = 10
0de5	CODE	; DDIV: X = X / Y (DBL)
*		;
*		; I: X = dividend (DBL)
*		;    Y = divisor (DBL)
*		; O: X = quotient
0de5	CODE	A = Exp (X)
0de8	CODE	zero ?
0de9	CODE	Yes: ?/0 Error
0dec	CODE	Process exponent and sign
0def	CODE	Adjust exponent
0df0	CODE	(see also SDIV)
0df1	CODE	Save dividend and set mantissa of X to 0
0df4	CODE	HL -> underflow of dividend
0df7	CODE	Clear underflow byte
0df8	CODE	Unterflow flag = 0
0df9	CODE	DE -> LSB of dividend
0dfc	CODE	HL -> LSB of divisor
0dff	CODE	Subtract mantissas
0e02	CODE	A = undeflow byte
0e03	CODE	A = A - C-flag (C-flag = 0)
0e04	CODE	Invert C-flag Underflow ?
0e05	CODE	No: continue at 0E12H Yes: reverse last subtract
0e07	CODE	DE -> LSB of dividend
0e0a	CODE	HL -> LSB of divisor
0e0d	CODE	Add mantissas
0e10	CODE	C-flag = 0
0e11	CODE	--
0e12	ENTRY	No underflow: write back undeflow byte
0e13	ENTRY	Underflow flag = 1
0e14	CODE	A = MSB of quotient
0e19	CODE	Shift bit 7 of A to C-flag for rounding purposes
0e1a	CODE	Done when highest bit = 1
0e1d	CODE	Shift back bit 7 of A
0e1e	CODE	HL -> LSB of quotient
0e21	CODE	7 bytes mantissa
0e23	CODE	Shift quotient one bit to the left
0e26	CODE	HL -> LSB of dividend
0e29	CODE	Shift dividend one bit to the left
0e2c	CODE	A = underflow byte
0e2d	CODE	Underflow occured ?
0e2e	CODE	No: process next bit Yes:
0e30	CODE	HL -> Exp (quotient)
0e33	CODE	Quotient = Quotient / 2 Exp = 0 ?
0e34	CODE	No: process next bit Yes:
0e36	CODE	?OV Error
0e39	CODE	; SUB for DDIV
*		; Save mantissa of X to 414AH to 4150H and set as result X to zero
0e39	CODE	A = MSB (Y)
0e3a	CODE	Write back MSB (Y)
0e3d	CODE	HL -> MSB (X)
0e3e	CODE	DE -> temp. memory space
0e41	CODE	Copy 7 bytes	 set to 00H
0e44	CODE	A = byte from X
0e45	CODE	Save it in (DE)
0e46	CODE	Clear mantissa of X
0e47	CODE	Pointer to temp. - 1
0e48	CODE	Pointer to X - 1
0e49	CODE	Counter - 1
0e4a	CODE	Next byte
0e4d	CODE	; X = X * 10 (DBL)
0e4d	CODE	Y = X
0e50	CODE	HL + 1 -> Exp (X)
0e51	CODE	HL -> Exp (X)
0e52	CODE	A = Exp (X)
0e53	CODE	X = 0 ?
0e54	CODE	Yes: done	 return
0e55	CODE	A = Exp(X) + 2 Overflow ?
0e57	CODE	Yes: ?OV Error
0e5a	CODE	Store Exp: X = X * 4
0e5b	CODE	Save pointer
0e5c	CODE	X = X + Y (now: X = X * 5)
0e5f	CODE	Restore pointer
0e60	CODE	Exp + 1: X = X * 2 (results in X = X * 10)
0e61	CODE	Return if no overflow
0e62	CODE	?OV Error
0e65	CODE	; Convert string to number (DBL)
*		; (like VAL function)
*		;
*		; I: HL -> string
*		; O: X = number (DBL)
0e65	CODE	X = 0
0e68	CODE	set VT to DBL
0e6b	CODE	Set flag <> 0
0e6c	ENTRY	; Convert string in a number according to type (INT	 SNG	 DBL)
*		; (like VAL function)
*		;
*		; I: HL -> string
*		; O: X = number
0e6c	ENTRY	Set flag = 0 First	 the routine will attempt to convert to an INT. In case of overflow	 it will attempt to convert to SNG or to DBL
0e6d	CODE	DE -> string
0e6e	CODE	B = 00 (number of positions after the decimal point) C = FFH (floating point flag: see 0EE4H and 0F29H)
0e71	CODE	HL = 0000H
0e72	CODE	(HL is initial value)
0e73	CODE	Write HL to X as INT
0e76	CODE	HL = pointer	 DE = 0000H
0e77	CODE	A = string character
0e78	CODE	Test for negative sign (Negative: Z-flag = 1)
0e7a	CODE	Save sign Negative sign ?
0e7b	CODE	Yes: continue at 0E83H
0e7e	CODE	Positive sign ?
0e80	CODE	Yes: continue at 0E83H
0e82	CODE	Pointer - 1 for RST 10H
0e83	CODE	A = next non-space character Digit ?
0e84	CODE	Yes: continue at 0F29H
0e87	CODE	'.' ?
0e8c	CODE	'E' ?
0e8e	CODE	Yes: continue at 0EA4H
0e90	CODE	'%' ? (INT indicator)
0e92	CODE	Yes: continue at 0EEEH
0e95	CODE	'#' ? (DBL indicator)
0e97	CODE	Yes: continue at 0EF5H
0e9a	CODE	'!' ? (SNG indicator)
0e9c	CODE	Yes: continue at 0EF6H
0e9f	CODE	'D' ?
0ea1	CODE	No: No digit or special character recognized: end of number string reached
0ea3	CODE	Yes: Set Z-flag = 0
0ea4	CODE	; 'E' (Z-flag = 1) or 'D' (Z-flag = 0)
0ea4	CODE	Convert X to SNG (Z-flag = 1) or DBL (Z-flag = 0)
0ea7	CODE	Save pointer
0ea8	CODE	Set new RET address to 0EBDH
0eab	CODE	and restore pointer
0eac	CODE	A = next character following 'D' or 'E'
0ead	CODE	D = FFH (-1)
0eae	CODE	'-' (BASIC token) ?
0eb0	CODE	Yes: continue at 0EBDH
0eb1	CODE	'-' ?
0eb3	CODE	Yes: continue at 0EBDH
0eb4	CODE	D = 00H (0)
0eb5	CODE	'+' (BASIC token) ?
0eb7	CODE	Yes: continue at 0EBDH
0eb8	CODE	'+' ?
0eba	CODE	Yes: continue at 0EBDH
0ebb	CODE	Pointer - 1 (for RST 10H)
0ebc	CODE	Remove RET address (0EBDH)
0ebd	CODE	A = exponent character digit found ?
0ebe	CODE	yes: continue at 0F94H No: exponent finished
0ec1	CODE	Exponent negative ? (D was FFH)
0ec2	CODE	No: continue at 0EC7H Yes:
0ec4	CODE	Negate exponent
0ec5	CODE	A = 00H - E
0ec6	CODE	E = correct exponent
0ec7	CODE	; Number in X is ready: process exponent / floating point / sign
0ec7	CODE	Save pointer
0ec8	CODE	A = exponent
0ec9	CODE	A = difference between exponent and number of positions after the decimal point. Larger than exponent ?
0eca	CODE	Yes: multiply X with 10
0ecd	CODE	No: divide X by 10 and difference + 1 Difference = 0 ?
0ed0	CODE	No: continue processing
0ed2	CODE	Restore pointer
0ed3	CODE	Restore sign
0ed4	CODE	Save pointer Negative sign ?
0ed5	CODE	Yes: X = -X
0ed8	CODE	Restore pointer
0ed9	CODE	TSTTYP DBL type ?
0eda	CODE	Yes : return
0edb	CODE	Save pointer
0edc	CODE	Set RET address to POP HL
0edf	CODE	(to restore pointer)
0ee0	CODE	X = -32768 ? Yes: convert X to INT
0ee3	CODE	RET and restore pointer
0ee4	CODE	; '.' found
0ee4	CODE	TSTTYP
0ee5	CODE	If point found for the first time then C = 00H else C > 00H Number done (C > 0) ?
0ee6	CODE	Yes: continue at 0EC7H X in INT format ?
0ee8	CODE	Yes: convert to SNG
0eeb	CODE	Get next character
0eee	CODE	; '%' (INT indicator) found
0eee	CODE	TSTTYP INT type ?
0eef	CODE	No: ?SN Error
0ef2	CODE	Pointer + 1
0ef3	CODE	Number is ready
0ef5	CODE	; '#' (DBL indicator) found
0ef5	CODE	Z-flag = 0
0ef6	CODE	; '!' (SNG indicator) found
0ef6	CODE	Convert number to SNG (Z-flag=1) or DBL (Z-flag=0)
0ef9	CODE	Pointer + 1	 number is ready
0efb	CODE	; Conversion into SNG or DBL
*		;
*		; I: Z-flag = 1: X = CSNG ( X )
*		;    Z-flag = 0: X = CDBL ( X )
*		; O: -
0efb	CODE	Save registers
0eff	CODE	Convert to SNG ? Yes: CSNG
0f02	CODE	Restore flags Convert to DBL ?
0f03	CODE	Yes: CDBL
0f06	CODE	Restore registers
0f0a	CODE	; X = X * 10 (SNG	DBL)
*		; Type conform multiplication with 10 of X
*		; Used at processing of the exponent and fractional part
*		;
*		; I: X = number (SNG or DBL format)
*		; O: X = X * 10
*		;    A = A - 1 (for exponent and fractional part processing)
0f0a	CODE	Difference between exponent and fractional part = 0 ? (Z-flag = 1); Yes: done	 return
0f0b	CODE	Save difference
0f0c	CODE	TSTTYP
0f0d	CODE	Save flags SNG type ?
0f0e	CODE	Yes: X = X * 10 (SNG)
0f11	CODE	Restore flags DBL type ?
0f12	CODE	Yes: X = X * 10 (DBL)
0f15	CODE	Restore difference
0f16	CODE	Difference - 1
0f18	CODE	; X = X / 10 (SNG	DBL)
*		; Type conform division by 10 of X
*		;
*		; I: X = number (SNG or DBL format)
*		; O: X = X / 10
*		;    A = A + 1 (for exponent and fractional part processing)
0f18	CODE	Save registers
0f1b	CODE	TSTTYP
0f1c	CODE	Save flags SNG type ?
0f1d	CODE	Yes: X = X / 10 (SNG)
0f20	CODE	Restore flags DBL type ?
0f21	CODE	Yes: X = X / 10 (DBL)
0f24	CODE	Restore registers
0f27	CODE	Difference + 1
0f29	CODE	; Process digit (C-flag = 1 because of previous RST 10H)
0f29	CODE	Save exponent flags
0f2a	CODE	A = number of fractional positions
0f2b	CODE	C = FFH If no fractional part recognized then C = FFH + C-flag (1)	 so A remains the same else C = 00H + C-flag (1) = 1	 so the number of positions behind the decimal pointer is incremented by one
0f2c	CODE	Result in B
0f2d	CODE	Save BC
0f2e	CODE	Save pointer
0f2f	CODE	A = digit (ASCII: '0' to '9')
0f30	CODE	A = value (numerical: 0 to 9)
0f32	CODE	Save digit
0f33	CODE	TSTTYP X still INT type ?
0f34	CODE	No: continue at 0F5DH
0f37	CODE	; Insert new digit into INT number
0f37	CODE	HL -> X (INT number)
0f3a	CODE	DE = 3277 (approx. 32767/10)
0f3d	CODE	Current number already larger than 3277 ?
0f3e	CODE	Yes	 inserting the new digit will cause the number to go outside of the INT range: the number has to be converted to SNG
0f40	CODE	DE = number
0f42	CODE	HL = HL * 2  = number *  2
0f43	CODE	HL = HL * 2  = number *  4
0f44	CODE	HL = HL + DE = number *  5
0f45	CODE	HL = HL * 2  = number * 10
0f46	CODE	Restore digit value
0f47	CODE	BC = digit value (B = fractional part = 0	 because the number is INT)
0f48	CODE	HL = number + new digit value
0f49	CODE	New number > 32767
0f4b	CODE	Yes: convert number to SNG
0f4e	CODE	X = HL = new number
0f51	CODE	Restore pointer
0f52	CODE	Restore decimal point
0f53	CODE	Restore exponent flag
0f54	CODE	Get next digit
0f57	CODE	; Overflow of INT
0f57	CODE	A = digit value
0f58	CODE	Save it
0f59	CODE	X = CSNG ( X )
0f5c	CODE	Set C-flag to 1 for indicate SNG processing DBL ?
0f5d	CODE	; Insert new digit into SNG (C-flag = 1) or DBL (c-flag = 0) number
0f5d	CODE	Yes: continue at 0F77H
0f5f	CODE	BCDE = 1E+6
0f65	CODE	Compare X and BCDE X already >= 1E+6 ?
0f68	CODE	Yes: convert X to DBL	 because the new number X gets more than 6 positions and will go outide the SNG range
0f6b	CODE	X = X * 10
0f6e	CODE	A = digit value
0f6f	CODE	X = X + A (SNG)
0f72	CODE	Get next digit
0f74	CODE	; Overflow of SNG
0f74	CODE	X = CDBL ( X )
0f77	CODE	; Insert new digit into DBL number
0f77	CODE	X = X * 10 (DBL)
0f7a	CODE	Y = X
0f7d	CODE	A = digit value
0f7e	CODE	X = A
0f81	CODE	X = CDBL ( X )
0f84	CODE	X = X + Y
0f87	CODE	Get next digit
0f89	CODE	; X = X + A (SNG)
0f89	CODE	(SP) = X
0f8c	CODE	X = A
0f8f	CODE	; X = X + (SP) (SNG)
0f8f	CODE	BCDE = (SP)
0f91	CODE	X = X + BCDE
0f94	CODE	; Digit found after 'E' or 'D'
0f94	CODE	A = current exponent
0f95	CODE	Exponent >= 10 ? Already two exponent postions recognized ? (one position can only give a maximum of 9)
0f97	CODE	Yes: set exponent to 48 to force an overflow
0f99	CODE	A = A * 2 = exponent *  2
0f9a	CODE	A = A * 2 = exponent *  4
0f9b	CODE	A = A * E = exponent *  5
0f9c	CODE	A = A * 2 = exponent * 10
0f9d	CODE	Insert new exponent digit
0f9e	CODE	Subtract 30H	 because an ASCII value was inserted (Result is always positive	 because (HL) is in the range from 30H to 39H ('0' to '9'))
0fa0	CODE	E = new exponent
0fa1	CODE	-- (positive result!)
0fa2	ENTRY	Exponent = 48 at overflow
0fa4	CODE	Get next exponent digit
0fa7	CODE	; Print 'in' followed by number in HL (routine for Error and Break)
0fa7	CODE	Save number
0fa8	CODE	HL -> ' in '
0fab	CODE	Print text
0fae	CODE	Restore number
0faf	CODE	; Print HL as decimal number (routine for printing line numbers with LIST)
0faf	CODE	Write HL to X as INT
0fb2	CODE	A = 00H: no formatting
0fb3	CODE	Store formatting byte and clear sign
0fb6	CODE	A = 20H (bit 7 of A = 0)
0fb7	CODE	Generate unformatted string
0fba	CODE	Print string
0fbd	CODE	; Conversion of X into an unformatted string (for PRINT)
*		; (like STR$ function)
*		;
*		; I: X = number
*		; O: HL -> string (= 4130H)
0fbd	CODE	Clear format byte
0fbe	CODE	; Conversion of X into a formatted string (for PRINT USING)
*		; (like STR$ function)
*		;
*		; I: X = number
*		;    A = formatting code: Bit 7 = 1: do a format
*		;                         Bit 6 = 1: print '	' for separation of thousands
*		;                         Bit 5 = 1: fill leading spaces with '*'
*		;                         Bit 4 = 1: print '$' in front of number
*		;                         Bit 3 = 1: print sign (also '+')
*		;                         Bit 2 = 1: print sign behind number
*		;                         Bit 1 = -: not used
*		;                         Bit 0 = 1: print exponent
*		;
*		; O: HL -> start of string (= 4130H)
*		;    DE -> end of string
0fbe	CODE	Store format byte Clear sign position in buffer and set HL to start of buffer ( = 4130H)
0fc1	CODE	Sign requested ?
0fc3	CODE	No: continue at 0FC7H
0fc5	CODE	First set sign to '+'
0fc7	CODE	Save HL in DE
0fc8	CODE	TEST1
0fcb	CODE	Restore HL X positive ?
0fcc	CODE	Yes: leave sign as it is
0fcf	CODE	Set sign to '-'
0fd1	CODE	Save BC
0fd2	CODE	Save HL
0fd3	CODE	X = -X (X is processed as a positive value because the sign is already in the buffer)
0fd6	CODE	Restore HL
0fd7	CODE	Restore BC
0fd8	CODE	Z-flag = 0 X is now positive Z-flag = 1 in case X = 0
0fd9	CODE	Pointer + 1
0fda	CODE	Put '0' in buffer
0fdc	CODE	A = format byte
0fdf	CODE	Save it in D
0fe0	CODE	C-flag = bit 7 of A
0fe1	CODE	A = VT Formatting required ?
0fe4	CODE	Yes: continue at 109AH Number is zero ?
0fe7	CODE	Yes: done	 continue at 1092H
0fea	CODE	Is X an INT (VT < 4) ?
0fec	CODE	No: continue at 103DH
0fef	CODE	; Convert INT number to unformatted string
0fef	CODE	B = 0: do not generate a decimal point C = 0: no separator of thousands
0ff2	CODE	Convert number into unformatted string using 5 digits (incl. leading zeroes)
0ff5	CODE	; Delete leading zeroes or replace them by '*'
0ff5	CODE	HL -> buffer
0ff8	CODE	B = sign (' ' or '-')
0ff9	CODE	C = ' '
0ffb	CODE	A = format byte
0ffe	CODE	E = format byte
0fff	CODE	Fill space with '*' ?
1001	CODE	No: continue at 100AH
1003	CODE	A = sign
1004	CODE	Sign = ' ' ?
1005	CODE	C = '*'
1007	CODE	No: sign = '-'	 goto 100AH
1009	CODE	Replace sign (' ') by '*'
100a	CODE	Write ' ' or '*' into buffer
100b	CODE	A = next character End of string ?
100c	CODE	Yes: continue at 1022H
100e	CODE	'E' found ?
1010	CODE	Yes: string end ('E' does not belong to INT format)
1012	CODE	'D' found ?
1014	CODE	Yes: string end ('D' does not belong to INT format)
1016	CODE	Leading zero ?
1018	CODE	Yes: replace by ' 'or '*'
101a	CODE	'	' found ?
101c	CODE	Yes: replace by ' ' or '*'
101e	CODE	'.' found
1020	CODE	No: continue at 1025H
1022	CODE	Yes: decimal point found
1023	CODE	Replace by '0'
1025	CODE	A = format byte
1026	CODE	'$' in front of number ?
1028	CODE	No: continue at 102DH
102a	CODE	Yes: insert '$'
102d	CODE	A = format byte
102e	CODE	Print sign behind number ?
1030	CODE	Yes: string is ready	 return
1031	CODE	No: put back sign in front of
1032	CODE	number
1034	CODE	; Save format byte	 set HL to start of buffer and clear sign
1034	CODE	Save format byte in system RAM
1037	CODE	HL -> start of buffer
103a	CODE	Clear sign in buffer
103d	CODE	; X is in floating point format
*		; Generate unformatted string
103d	CODE	if SNG then C-flag = 1        else C-flag = 1
103f	CODE	Save pointer
1040	CODE	If SNG then A = 3 if DBL then A = 8
1042	CODE	* 2 gives the number of decimal positions to be generated  - 1
1043	CODE	D = A
1044	CODE	D = maximum number of positions (7 for SNG	 17 for DBL)
1045	CODE	Scale X to 6 / 16 positions A = exponent offset ( = number of decimal point shifts to the left during scaling)
1048	CODE	B = 3 (decimal point pos. + 1) C = 0 (no thousands separator)
104b	CODE	A = exponent-offset + maximum number of positions = 10-exponent + 2 10-exponent < -2 ?
104c	CODE	Yes: continue at 1057H
104f	CODE	Position mnumber + 1 smaller
1050	CODE	than 10-exponent + 2
1051	CODE	Yes: continue at 1057H
1053	CODE	10-exponent + 3 = decimal point position + 1
1054	CODE	B = decimal point pos. + 1
1055	CODE	A = 2 because of SUB 02H: no 10-exponent is printed
1057	CODE	A = 10-exponent
1059	CODE	Restore buffer pointer
105a	CODE	Save 10-exponent
105b	CODE	Set '	' and '.'	 B - 1
105e	CODE	Use '0'
1060	CODE	Pointer + 1 when decimal point set
1063	CODE	Convert X into unformatted string with 7 / 17 positions Use decimal point after B positions
1066	CODE	Pointer - 1
1067	CODE	A = character
1068	CODE	Trailing zero ?
106a	CODE	Yes: pointer = last character unequal to '0'. (trailing zeroes are represented by 10-exponent)
106c	CODE	Last character is the decimal point ? Yes: leave pointer alone	 decimal point is deleted
106e	CODE	No: pointer + 1
1071	CODE	Restore 10-exponent 10-exponent = 0 ?
1072	CODE	Yes: done	 continue at 1093H
1074	CODE	; Use 10-exponent
*		; A = 10-exponent
1074	CODE	Save 10-exponent
1075	CODE	TSTTYP
1076	CODE	A = ASCII value of 'D' / 2
1078	CODE	A = A *2 + C-flag A = 'E' (X in SNG format) A = 'D' (X in DBL format)
1079	CODE	Put correct exponent character in buffer
107a	CODE	Pointer + 1
107b	CODE	Restore 10-exponent
107c	CODE	Assume positve sign 10-exponent > 0 ?
107e	CODE	Yes: continue at 1085H
1081	CODE	Use '-' instead
1083	CODE	Negate exponent (so treat it
1084	CODE	as a positive number)
1085	CODE	B = ASCII value of '0' - 1
1087	CODE	B + 1 (next digit in the tenth position
1088	CODE	Subtract 10 for 10-exponent 10-exponent < 10 ?
108a	CODE	No: increment digit again
108c	CODE	+ 3AH gives correct ASCII value for remaining position
108e	CODE	Pointer + 1
108f	CODE	Set first position of exp.
1090	CODE	Pointer + 1
1091	CODE	Set second position of exp.
1092	CODE	; Terminate string with 00H
1092	CODE	Pointer + 1
1093	CODE	Terminate with 00H
1095	CODE	DE -> end of string
1096	CODE	HL -> start of string
109a	CODE	; Formatting required
*		;
*		; I: A= VT
*		;    BC = position counter before and after decimal point
*		;    D = format byte
*		;    HL -> buffer
109a	CODE	Pointer + 1
109b	CODE	Save counters
109c	CODE	X in INT format ?
109e	CODE	A = format byte
109f	CODE	No: continue at 1109H
10a2	CODE	; Convert INT number into formatted string
10a2	CODE	C-flag = bit 0 of A Use 10-exponent ?
10a3	CODE	Yes: continue at 11A3H (convert number to SNG)
10a6	CODE	B = maximum number of positions before decimal point C = counter for thousands separation
10a9	CODE	Set C = 0 if no thousands separation required
10ac	CODE	Restore counters D = number of positions before decimal point E = number of positions after decimal point
10ad	CODE	A = number of positions before decimal point
10ae	CODE	More than 4 positions ?
10b0	CODE	Yes: use corresponding number of leading zeroes
10b3	CODE	Convert X into 5 digit string
10b6	CODE	E = number of positions after decimal point
10b7	CODE	Any positions at all ?
10b8	CODE	Yes: buffer pointer -1
10bb	CODE	Any positions required ?
10bc	CODE	Yes: use corresponding number of zeroes
10bf	CODE	Save pointer on end of buffer
10c0	CODE	Delete leading zeroes or replace them by '*'
10c3	CODE	Restore buffer pointer Sign in front ?
10c4	CODE	yes: continue at 10C8H
10c6	CODE	Set sign behind the number
10c7	CODE	Pointer + 1
10c8	CODE	Terminate string
10ca	CODE	HL -> Start of buffer - 1
10cd	CODE	Pointer + 1
10ce	CODE	A = LSB of buffer address of decimal point
10d1	CODE	-LSB of current buffer pointer
10d2	CODE	Equals the requested number of positions before the decimal point ?
10d3	CODE	Yes: done	 return
10d4	CODE	; Shift string in buffer
*		; Delete a position before the decimal point (means deleting a space)
10d4	CODE	Get next character from buffer
10d5	CODE	Is it a leading space ?
10d7	CODE	Yes: skip it	 next character
10d9	CODE	'*' in front of number ?
10db	CODE	Yes: skip it	 next character
10dd	CODE	Pointer - 1
10de	CODE	Save pointer (now points on sign character or the first digit or '$')
10df	CODE	Save character on stack
10e0	CODE	Set new RET address to 10DFH
10e4	CODE	Search start of number string and get next character
10e5	CODE	'-' found ?
10e7	CODE	Yes: save character	 next character
10e8	CODE	'+' found ?
10ea	CODE	Yes: save character	 next character
10eb	CODE	'$' found ?
10ed	CODE	Yes: save character	 next character
10ee	CODE	Remove RET adress
10ef	CODE	Leading zero found ?
10f1	CODE	No: field overflow! Yes:
10f3	CODE	Pointer + 1	 skip leading zero
10f4	CODE	Get next character Is it a digit ?
10f5	CODE	No: field overflow! Yes:
10f7	CODE	Pointer - 1 (string starts one position earlier in the buffer)
10f8	CODE	--
10f9	ENTRY	Buffer pointer - 1
10fa	ENTRY	Store character back into the buffer
10fb	CODE	Get character from stack Start of string reached ?
10fc	CODE	No: store next character Yes:
10fe	CODE	Remove buffer pointer from stack
10ff	CODE	Number of positions now ok ?
1102	CODE	; Field overflow
*		; More positions before decimal point are generated as there are reqeusted
1102	CODE	Get character from stack Last character ?
1103	CODE	No: get next character Yes:
1105	CODE	Restore buffer pointer to start of string
1106	CODE	Use '%' to indicate overflow
1109	CODE	; Formatting requested
*		; X is in floating point format
1109	CODE	Save pointer
110a	CODE	C-flag = bit 0 of A; exponent output requested ?
110b	CODE	Yes: continue at 11AAH X in SNG format ?
110e	CODE	Yes: continue at 1124H
1110	CODE	; X in DBL format
*		; Generate number string without exponent
*		; (X must not have more that 16 positions before the decimal point. This
*		; means that X must be smaller than 1D+16)
1110	CODE	DE -> 1D+16
1113	CODE	CP X	(DE) = CP X	1D+16
1116	CODE	D = maximum number of positions (16) X < 1D+16 ?
1118	CODE	Yes: continue at 1132H
111b	CODE	; Field overflow with floating point number
111b	CODE	Restore buffer pointer
111c	CODE	Restore counters
111d	CODE	Generate unformatted string
1120	CODE	Buffer pointer - 1
1121	CODE	Use '%' in front of string to indicate overflow
1124	CODE	; X has SNG format
1124	CODE	BCDE = 1E+16
112a	CODE	CP X	BCDE = CP X	1E+16 X > 1E+16 ?
112d	CODE	Yes: field overflow
1130	CODE	D = maximum number of positions (6)
1132	CODE	TEST2 (number = 0 ?)
1135	CODE	No: scale number to 6 or 16 positions
1138	CODE	Restore pointer
1139	CODE	Restore counters on number of positions before and after the decimal point Did scale operation extend ?
113a	CODE	Yes: continue at 1157H
113d	CODE	; The scale operation resulted in truncation (no fractional digits)
*		; A = exponent offset ( > 0 )
113d	CODE	Save counters
113e	CODE	E = exponent offset
113f	CODE	A = number of positions before the decimal point
1140	CODE	- maximum number of positions
1141	CODE	- exponent offset
1142	CODE	Use corresponding number of leading zeroes
1145	CODE	Compute decimal point position and thousand separation
1148	CODE	Convert floating point number into unformatted string
114b	CODE	A = exponent offset
114c	CODE	Set corresponding number of trailing zeroes (because 10-exponent is not used)
114f	CODE	A = exponent offset
1150	CODE	Use decimal point if necessary
1153	CODE	Restore positions counters
1154	CODE	Number of positions ok ?
1157	CODE	; The scale operation resulted in extension (fractional digits presents)
*		; A = exponent offset ( < 0 )
1157	CODE	E = exponent offset
1158	CODE	A = number of requested positions after the decimal point
1159	CODE	Any positions requested ?
115a	CODE	Yes: A - 1 (because of decimal point)
115d	CODE	A = number of positions after the decimal point + exponent offset = negative number of the superfluous generated positions at scaling
115e	CODE	If too many positions generated then leave A as it is
1161	CODE	else set A = 0
1162	CODE	Save position counters
1163	CODE	Save number of positions generated too many
1164	CODE	X = X / 10 	 A + 1
1167	CODE	Reverse scaling until the requested number of positions behind the decimal point is reached
116a	CODE	B = neagative number of positions generated too many
116b	CODE	A = exponent offset
116c	CODE	+ number of positions generated too many
116d	CODE	Restore position counters
116e	CODE	E = exponent offset ( < 0!)
116f	CODE	Is the exponent offset + the maximum number of requested positions before the decimal point < 0 ? (this means no positions before the decimal point)
1170	CODE	A = number of positions before the decimal point
1171	CODE	Yes: continue at 117FH
1174	CODE	A = number of positions before decimal point - maximum number of positions before decimal point
1175	CODE	- exponent offset
1176	CODE	Set corresponding number of leading zeroes in buffer
1179	CODE	Saev position counters
117a	CODE	Compute decimal point position and counter for thousands separation
117d	CODE	continue at 1190H
117f	CODE	; No positions before decimal point present (only a fractional part	 see 116EH)
117f	CODE	Simulate requested field length before decimal point by using leading zeroes
1182	CODE	A = number of requested positions behind the decimal point + 1
1183	CODE	Set decinal point	 C = B
1186	CODE	Write field length after decimal point back to C
1187	CODE	A = 0
1188	CODE	A = A - maximum number of positions
1189	CODE	+ exponent offset (+ because E < 0)
118a	CODE	Set corresponding number of trailing zeroes after the decimal point
118d	CODE	Save position counters
118e	CODE	B = 0 (A = 0 because of 1269H)
118f	CODE	C = 0: use no decimal point and no separation of thousands
1190	CODE	Generate unformatted string
1193	CODE	Restore position counters
1194	CODE	A = requested number of positions behing the decimal point. Any positions behind the decimal point specified ?
1195	CODE	Yes: leave buffer pointer as it is (buffer pointer points at the last string char! )
1197	CODE	No: set buffer pointer to the position of the decimal point (= end of string!)
119a	CODE	A = number of requested positions behind the decimal point + 1 + exponent offset
119b	CODE	Adjust because of + 1
119c	CODE	Set corresponding number of trailing zeroes after the decimal point
119f	CODE	D = number of requested positions before decimal point
11a0	CODE	Continue at 10BFH
11a3	CODE	; INT number using exponential format
*		; For this	 X has to be converted to SNG format
11a3	CODE	Save buffer pointer
11a4	CODE	Save format byte
11a5	CODE	X = CSNG ( X )
11a8	CODE	Restore format byte
11a9	CODE	A = 0 (Z-flag = 1 because X in SNG format) SNG number ?
11aa	CODE	; SNG or DBL number using exponential format
11aa	CODE	Yes: continue at 11B0H
11ad	CODE	E = maximum number of positions (16)
11af	CODE	--
11b0	ENTRY	E = maximum number of positions (16)
11b2	CODE	TEST2. X = 0 ?
11b5	CODE	C-flag = 1
11b6	CODE	No	 scale X to 6 (SNG) or 16 (DBL) positions
11b9	CODE	Restore buffer pointer
11ba	CODE	Restore position counters
11bb	CODE	Save exponent offset
11bc	CODE	A = number of positions behind the decimal point
11bd	CODE	Any positions behind decimal point specified ?
11be	CODE	Save number of positions
11bf	CODE	Yes: A - 1 (because of decimal point)
11c2	CODE	+ number of positions in front of the decimal point
11c3	CODE	C = total length
11c4	CODE	A = format byte
11c5	CODE	Print sign behind number ?
11c7	CODE	No: C-flag = 1
11c9	CODE	If not then A = FFH (-1)
11ca	CODE	D = A
11cb	CODE	A = total length	 left alone if sign is to printed in front else decrement it by 1
11cc	CODE	C = total length
11cd	CODE	A = requested total length of string - maximum number of positions
11ce	CODE	Save difference
11cf	CODE	Save total length Is the requested number of positions < generated number of positions
11d0	CODE	Yes: X = X / 10	 A - 1
11d3	CODE	Scale X according to difference
11d6	CODE	Restore total length
11d7	CODE	Restore difference
11d8	CODE	Save total length
11d9	CODE	Save difference Total length > number of positions ?
11da	CODE	Yes: continue at 11DEH
11dd	CODE	A = 0
11de	CODE	A = positive difference
11e0	CODE	+ number of requested positions on front of decimal point
11e1	CODE	+ 1
11e2	CODE	-1 if case of sign being printed in front of the number
11e3	CODE	= decomal point position
11e4	CODE	Set no thousands separation
11e6	CODE	Generate unformatted string
11e9	CODE	Restore position difference
11ea	CODE	Use corresponding number of trailing zeroes
11ed	CODE	Restore position counters
11ee	CODE	A = requested number of positions behind the decimal point. Any positions requested ?
11ef	CODE	No: buffer pointer - 1 (remove decimal point again)
11f2	CODE	Restore exponent offset X = 0 ? (see 11B5H)
11f3	CODE	Yes: 10-exponent is also 0 No:
11f5	CODE	Add maximum number of positions
11f6	CODE	subtract number of already generated positions in front of decimal point
11f7	CODE	Reverse addition of 11E2H = 10-exponent
11f8	CODE	Save number of positions in front of decimal point
11f9	CODE	Use 10-exponent
11fc	CODE	HL = end pointer
11fd	CODE	D = number of requested positions
11fe	CODE	Continue at 10BFH
1201	CODE	; Scaling:
*		; Scale X to 6 (SNG) or 16 (DBL) positions in front of decimal point
*		; O: A = 10-exponent offset
1201	CODE	Save DE
1202	CODE	Exponent offset = 00H
1203	CODE	Save exponent offset
1204	CODE	TSTTYP X in SNG format ?
1205	CODE	Yes: continue at 1222H
1208	CODE	; X in DBL format
1208	CODE	A = Exp (X)
120b	CODE	X >= 2 ^ 16 ?
120d	CODE	Yes: continue at 1222H
1210	CODE	DE -> 1D+10
1213	CODE	HL -> Y
1216	CODE	(HL) = (DE): Y = 1D+10
1219	CODE	X = X * Y - X * 1D+10
121c	CODE	Restore exponent offset
121d	CODE	Exponent offset - 10 (shifted 10 decimal positions)
121f	CODE	Save exponent offset
1220	CODE	Repeat until X >= 2 ^ 16
1222	CODE	; X in SNG format / X >= 65536 when in DBL format
1222	CODE	Divide X by 10 until X < 1E+6 (SNG) or X < 1D+16 (DBL)
1225	CODE	; X is now < 1E+6 (SNG) or < 1D+16 (DBL)
1225	CODE	TSTTYP X in DBL format ?
1226	CODE	Yes: continue at1233H
1228	CODE	; X has SNG format
1228	CODE	BCDE = 1E+5
122e	CODE	CP X	BCDE = CP X	1E+5
1231	CODE	Continue at 1239H
1233	CODE	; X has DBL format
1233	CODE	DE -> 1D+15
1236	CODE	CP X	(DE) = CP X	1D+15 X >= 1D+15 (DBL) ? X >= 1E+5 (SNG) ?
1239	CODE	Yes: done
123c	CODE	Restore exponent offset
123d	CODE	X = X + 10 (SNG	DBL)	 A - 1
1240	CODE	Save exponent offset
1241	CODE	Repeat until X >= 1E+5 (SNG)
1243	CODE	; X >= 1E+6 (SNG) or X >= 1D+16 (DBL)
*		; (Continuation of 124FH)
1243	CODE	Restore exponent offset
1244	CODE	X = X / 10	 A + 1
1247	CODE	Save exponent offset
1248	CODE	Test again
124b	CODE	; Scaling finished
*		;
*		;  1E+5 <= X < 1E+6 (SNG)
*		; 1D+15 <= X < 1D+16 (DBL)
124b	CODE	Restore exponent offset
124c	CODE	C-flag = 0 (for 11B5H)
124d	CODE	Restore DE
124f	CODE	; Divide X by 10 until X < 1E+6 (SNG) or X < 1D+16 (DBL)
124f	CODE	TSTTYP X in DBL format ?
1250	CODE	Yes: continue at 125EH
1253	CODE	; X has SNG format
1253	CODE	BCDE = 1E+6
1259	CODE	CP X	BCDE = CP X	1E+6
125c	CODE	Continue at 1264H
125e	CODE	; X has DBL format
125e	CODE	DE -> 1D+16
1261	CODE	CP X	(DE) = CP X	 1D+16
1264	CODE	HL = RET address X >= 1E+6 (SNG) ? X >= 1D+16 (DBL) ?
1265	CODE	Yes: continue at 1243H
1268	CODE	RET
1269	CODE	; Write A zeroes into buffer from (HL) onwards
*		; (positions after the decimal point)
1269	CODE	Counter = 0 ?
126a	CODE	Yes: done	 return
126b	CODE	Counter - 1
126c	CODE	Put a '0' into buffer
126e	CODE	Pointer + 1
126f	CODE	Done ? Counter zero ?
1271	CODE	; Write A zeroes into buffer from (HL) onwards and set '	' and '.'
*		; (positions before the decimal point)
1271	CODE	No: continue at 1277H
1273	CODE	Yes: done	 return
1274	CODE	Set '	' and '.'
1277	CODE	Put a '0' into buffer
1279	CODE	Pointer + 1
127a	CODE	Counter - 1
127b	CODE	Done ?
127d	CODE	; Establish decimal point position and counter for thousands separation
127d	CODE	A = exponent offset
127e	CODE	+ maimum number of generated positions
127f	CODE	+ 1
1280	CODE	= decimal point position (=number of positions before the decimal point) Ccompute counter for thousands separation
1281	CODE	+ 1
1282	CODE	A = A DIV 3
1284	CODE	(Integer division)
1286	CODE	+5
1288	CODE	Results in counter for thousands separation
1289	CODE	A = format byte
128c	CODE	Thousands separation required?
128e	CODE	Yes: B and C are ok	 return
128f	CODE	Set C to 0
1291	CODE	; Set '	' and '.'
*		;
*		; I: B = number of remaining positions before the decimal point (until
*		;        decimal point)
*		;    C = number of remaining digits until next thousand separation
*		;    C = 0: do not separate thousands
1291	CODE	Positions before decimal point - 1 Decimal point reached ?
1292	CODE	No: set '	'
1294	CODE	Put '.' into buffer
1296	CODE	; Save buffer pointer to decimal point
*		; Do not separate thousands
1296	CODE	Save buffer pointer
1299	CODE	Pointer + 1
129a	CODE	C = 0 (no thousand separation)
129c	CODE	; Decimal point not reached yet: insert thousands separation
129c	CODE	Next thousand position reached ?
129d	CODE	No: done	 return
129e	CODE	Yes	 put '	' into buffer
12a0	CODE	Pointer + 1
12a1	CODE	Counter = 3 for next thousands position
12a4	CODE	; Convert floating point number to unformatted string
12a4	CODE	Save DE
12a5	CODE	TSTTYP SNG ?
12a6	CODE	Yes: continue at 12EAH
12a9	CODE	; X in DBL format (and 1D+15 <= X < 1D+16 !)
*		; Generate unformatted string with 17 positions
*		; (10 positions using DBL-mantissas	 2 positions using SNG-mantissas
*		; and 5 positions with INT-format)
12a9	CODE	Save position counters
12aa	CODE	Save buffer pointer
12ab	CODE	Y = X
12ae	CODE	HL -> Constant 0.5 (DBL)
12b1	CODE	X = (HL) = 0.5
12b4	CODE	X = X + Y = 0.5 + Y (Round up X)
12b7	CODE	C-flag = 0
12b8	CODE	Clear positions behind the decimal point
12bb	CODE	Restore buffer pointer
12bc	CODE	Restore position counters
12bd	CODE	DE -> DBL-mantissas
12c0	CODE	A = counter (10 DBL-mantissas from (DE) onwards)
12c2	CODE	Set '	' and '.'
12c5	CODE	Save position counters
12c6	CODE	Save mantissa counter
12c7	CODE	Save buffer pointer
12c8	CODE	Save mantissa pointer
12c9	CODE	B = ASCII '0' - 1
12cb	CODE	Next digit
12cc	CODE	HL = mantissa pointer
12cd	CODE	Save it again
12ce	CODE	X = X - (HL): subtract mantissa. Underflow ?
12d1	CODE	No: next digit
12d3	CODE	Yes: restore mantissa pointer
12d4	CODE	X = X + (HL): reverse last subtract
12d7	CODE	DE = mantissa pointer
12d8	CODE	HL = buffer pointer
12d9	CODE	Insert digit in buffer
12da	CODE	Update buffer pointer to next position
12db	CODE	Restore maintissa counter
12dc	CODE	Restore position counters
12dd	CODE	Mantissa counter - 1
12de	CODE	Next decimal position
12e0	CODE	Save position counters
12e1	CODE	Save buffer pointer
12e2	CODE	HL -> X (DBL)
12e5	CODE	X = BCDE = (HL) (SNG) Shift the remaining LSBs of the DBL number into X as a SNG number
12e8	CODE	The remaining decimal positions are processed in SNG format (because now X < 1D+6)
12ea	CODE	; X in SNG format (and 1E+5 <= X < 1E+6 !)
*		; Generate unformatted string with 7 positions
*		; (2 positions using SNG-mantissas and the remaining 5 positions with
*		; INT-format)
12ea	CODE	Save position counters
12eb	CODE	Save buffer pointers
12ec	CODE	X = X + 0.5 (adjust mantissa)
12ef	CODE	A <> 0 (for 0AFBH)
12f0	CODE	Clear all positions behind the decimal point
12f3	CODE	X = BCDE (BCDE is the result of 0AFBH)
12f6	CODE	Restore buffer pointer
12f7	CODE	Restore position counters
12f8	CODE	C-flag = 0
12f9	CODE	DE -> mantissas
12fc	CODE	C-flag = 1 at first itteration after that C-flag = 0
12fd	CODE	Set '	' and '.'
1300	CODE	Save position counters
1301	CODE	Save repeat flag
1302	CODE	Save buffer pointer
1303	CODE	Save mantissa pointer
1304	CODE	BCDE = X
1307	CODE	Mantissa pointer back to HL
1308	CODE	B = '0' - 1
130a	CODE	next digit
130b	CODE	CDE = CDE - (HL):
130c	CODE	Subtract mantissa
1316	CODE	HL -> start of mantissa
1317	CODE	Underflow ?
1318	CODE	No: next digit
131a	CODE	CDE= CDE + (HL): reverse last subtract
131d	CODE	Mantissa pointer + 1
131e	CODE	X = BCDE: new value to X
1321	CODE	DE = mantissa pointer
1322	CODE	Restore buffer pointer
1323	CODE	Store digit
1324	CODE	Buffer pointer + 1
1325	CODE	Restore repeat flag
1326	CODE	Restore position counters Repeat ?
1327	CODE	Yes: back to 12FCH (there are only 2 mantissas in the SNG format)
1329	CODE	Mantissa pointer + 2
132a	CODE	(for INT processing)
132b	CODE	Process 4 mantissas (the first mantissa with 10000 is also in the SNG format)
132d	CODE	Process remaining 4 digits in INT-format
132f	CODE	; X in INT-format (and 0 <= X < 32768 !)
*		; Generate unfomratted string with 5 positions
132f	CODE	Save DE
1330	CODE	DE -> Mantissas
1333	CODE	5 Mantissas
1335	CODE	Set '.' and '	'
1338	CODE	Save position counters
1339	CODE	Save mantissa counter
133a	CODE	Save buffer pointer
133b	CODE	HL = mantissa pointer
133c	CODE	BC = mantissa
133f	CODE	Save mantissa
1340	CODE	HL -> next mantissa
1341	CODE	Save mantissa pointer	 HL = mantissa
1342	CODE	DE = mantissa
1343	CODE	HL = X
1346	CODE	B = ASCII '0' - 1
1348	CODE	Next digit
1349	CODE	HL = HL - DE
134e	CODE	Underflow ?
134f	CODE	No: next digit Yes:
1351	CODE	Reverse subtract
1352	CODE	and store new value in X
1355	CODE	Restore mantissa pointer
1356	CODE	Restore buffer pointer
1357	CODE	Insert digit
1358	CODE	Buffer pointer + 1
1359	CODE	Restore mantissa counter
135a	CODE	Restore position counters
135b	CODE	Mantissa counter - 1
135c	CODE	Next mantissa
135e	CODE	Set '	' and '.'
1361	CODE	Terminate string with 00H
1362	CODE	Restore DE
1364	BYTES	; Floating point constants
1364	BYTES	1D+10
1368	BYTES	1E+10
136c	BYTES	1D+15
1370	BYTES	1E+15
1374	BYTES	1D+16
1378	BYTES	1E+16
137c	BYTES	0.5 (DBL)
1380	BYTES	0.5 (SNG)
1384	BYTES	1D+16
1388	BYTES	1E+16
138c	BYTES	; Fixed point constants (mantissas for number conversion)
138c	BYTES	; 1000000000000000 (1D+15)
1393	BYTES	; 100000000000000 (1D+14)
139a	BYTES	; 10000000000000 (1D+13)
13a1	BYTES	; 1000000000000 (1D+12)
13a8	BYTES	; 100000000000 (1D+11)
13af	BYTES	; 10000000000 (1D+10)
13b6	BYTES	; 1000000000 (1D+9)
13bd	BYTES	; 100000000 (1D+8)
13c4	BYTES	; 10000000 (1D+7)
13cb	BYTES	; 1000000 (1D+6)
13d2	BYTES	; 100000 (1E+5)
13d5	BYTES	; 10000 (1E+4)
13d8	BYTES	; 10000 (INT)
13da	BYTES	; 1000 (INT)
13dc	BYTES	; 100 (INT)
13de	BYTES	; 10 (INT)
13e0	BYTES	; 1 (INT)
13e2	CODE	; SUB for SQR and ATN
*		; Negate the result of the routine (X = -X)
13e2	CODE	HL -> Routine for X = -X
13e5	CODE	Save HL as RET address on stack
13e6	CODE	Back to caller (SQR or ATN)
13e7	CODE	; X = SQR ( X ) = X ^ 0.5
*		; -----------------------
*		;
13e7	CODE	(SP) = X
13ea	CODE	HL -> constant 0.5
13ed	CODE	X = BCDE = (HL)
13f0	CODE	Compute (SP) ^ X
13f2	CODE	; X = (SP) ^ X
13f2	CODE	X = CSNG (X) (exponent)
13f5	CODE	BCDE = (SP) (Base)
13f7	CODE	TEST2
13fa	CODE	A = Exp (Base); exponent zero ?
13fb	CODE	Yes: compute Exp(0) = 1; exponent > 0
13fd	CODE	Yes: continue at 1404H
1400	CODE	Base = zero ? (with negative exponent)
1401	CODE	Yes: ?/0 Error
1404	CODE	Base = zero ? (with negative exponent)
1405	CODE	Yes: ?/0 Error
1408	CODE	Save Base
140a	CODE	A = MSB (Base)
140b	CODE	Test sign
140d	CODE	BCDE = X Positive Base ?
1410	CODE	Yes: continue at 1421H
1413	CODE	Save exponent
1415	CODE	X = INT (X) = INT (Exponent)
1418	CODE	Restore exponent
141a	CODE	Save LSB (X)
141b	CODE	CP X	BCDE CP INT (Exponent)	 Exponent; Exponent an integer ?
141e	CODE	Restore LSB (X)
141f	CODE	A = LSB (X) = INT (Exponent) (because exponent < 88)
1420	CODE	C-flag = A	 bit 0 (lowest bit of the exponent); exponent odd ?
1421	CODE	X = (SP) = Base
1429	CODE	Exponent odd ? Yes: negate result when exponent is odd with negative base exponent an integer ?
142c	CODE	Yes: make base positive when exponent is integer.
142f	CODE	Save exponent
1431	CODE	X = LOG (X) (logaritm of Base)
1434	CODE	Restore exponent
1436	CODE	X = BCDE * X   = Exponent * LOG (Base) Now compute the following: EXP ( Exponent * LOG (Base) )
1439	CODE	; X = EXP ( X )
*		; -------------
*		; Only computable for -88.7228 <= X <= 87.3365
1439	CODE	(SP) = X: Save argument
143c	CODE	BCDE = 1/4427 = 1 / LOG(2)
1442	CODE	X = BCDE * argument   = argument / LOG(2)
1445	CODE	A = Exp (X)
1448	CODE	Exp (X) >= 88H  ? means: X >= 2 ^ 8  ? means: argument/LOG(2) > 127 (or argument/LOG(2) < -128)  ? means: argument > 88.0297 (or argument < -88.7228) ?
144a	CODE	Yes: ?OV Error if argument > 88.0297	 Result = 0 if argument < 88.7228)
144d	CODE	A = X = INT (X) ( X = INT( argument/LOG(2) ) ) (   = 2-exponent of result )
1450	CODE	A > 7DH ? (A + 82H > FFH)
1452	CODE	means: INT(arg./LOG(2)) > 125? means X > 87.3365 ?
1454	CODE	Yes: ?OV Error No:
1457	CODE	Save 2-exponent + offset (80H) + 2
1458	CODE	HL -> Constant 1 (SNG)
145b	CODE	X = X + HL = X + 1
145e	CODE	X = X * LOG(2)
1461	CODE	Restore 2-exponent
1462	CODE	BCDE = (SP) = argument
1464	CODE	Save 2-exponent
1465	CODE	X = BCDE - X
1468	CODE	X = -X
146b	CODE	HL -> coefficients
146e	CODE	Series calculation 2
1471	CODE	DE = 0000H
1474	CODE	B = 2-exponent + 2
1475	CODE	C = 00H
1476	CODE	X = BCDE * X   = (2 ^ 2 + 2-exponent) * X
1479	BYTES	; Coefficients for EXP
*		; '!' means faculty of the number (3! = 1 * 2 * 3)
1479	BYTES	8 coefficients
147a	BYTES	-1.41361E-4 = -1/7076
147b	BYTES	approx. -1/5040 = -1/7!
147e	BYTES	1.32988E-3 = 1/752
147f	BYTES	approx. 1/720 = 1/6!
1482	BYTES	=8.30136E-3 = -1/120
1486	BYTES	0.0416574 = 1/24
148a	BYTES	-0.166665 = -1/6
148e	BYTES	0.5 = 1/2
1492	BYTES	-1 = -1/1!
1496	BYTES	1
149a	CODE	; Series calculation 1
*		; Calculate Taylor-series of the following form:
*		;
*		; y = k1*x + k2*x*x*x + k3*x*x*x*x*x... (k1	 k2	 k3 are coefficients)
*		;
*		; I: HL -> coefficients table
*		;          The first byte of the table indicates the number of coefficients
*		;          in the table. Then the coefficients follow	 in an inverted
*		;          order (k1 last)
*		;    X = factor in series (x in the example)
*		; O: X = result of series calculation (y in the example)
149a	CODE	(SP) = X
149d	CODE	DE = address of X = X * (SP)
14a0	CODE	Save as new RET address
14a1	CODE	Save table pointer
14a2	CODE	BCDE = X
14a5	CODE	X = BCDE * X = X * X
14a8	CODE	Restore table pointer and Series calulation 2 using X * X and multiply result again with X
14a9	CODE	; Series calculation 2
*		; Calculate Taylor-series of the following form:
*		;
*		; y = k1 + k2*x + k3*x*x*x... (k1	 k2	 k3 are coefficients)
*		;
*		; I: HL -> coefficients table
*		;          The first byte of the table indicates the number of coefficients
*		;          in the table. Then the coefficients follow	 in an inverted
*		;          order (k1 last)
*		;    X = factor in series (x in the example)
*		; O: X = result of series calculation (y in the example)
14a9	CODE	(SP) = X
14ac	CODE	A = number of coefficients
14ad	CODE	HL -> 1st number (last coefficient in the series)
14ae	CODE	X = BCDE = (HL) = 1st coeff.
14b1	CODE	--
14b2	ENTRY	Restore counter
14b3	CODE	BCDE = X
14b5	CODE	Any more coefficients ?
14b6	CODE	No: done	 return
14b7	CODE	Save BCDE
14b9	CODE	Save counter
14ba	CODE	Save pointer
14bb	CODE	Result = result + BCDE
14be	CODE	Restore pointer
14bf	CODE	BCDE = (HL) = coefficient
14c2	CODE	Save pointer
14c3	CODE	Result = result + BCDE
14c6	CODE	Restore pointer
14c7	CODE	Calculate next term
14c9	CODE	; X = RND ( X )
*		; -------------
*		; For X > 1: RND ( X ) = INT( RND(0) * INT(X) + 1 )
14c9	CODE	X = HL = CINT( argument )
14cc	CODE	Argument negative ?
14ce	CODE	Yes: ?FC Error
14d1	CODE	Argument = 0 ?
14d2	CODE	Yes: compute RND (0)
14d5	CODE	Save argument
14d6	CODE	Compute RND (0)
14d9	CODE	BCDE = X = RND (0)
14dc	CODE	(SP) = BCDE	 HL = argument
14df	CODE	X = CSNG (HL)
14e2	CODE	BCDE = (SP) = RND (0)
14e4	CODE	X = X * BCDE   = argument * RND (0)
14e7	CODE	HL -> Constant 1 (SNG)
14ea	CODE	X = X + (HL) = X + 1
14ed	CODE	X = CINT (X)
14f0	CODE	; X = RND ( 0 )
*		;   = last random number * 0.253514 + 0.022228 (ignore carry)
14f0	CODE	HL -> multiplicator
14f3	CODE	Save pointer
14f4	CODE	CDE = 000000H
14f7	CODE	(Result in CDE)
14f8	CODE	H = byte counter (3 bytes mantissa)
14fa	CODE	L = bit counter (8 bits per byte)
14fc	CODE	Shift CDE 1 bit to the left
14fd	CODE	(for multiplication)
1502	CODE	Save counter	 restore pointer
1503	CODE	Shift next bit of
1504	CODE	multiplicator into C-flag
1506	CODE	Save pointer	 restore counter Next bit = 1 ?
1507	CODE	No: continue at 1516H Yes:
150a	CODE	Save pointer
150b	CODE	HL = LSBs of last random number
150e	CODE	Add to result
1510	CODE	A = MSB of last random number
1513	CODE	Add to result
1515	CODE	Restore counter
1516	CODE	Bit counter - 1 All bits done ?
1517	CODE	No: process next bit Yes:
151a	CODE	Save counter	 restore pointer
151b	CODE	Pointer + 1 (process next byte of the multiplicator)
151c	CODE	Save pointer	 restore counter
151d	CODE	Byte counter - 1 All 3 bytes processed ?
151e	CODE	No: process next byte Yes:
1521	CODE	Remove pointer from stack
1522	CODE	and add 05B065H (=0.022228)
1525	CODE	to mantissa
1526	CODE	Store new random number
1529	CODE	Set VT = SNG
152c	CODE	Adjust MSB
152f	CODE	And store it
1532	CODE	CDE = mantissa of new random number
1533	CODE	Set exponent = 80H
1535	CODE	HL -> sign flag
1538	CODE	Sign-flag = 80H (generate a positive number at SFLOAT)
1539	CODE	HL -> Exp (X)
153a	CODE	Exp (X) = 80H (result < 1)
153b	CODE	Use MSB in BCDE
153c	CODE	LSB of CDEB = 00H
153e	CODE	Convert CDEB into SNG format and store in X (SFLOAT)
1541	CODE	; X = COS ( X )
*		; -------------
*		; X = COS (X) = SIN (X + PI / 2). PI = 3.14159
1541	CODE	HL -> PI/2
1544	CODE	X = argument + PI/2
1547	CODE	; X = SIN ( X )
*		; -------------
1547	CODE	(SP) = argument
154a	CODE	BCDE = 6.28319 = 2*PI
1550	CODE	Sace X into the range of -1 to 1; X = BCDE = 2*PI
1553	CODE	BCDE = argument
1555	CODE	X = X / BCDE = argument/(2*PI)
1558	CODE	(SP) = X = argument/(2*PI)
155b	CODE	X = INT (X)   = INT ( argument / (2*PI) )
155e	CODE	BCDE = argument / (2*PI)
1560	CODE	X = BCDE - X = arg./(2*PI)-INT(arg./(2*PI)) (remove multiples of 2*PI) The argument (X) is now between -1 (corresponds to -2*PI) and 1 (corresponds to +2*PI)
1563	CODE	HL -> 1/4
1566	CODE	X = (HL) - X = 1/4 - X
1569	CODE	TEST2: X >= 0 ? (arg. > PI/2)
156c	CODE	C-flag = 1
156d	CODE	Yes: continue at 1577H No:
1570	CODE	X = X + 1/2
1573	CODE	TEST2: X >= 0 ? (arg < PI/2)
1576	CODE	C-flag = 0 (for 1582H)
1577	CODE	Save flags
1578	CODE	Yes: X = -X
157b	CODE	HL -> 1/4
157e	CODE	X = X + (HL) = X + 1/4
1581	CODE	Restore flags
1582	CODE	if (1/4-X) > 0 then X = -X
1585	CODE	HL -> coefficients
1588	CODE	Calculate series 1
158b	BYTES	Constant 1.5708 = PI / 2
158f	BYTES	Constant 0.25 = 1/4
1593	BYTES	; Coefficient table for SIN and COS
*		; '!' means faculty of the number (3! = 1 * 2 * 3)
1593	BYTES	5 coefficients
1594	BYTES	39.7107
1595	BYTES	= ((2*PI) ^ 9) / 9!
1598	BYTES	-76.575
1599	BYTES	= - ((2*PI) ^ 7) / 7!
159c	BYTES	81.6022
159d	BYTES	= ((2*PI) ^ 5) / 5!
15a0	BYTES	-41.3417
15a1	BYTES	= - ((2*PI) ^ 3) / 3!
15a4	BYTES	6.28319 = 2*PI
15a5	BYTES	= ((2*PI) ^ 1) / 1!
15a8	CODE	; X = TAN ( X )
*		; -------------
*		; X = TAN (X) = SIN (X) / COS (X)
15a8	CODE	(SP) = argument
15ab	CODE	X = SIN (argument)
15ae	CODE	BCHL = argument
15b0	CODE	(SP) = X = SIN (argument)
15b3	CODE	BCDE = argument
15b4	CODE	X = BCDE = argument
15b7	CODE	X = COS (argument)
15ba	CODE	Result = (SP) / X = SIN (arg.) / COS (arg.)
15bd	CODE	; X = ATN ( X )
*		; -------------
15bd	CODE	TEST2: argument < 0 ?
15c0	CODE	Yes: negate restult afterwards
15c3	CODE	and continue processing with positive argument
15c6	CODE	A = Exp (argument)
15c9	CODE	Argument < 1 ?
15cb	CODE	Yes: continue at 15D9H
15cd	CODE	BCDE = 1.0
15d2	CODE	X = BCDE / X = 1 / argument
15d5	CODE	HL = address of X = (HL) - X
15d8	CODE	Save as new RET address
15d9	CODE	HL -> coefficient table
15dc	CODE	Calculate series 1
15df	CODE	HL -> PI/2
15e2	CODE	Result = PI/2 - X if argument was > 1 (Series calculation is only correct for -1 < X < 1)
15e3	BYTES	; Coefficients for ATN
15e3	BYTES	9 coefficients
15e4	BYTES	2.86623E-3     approx. 1/349
15e8	BYTES	-0.0161657     approx. -1/62
15ec	BYTES	0.0429096      approx. 1/23
15f0	BYTES	-0.0752896     approx. -1/11
15f4	BYTES	0.106563       approx. 1/9
15f8	BYTES	-0.142089      approx. -1/7
15fc	BYTES	0.199936       = 1/5
1600	BYTES	-0.333331      = 1/3
1604	BYTES	1.0            = 1/1
1608	WORDS	; Address table for Level II and Disk BASIC functions (tokens D7H to FAH)
1608	WORDS	SNG
160a	WORDS	INT
160c	WORDS	ABS
160e	WORDS	FRE
1610	WORDS	INP
1612	WORDS	POS
1614	WORDS	SQR
1616	WORDS	RND
1618	WORDS	LOG
161a	WORDS	EXP
161c	WORDS	COS
161e	WORDS	SIN
1620	WORDS	TAN
1622	WORDS	ATN
1624	WORDS	PEEK
1626	WORDS	CVI
1628	WORDS	CVS
162a	WORDS	CVD
162c	WORDS	EOF
162e	WORDS	LOC
1630	WORDS	LOF
1632	WORDS	MKI$
1634	WORDS	MKS$
1636	WORDS	MKD$
1638	WORDS	CINT
163a	WORDS	CSNG
163c	WORDS	CDBL
163e	WORDS	FIX
1640	WORDS	LEN
1642	WORDS	STR$
1644	WORDS	VAL
1646	WORDS	ASC
1648	WORDS	CHR$
164a	WORDS	LEFT$
164c	WORDS	RIGHT$
164e	WORDS	MID$
1650	ASCII	; Table for keywords of Level II and Disk BASIC
1650	ASCII	(080H) END
1653	ASCII	(081H) FOR
1656	ASCII	(082H) RESET
165b	ASCII	(083H) SET
165e	ASCII	(084H) CLS
1661	ASCII	(085H) CMD
1664	ASCII	(086H) RANDOM
166a	ASCII	(087H) NEXT
166e	ASCII	(088H) DATA
1672	ASCII	(089H) INPUT
1677	ASCII	(08AH) DIM
167a	ASCII	(08BH) READ
167e	ASCII	(08CH) LET
1681	ASCII	(08DH) GOTO
1685	ASCII	(08EH) RUN
1688	ASCII	(08FH) IF
168a	ASCII	(090H) RESTORE
1691	ASCII	(091H) GOSUB
1696	ASCII	(092H) RETURN
169c	ASCII	(093H) REM
169f	ASCII	(094H) STOP
16a3	ASCII	(095H) ELSE
16a7	ASCII	(096H) TRON
16ab	ASCII	(097H) TROFF
16b0	ASCII	(098H) DEFSTR
16b6	ASCII	(099H) DEFINT
16bc	ASCII	(09AH) DEFSNG
16c2	ASCII	(09BH) DEFDBL
16c8	ASCII	(09CH) LINE
16cc	ASCII	(09DH) EDIT
16d0	ASCII	(09EH) ERROR
16d5	ASCII	(09FH) RESUME
16db	ASCII	(0A0H) OUT
16de	ASCII	(0A1H) ON
16e0	ASCII	(0A2H) OPEN
16e4	ASCII	(0A3H) FIELD
16e9	ASCII	(0A4H) GET
16ec	ASCII	(0A5H) PUT
16ef	ASCII	(0A6H) CLOSE
16f4	ASCII	(0A7H) LOAD
16f8	ASCII	(0A8H) MERGE
16fd	ASCII	(0A9H) NAME
1701	ASCII	(0AAH) KILL
1705	ASCII	(0ABH) LSET
1709	ASCII	(0ACH) RSET
170d	ASCII	(0ADH) SAVE
1711	ASCII	(0AEH) SYSTEM
1717	ASCII	(0AFH) LPRINT
171d	ASCII	(0B0H) DEF
1720	ASCII	(0B1H) POKE
1724	ASCII	(0B2H) PRINT
1729	ASCII	(0B3H) CONT
172d	ASCII	(0B4H) LIST
1731	ASCII	(0B5H) LLIST
1736	ASCII	(0B6H) DELETE
173c	ASCII	(0B7H) AUTO
1740	ASCII	(0B8H) CLEAR
1745	ASCII	(0B9H) CLOAD
174a	ASCII	(0BAH) CSAVE
174f	ASCII	(0BBH) NEW
1752	ASCII	(0BCH) TAB(
1756	ASCII	(0BDH) TO
1758	ASCII	(0BEH) FN
175a	ASCII	(0BFH) USING
175f	ASCII	(0C0H) VARPTR
1765	ASCII	(0C1H) USR
1768	ASCII	(0C2H) ERN
176b	ASCII	(0C3H) ERR
176e	ASCII	(0C4H) STRING$
1775	ASCII	(0C5H) INSTR
177a	ASCII	(0C6H) CHECK
177f	ASCII	(0C7H) TIME$
1784	ASCII	(0C8H) MEM
1787	ASCII	(0C9H) INKEY$
178d	ASCII	(0CAH) THEN
1791	ASCII	(0CBH) NOT
1794	ASCII	(0CCH) STEP
1798	ASCII	(0CDH) +
1799	ASCII	(0CEH) -
179a	ASCII	(0CFH) *
179b	ASCII	(0D0H) /
179c	ASCII	(0D1H) [ (power)
179d	ASCII	(0D2H) AND
17a0	ASCII	(0D3H) OR
17a2	ASCII	(0D4H) >
17a3	ASCII	(0D5H) =
17a4	ASCII	(0D6H) <
17a5	ASCII	(0D7H) SNG
17a8	ASCII	(0D8H) INT
17ab	ASCII	(0D9H) ABS
17ae	ASCII	(0DAH) FRE
17b1	ASCII	(0DBH) INP
17b4	ASCII	(0DCH) POS
17b7	ASCII	(0DDH) SQR
17ba	ASCII	(0DEH) RND
17bd	ASCII	(0DFH) LOG
17c0	ASCII	(0E0H) EXP
17c3	ASCII	(0E1H) COS
17c6	ASCII	(0E2H) SIN
17c9	ASCII	(0E3H) TAN
17cc	ASCII	(0E4H) ATN
17cf	ASCII	(0E5H) PEEK
17d3	ASCII	(0E6H) CVI
17d6	ASCII	(0E7H) CVS
17d9	ASCII	(0E8H) CVD
17dc	ASCII	(0E9H) EOF
17df	ASCII	(0EAH) LOC
17e2	ASCII	(0EBH) LOF
17e5	ASCII	(0ECH) MKI$
17e9	ASCII	(0EDH) MKS$
17ed	ASCII	(0EEH) MKD$
17f1	ASCII	(0EFH) CINT
17f5	ASCII	(0F0H) CSNG
17f9	ASCII	(0F1H) CDBL
17fd	ASCII	(0F2H) FIX
1800	ASCII	(0F3H) LEN
1803	ASCII	(0F4H) STR$
1807	ASCII	(0F5H) VAL
180a	ASCII	(0F6H) ASC
180d	ASCII	(0F7H) CHR$
1811	ASCII	(0F8H) LEFT$
1816	ASCII	(0F9H) RIGHT$
181c	ASCII	(0FAH) MID$
1820	ASCII	(0FBH) ' (remark)
1821	ASCII	End of table
1822	WORDS	; Address table for Level II and Disk BASIC statements (tokens 80H to BBH)
1822	WORDS	END
1824	WORDS	FOR
1826	WORDS	RESET
1828	WORDS	SET
182a	WORDS	CLS
182c	WORDS	CMD
182e	WORDS	RANDOM
1830	WORDS	NEXT
1832	WORDS	DATA
1834	WORDS	INPUT
1836	WORDS	DIM
1838	WORDS	READ
183a	WORDS	LET
183c	WORDS	GOTO
183e	WORDS	RUN
1840	WORDS	IF
1842	WORDS	RESTORE
1844	WORDS	GOSUB
1846	WORDS	RETURN
1848	WORDS	REM
184a	WORDS	STOP
184c	WORDS	ELSE
184e	WORDS	TRON
1850	WORDS	TROFF
1852	WORDS	DEFSTR
1854	WORDS	DEFINT
1856	WORDS	DEFSNG
1858	WORDS	DEFDBL
185a	WORDS	LINE
185c	WORDS	EDIT
185e	WORDS	ERROR
1860	WORDS	RESUME
1862	WORDS	OUT
1864	WORDS	ON
1866	WORDS	OPEN
1868	WORDS	FIELD
186a	WORDS	GET
186c	WORDS	PUT
186e	WORDS	CLOSE
1870	WORDS	LOAD
1872	WORDS	MERGE
1874	WORDS	NAME
1876	WORDS	KILL
1878	WORDS	LSET
187a	WORDS	RSET
187c	WORDS	SAVE
187e	WORDS	SYSTEM
1880	WORDS	LPRINT
1882	WORDS	DEF
1884	WORDS	POKE
1886	WORDS	PRINT
1888	WORDS	CONT
188a	WORDS	LIST
188c	WORDS	LLIST
188e	WORDS	DELETE
1890	WORDS	AUTO
1892	WORDS	CLEAR
1894	WORDS	CLOAD
1896	WORDS	CSAVE
1898	WORDS	NEW
189a	BYTES	; Prioritytable for operators
*		; highest value corresponds with highest proirity
189a	BYTES	+
189b	BYTES	-
189c	BYTES	*
189d	BYTES	/
189e	BYTES	exponent
189f	BYTES	AND
18a0	BYTES	OR
18a1	WORDS	; Address table for type conversion
18a1	WORDS	0ADBH: CDBL
18a3	WORDS	0000H: unused entry in table
18a5	WORDS	0A7FH: CINT
18a7	WORDS	0AF4H: ?TM error when no        string in X
18a9	WORDS	0AB1H: CSNG
18ab	WORDS	; Address table for basic arithmatic and comparisons
*		; 1. double precision
18ab	WORDS	 + (X = X + Y)
18ad	WORDS	 - (X = X - Y)
18af	WORDS	 * (X = X * Y)
18b1	WORDS	 / (X = X / Y)
18b3	WORDS	 Compare (CP X 	 Y)
18b5	WORDS	; 2. single precision
18b5	WORDS	 + (X = BCDE + X)
18b7	WORDS	 - (X = BCDE - X)
18b9	WORDS	 * (X = BCDE * X)
18bb	WORDS	 / (X = BCDE / X)
18bd	WORDS	 Compare (CP X 	 BCDE)
18bf	WORDS	; 3. integer
18bf	WORDS	 + (X = DE + HL)
18c1	WORDS	 - (X = DE - HL)
18c3	WORDS	 * (X = DE * HL)
18c5	WORDS	 / (X = DE / HL)
18c7	WORDS	 Compare (CP HL 	 DE)
18c9	ASCII	; Table with character combinations for error messages
18c9	ASCII	NF: next without for
18cb	ASCII	SN: syntax
18cd	ASCII	RG: return without gosub
18cf	ASCII	OD: out of data
18d1	ASCII	FC: function call
18d3	ASCII	OV: overflow
18d5	ASCII	OM: out of memory
18d7	ASCII	UL: undefined line
18d9	ASCII	BS: bad ??
18db	ASCII	DD: doubly defined
18dd	ASCII	/0: division by zero
18df	ASCII	ID: illegal direct
18e1	ASCII	TM: type mismatch
18e3	ASCII	OS: out of string space
18e5	ASCII	LS: ???
18e7	ASCII	ST: ???
18e9	ASCII	CN: can't continue (?)
18eb	ASCII	NR: no resume
18ed	ASCII	RW: read/write (?)
18ef	ASCII	UE: undefined error
18f1	ASCII	MO: missing operand
18f3	ASCII	FD: ???
18f5	ASCII	SN: syntax (?)
18f7	ASCII	; Following 39 bytes are copied into system RAM from 4080H onwards
191d	ASCII	; Text ' Error'
1923	BYTES	End of string
1924	ASCII	; Text ' in '
1928	BYTES	End of string
1929	ASCII	; Text 'READY'
192e	BYTES	Carriage Return
192f	BYTES	End of string
1930	ASCII	; Text 'Break'
1935	BYTES	End of string
1936	CODE	; SUB for FOR	 NEXT and RETURN
*		; Retrieves data from stack
*		;
*		; I: DE = VARPTR of new loop variable when a new FOR-TO loop is started
*		;    DE = VARPTR of the variable indicated with NEXT
*		;    DE = 0000H when NEXT with no variable
*		; O: DE = unchanged
*		;    HL = 'stackpointer' on FOR-TO-stack + 1 (when Z-flag = 0)
*		;    HL = 'stackpointer' on FOR-TO-stack + 3 (when Z-flag = 1)
*		;    Z-flag = 0 when no FOR-TO-stack found or when the variable is not used
*		;               in a loop
*		;    Z-flag = 1 when call from NEXT or if the variable had already been used
*		;               in a loop
1939	CODE	HL = SP + 4 HL is now like stack pointer after 2 POPs
193a	CODE	Get marker form stack
193b	CODE	"stack pointer" + 1
193c	CODE	FOR marker found ?
193e	CODE	No: done	 return Yes:
193f	CODE	BC = VARPTR of loop variable
1943	CODE	save "stack pointer"
1944	CODE	HL -> loop variable
1946	CODE	DE = 0000H (call from NEXT) ?
1948	CODE	DE = VARPTR of loop variable found in stack HL = VARPTR of new loop variable Call from NEXT ?
1949	CODE	Yes: done
194b	CODE	Swap DE and HL
194c	CODE	Compare both VARPTRs
194d	CODE	BC = offset to next FOR-TO-stack
1950	CODE	Restore "stack pointer"
1951	CODE	Done if searched VARPTR found
1952	CODE	Increment "stack pointer" to next FOR-TO-stack. (Every FOR-TO-loop requires 17 bytes of stack space. HL was already incremented by 3 (193BH	 1940H	 1942H). Add 0EH (14) to get 17)
1953	CODE	Continue search in stack
1955	CODE	; Move program text for insertion of a new line
*		; Copies memory from (BC) to (HL) until BC = DE
*		;
*		; I: BC -> old program end (before move)
*		;    DE = LP of new line
*		;    HL -> new program end (after move)
*		; O: DE = LP on new line
*		;    HL = DE
1955	CODE	Enough free memory available ?
1958	CODE	Swap BC and HL
1959	CODE	(because of RST 18H)
195b	CODE	New line reached ?
195c	CODE	Copy byte from old location
195d	CODE	to new location
195e	CODE	Yes: done	 return
195f	CODE	Pointer - 1
1961	CODE	Copy next byte
1963	CODE	; Test if sufficient memory space is available
*		; ?OM Error if less than 2 * C bytes are available
*		;
*		; I: C = number of required bytes
1963	CODE	Save PTP
1964	CODE	HL -> start of free memory
1967	CODE	BC = number of required bytes
1969	CODE	HL - HL + 2 * BC
196b	CODE	--
196b	CODE	; Is there sufficient free space from (HL) onwards ?
*		;
*		; I: HL -> free memory space
196b	CODE	Save HL HL now points to the new start of free memory
196d	CODE	HL = FFC6H - HL
1974	CODE	HL > FFC6H; Yes: ?OM Error
1976	CODE	MSB back to H
1977	CODE	HL = SP + (FFC6 - HL)
1978	CODE	Restore HL
1979	CODE	If room until stack then return else ?OM Error
197a	CODE	E = error code for ?OM Error
197c	CODE	Continue at error routine
197e	CODE	; End program without 'END'
197e	CODE	HL = current LN
1981	CODE	Was a program finished ?
1982	CODE	(is LN <> 65535)
1984	CODE	No: go via 198EH to END
1986	CODE	ON ERROR GOTO flag set ?
198a	CODE	E = error code for ?NR error
198c	CODE	Flag set: ?NR Error
198e	CODE	Continue at END
1991	CODE	; ?SN Error in DATA line
1991	CODE	HL = DATA LN
1994	CODE	Store as current LN
1997	CODE	; ?SN Error
1997	CODE	E = error code for ?SN Error
1999	CODE	--
199a	ENTRY	; ?/0 Error
199a	ENTRY	E = error code for ?/0 Error
199c	CODE	--
199d	ENTRY	; ?NF Error
199d	ENTRY	E = error code for ?NF Error
199f	CODE	--
19a0	ENTRY	; ?RW Error
19a0	ENTRY	E = error code for ?RW Error
19a2	CODE	; Error routine
*		; Displays the error code and line number and aborts program
*		;
*		; I: E = (error code - 1) * 2
*		; O: - (returns to active command mode or to error handling routine if
*		;    ON ERROR GOTO was active
19a2	CODE	HL = current LN
19a5	CODE	Save as ERL
19a8	CODE	and '.' (current LN)
19ab	CODE	19B4H = new return address
19ae	CODE	HL = last SP value
19b1	CODE	Reinitialize stack
19b4	CODE	Correct stack
19b5	CODE	A = error code
19b6	CODE	C = error code
19b7	CODE	Save error code as ERR
19ba	CODE	HL = PTP before error
19bd	CODE	Save PTP for RESUME
19c0	CODE	DE = PTP
19c1	CODE	HL = LN
19c4	CODE	LN = FFFH (65535 ?)
19c7	CODE	Yes: error on active command mode level	 continue at 19D0H
19c9	CODE	Save LN for CONT
19cc	CODE	HL = PTP
19cd	CODE	Save PTP for CONT
19d0	CODE	HL = LN of ON ERROR GOTO
19d3	CODE	ON ERROR GOTO active ?
19d4	CODE	(LN <> 0 ?)
19d5	CODE	DE = LN
19d6	CODE	HL = ON ERROR GOT flag
19d9	CODE	No: continue at 19E3H
19db	CODE	ON ERROR GOTO Flag set ?
19dc	CODE	No: continue at 19E3H
19de	CODE	Flag - 1 (as counter for RESUME)
19df	CODE	HL = PTP of ON ERROR GOTO line
19e0	CODE	Continue program at (HL)
19e3	CODE	; Issue error
19e3	CODE	Clear ON ERROR GOTO flag
19e5	CODE	E = Error code
19e6	CODE	Start at new line
19e9	CODE	HL -> Error codes table
19ec	CODE	DOS
19ef	CODE	DE = offset in error table
19f0	CODE	A = '?'
19f2	CODE	Print it
19f5	CODE	HL -> Error code text
19f6	CODE	Print both characters
19f7	CODE	Print 1st error character
19fa	CODE	A = 2nd character
19fb	CODE	Print 2nd error character
19fe	CODE	HL -> ' Error'
1a01	CODE	Save HL
1a02	CODE	HL = ERL
1a05	CODE	Save ERL and restore text pointer
1a06	CODE	; Entry for STOP (see 1DDEH)
1a06	CODE	Give text and sound
1a09	CODE	Restore ERL
1a0a	CODE	Error originates from MEM SIZE? (ERL = 65534)
1a0d	CODE	Compare HL and DE
1a0e	CODE	Yes: back to start 1
1a11	CODE	Error originates from program?
1a12	CODE	(ERL <> 65535)
1a14	CODE	Yes: print ' in ' and LN
1a17	CODE	Back into BASIC
1a18	ENTRY	--
1a19	CODE	; Entry into active command mode
1a19	CODE	End output to printer	 next output to screen
1a1c	CODE	DOS
1a1f	CODE	--
1a22	CODE	Finish screen output
1a25	CODE	HL -> READY text
1a28	CODE	Set LGR	 NBGRD and print text
1a2b	CODE	A = last error code
1a2e	CODE	Was it ?SN Error ?
1a30	CODE	Yes: call EDIT
1a33	CODE	Set current LN to 65535
1a39	CODE	AUTO active ?
1a3d	CODE	No: goto normal command mode
1a3f	CODE	; Process AUTO
1a3f	CODE	HL = AUTO-LN
1a42	CODE	Save LN
1a43	CODE	Print LN
1a46	CODE	DE = LN
1a47	CODE	Save LN
1a48	CODE	Search LN and test if already
1a4b	CODE	A = '*' LN already present ?
1a4d	CODE	Yes: continue at 1A51H
1a4f	CODE	A = ' '
1a51	CODE	Print it
1a54	CODE	Input line
1a57	CODE	Restore LN <BREAK> pressed ?
1a58	CODE	No: accept line
1a5a	CODE	A = 00H
1a5b	CODE	Switch off AUTO
1a5e	CODE	Back to active command mode
1a60	CODE	; Accept AUTO line
1a60	CODE	HL = diffence to next LN
1a63	CODE	Calculate next AUTO-LN
1a64	CODE	Abort AUTO if next LN becomes larger than 65535
1a66	CODE	Save current LN
1a67	CODE	DE = 65530 (maximum LN + 1)
1a6a	CODE	Compare new LN with 65530
1a6b	CODE	Restore current LN new LN too large (> 65529) ?
1a6c	CODE	Yes: abort AUTO
1a6e	CODE	Store next LN
1a71	CODE	Set A <> 0
1a73	CODE	Accept line by EDIT routine
1a76	CODE	; Normal command or line input in active command mode
1a76	CODE	A = '>'
1a78	CODE	Print it
1a7b	CODE	Input line <BREAK> pressed ?
1a7e	CODE	Yes: back to active command mode
1a81	CODE	A = 1st character of entered line
1a82	CODE	A = 00H ?
1a83	CODE	(no 'OR A' so that C-flag is not infuenced)
1a84	CODE	Yes: back to active command mode
1a87	CODE	Save flags
1a88	CODE	Decode number
1a8b	CODE	Set HL back to the
1a8c	CODE	All following spaces are
1a8d	CODE	last digit of the number
1a91	CODE	HL -> first character in line
1a92	CODE	A = character
1a93	CODE	Space ?
1a95	CODE	Yes: HL + 1	 the first space is not used because LIST automaticcaly inserts a space after the line number
1a98	CODE	Save LN
1a99	CODE	Tokenize line
1a9c	CODE	Restore LN
1a9d	CODE	Restore flags
1a9e	CODE	Save HL as current PTP
1aa1	CODE	DOS LN indicated ?
1aa4	CODE	No: execute line directly
1aa7	CODE	; Use line to program
1aa7	CODE	Save LN
1aa8	CODE	Save length of line
1aa9	CODE	A = 00H
1aaa	CODE	Clear STOP-flag
1aad	CODE	A = 1st character of tokenized line
1aae	CODE	A = 00H ? (No program text entered behind the line number ? )
1aaf	CODE	Save flags
1ab0	CODE	Save pointer
1ab1	CODE	Save LN as '.'-LN
1ab4	CODE	Restore pointer
1ab5	CODE	LN already used in program ?
1ab8	CODE	Save LP
1ab9	CODE	Yes: delete line
1abc	CODE	Restore LP
1abd	CODE	Restore flags
1abe	CODE	Save LP Z-flag = 1 (see 1AAEH) ?
1abf	CODE	Yes: the line had only to be deleted. Now only the LPs in the program have to be renewed
1ac1	CODE	Restore LP
1ac2	CODE	HL -> program end
1ac5	CODE	HL = length of line
1ac6	CODE	BC -> program end
1ac7	CODE	HL -> new program end
1ac8	CODE	Save pointer
1ac9	CODE	Make room for new line
1acc	CODE	Restore pointer to new program
1acd	CODE	end and store it in system RAM
1ad0	CODE	HL = new LP
1ad1	CODE	Set LP to next line <> 0
1ad2	CODE	Restore LN
1ad3	CODE	Save LP
1ad4	CODE	LP + 2
1ad6	CODE	Insert new LP in program
1ada	CODE	DE -> free space for line text
1adb	CODE	HL -> line buffer
1ade	CODE	HL -> program DE -> new line + 2
1adf	CODE	DE - 2
1ae1	CODE	copy byte from buffer
1ae2	CODE	into program
1ae3	CODE	Pointer + 1
1ae5	CODE	End of line reached ?
1ae6	CODE	No: continue copy Yes:
1ae8	CODE	DE = LP of new line
1ae9	CODE	Renew all LPs in program from DE onwards
1aec	CODE	DOS
1aef	CODE	CLEAR
1af2	CODE	DOS
1af5	CODE	Back to active command mode
1af8	CODE	; Renew all LPs in program
1af8	CODE	HL = start of program
1afb	CODE	DE = start of program
1afc	CODE	; Renew all LPs in program from DE onwards
1afc	CODE	HL = LP
1afe	CODE	LP to next line = 0 ?
1b00	CODE	(end of program reached ?)
1b01	CODE	Yes: done	 return No:
1b02	CODE	Increment HL to line text
1b05	CODE	A = 00H
1b06	CODE	Search for 00H (end of line)
1b07	CODE	Pointer + 1
1b08	CODE	Continue search
1b0a	CODE	DE = LP on next line
1b0b	CODE	Set line
1b0e	CODE	Process next line
1b10	CODE	; Decode line numbers at LIST and DELETE
*		; (LIST. 	 LIST FF 	 LIST FF-LL 	 LIST FF- 	 LIST -LL etc. )
*		;
*		; I: HL = PTP on character following command (line number in ASCII format)
*		; O: BC -> first line (FF in example)
*		;    DE = starting LN (FF in example) (default = 0)
*		;    HL -> next line (after FF)
*		;    (SP) = end-LN (LL in example) (default = 65529)
1b10	CODE	Default first LN = 0
1b13	CODE	Save first LN LNs indicated ?
1b14	CODE	No: continue at 1B1FH Yes:
1b16	CODE	Restore first LN
1b17	CODE	Decode first LN
1b1a	CODE	Save first LN ( = 0 if '-' indicated) Only 1 LN indicated ?
1b1b	CODE	Yes: continue at 1B1FH
1b1d	CODE	'-' indicated ?
1b1e	BYTES	'-' token
1b1f	CODE	Default last LN = 65529
1b22	CODE	Decode last LN
1b25	CODE	?SN Error ?
1b28	CODE	HL = last LN
1b29	CODE	Restore first LN
1b2a	CODE	Save last LN
1b2b	CODE	RET address back on stack
1b2c	CODE	; Search line number DE in program
*		;
*		; I: DE = line number of line to be searched
*		; O: BC -> searched line (if line found) or program end (line not found)
*		;    DE = line number
*		;    HL -> next line
*		;    Z-flag = 1	 C-flag = 1: search succesfull
*		;    Z-flag = 1	 C-flag = 0: BC -> program end
*		;    Z-flag = 0	 C-flag = 0: BC -> line with largerst LN < searched LN
1b2c	CODE	HL -> first program lline
1b2f	CODE	BC = LP
1b31	CODE	LP to next line = 0 ?
1b34	CODE	Reverse INC HL
1b35	CODE	Yes: done	 return
1b36	CODE	Increment HL to line number
1b38	CODE	HL = line number
1b3c	CODE	Compare with line number to be searched for
1b3d	CODE	LP back to HL
1b3f	CODE	HL -> next line
1b43	CODE	C-flag = 1 for succesfull search
1b44	CODE	Done if line found
1b45	CODE	Reverse C-flag again
1b46	CODE	RET if LN found > LN to be searched for
1b47	CODE	Check next line
1b49	CODE	; NEW statement
*		; -------------
1b49	CODE	?SN Error ?
1b4a	CODE	CLS
1b4d	CODE	HL -> start of BASIC program
1b50	CODE	TROFF
1b53	CODE	Switch off AUTO
1b56	CODE	Set LP to second line
1b57	CODE	to zero
1b5a	CODE	Program end = program start+2
1b5d	CODE	; Entry for RUN without line number (RET on program loop)
1b5d	CODE	HL -> BASIC program start
1b60	CODE	HL - 1
1b61	CODE	; CLEAR without argument
1b61	CODE	Store PTP to first/next command
1b64	CODE	DEFSNG A-Z (B = 26)
1b66	CODE	HL -> DEF table
1b69	CODE	Set type code on SNG
1b6b	CODE	Pointer + 1
1b6c	CODE	Loop
1b6e	CODE	A = 00H
1b6f	CODE	Clear ON ERROR GOTO flag
1b72	CODE	HL = 0000H
1b74	CODE	ON ERROR GOTO LN = 0
1b77	CODE	CONT PTP = 0
1b7a	CODE	HL = TOPMEM
1b7d	CODE	Address of last string in string space = TOPMEM (delete all strings)
1b80	CODE	RESTORE
1b83	CODE	HL -> BASIC program end
1b86	CODE	End of variable tables
1b89	CODE	is end of BASIC program: Delete all variables
1b8c	CODE	DOS
1b8f	CODE	BC = return address
1b90	CODE	HL -> start of string memory
1b93	CODE	HL - 2
1b95	CODE	Set new program stack
1b9a	CODE	SP = start of string memory
1b9b	CODE	HL -> start of string table
1b9e	CODE	Set pointer to first free position in string table
1ba1	CODE	End output to printer
1ba4	CODE	Next output to screen
1ba7	CODE	A = 0
1ba8	CODE	HL = 0000H
1baa	CODE	Release array variables
1bad	CODE	Put HL on stack
1bae	CODE	Set new return address
1baf	CODE	HL = entry address SYSTEM
1bb3	CODE	; SUB for INPUT
*		; Print '? ' and input line
1bb3	CODE	A = '?'
1bb5	CODE	Print it
1bb8	CODE	A = ' '
1bba	CODE	Print it
1bbd	CODE	Input line
1bc0	CODE	; SUB for active command mode
*		; Tokenize program text in line buffer
*		; Text pointer = pointer on entered text
*		; Buffer pointer = pointer on tokenized text
*		;
*		; I: HL = text pointer
*		; O: BC = number of required memory bytes (line length)
*		;    DE -> end of tokenized text
*		;    HL -> start of tokenized text - 1
1bc0	CODE	A = 00H
1bc1	CODE	Allow tokenizing
1bc4	CODE	Counter = 0
1bc5	CODE	DE = text pointer
1bc6	CODE	HL -> start of line buffer
1bcb	CODE	DE = buffer pointer HL = text pointer
1bcc	CODE	A = text character
1bcd	CODE	Space ?
1bcf	CODE	Yes: store character No:
1bd2	CODE	B = character
1bd3	CODE	Start of a string ?
1bd5	CODE	Yes: continue at 1C77H No:
1bd8	CODE	End of line reached ?
1bd9	CODE	Yes: continue at 1C7DH No:
1bdc	CODE	Tokenizing allowed ?
1be0	CODE	A = text character
1be1	CODE	No: accept character Yes:
1be4	CODE	Is it '?'
1be6	CODE	A = PRINT token
1be8	CODE	Yes: store PRINT token No:
1beb	CODE	A = text character
1bec	CODE	Is it a digit ?
1bee	CODE	No: tokenize character Yes:
1bf0	CODE	Character before '<' ?
1bf2	CODE	Yes: accept character (the characters '<' 	 '=' and '>' are tokenized)
1bf5	CODE	; Tokenize character / text
1bf5	CODE	Save buffer pointer
1bf6	CODE	DE -> Keyword table
1bf9	CODE	Save counter
1bfa	CODE	Set new RET address
1bfd	CODE	to 1C3DH
1bfe	CODE	B = token counter
1c00	CODE	A = text character
1c01	CODE	Character < 'a' ?
1c03	CODE	Yes: continue at 1C0CH
1c05	CODE	Character > 'z' ?
1c07	CODE	Yes: continue at 1C0CH
1c09	CODE	Convert to upper case
1c0b	CODE	Store character
1c0c	CODE	C = text character
1c0d	CODE	HL = table pointer
1c0e	CODE	Table pointer + 1
1c0f	CODE	Next keyword reached ?
1c10	CODE	No: increment HL to next keyword
1c13	CODE	Yes: token counter + 1
1c14	CODE	A = table character
1c15	CODE	Intercept Colour BASIC keywords
1c18	CODE	Compare text character with table character; the same ?
1c19	CODE	No: increment table pointer to next keyword and check again
1c1b	CODE	DE = table pointer HL = buffer pointer on first character
1c1c	CODE	Save buffer pointer
1c1d	CODE	Get next character
1c1e	CODE	from table
1c1f	CODE	Next keyword reached ?
1c20	CODE	Yes: Put token in B No:
1c23	CODE	C = table character
1c24	CODE	A = token counter
1c25	CODE	At GOTO token ?
1c27	CODE	No: continue at 1C2BH
1c29	CODE	Increment text pointer to next character (GOTO can also be written as GO TO !)
1c2a	CODE	HL - 1 because of HL + 1 in the RST 10H
1c2b	CODE	Text pointer + 1
1c2c	CODE	A = next character
1c2d	CODE	Lower case ?
1c2f	CODE	No: ok	 continue at 1C33H
1c31	CODE	Convert to upper case
1c33	CODE	Text character the same as table character
1c34	CODE	Yes: compare next character No:
1c36	CODE	Set text pointer back to first character
1c37	CODE	And compare with next keyword
1c39	CODE	; Compare ended succesfully
1c39	CODE	C = token
1c3a	CODE	Remove text pointer from stack
1c3b	CODE	DE = text pointer
1c3d	CODE	; Store token or character
1c3d	CODE	HL = text pointer
1c3e	CODE	A = token
1c3f	CODE	Restore character counter
1c40	CODE	Restore buffer pointer
1c41	CODE	DE = text pointer HL = buffer pointer
1c42	CODE	'ELSE' token ?
1c44	CODE	Put ':' in buffer
1c46	CODE	No: do not use ':' Yes:
1c48	CODE	Counter + 1
1c49	CODE	Buffer pointer + 1:  ':' is used
1c4a	CODE	Apostroph ? (REM)
1c4c	CODE	No: implement token Yes:
1c4e	CODE	Put ':' in buffer
1c50	CODE	Buffer poiner + 1
1c51	CODE	B = 'REM' token
1c53	CODE	Put token in buffer
1c54	CODE	Buffer pointer + 1
1c55	CODE	DE = buffer pointer
1c56	CODE	Counter + 1 (for ':')
1c57	CODE	Counter + 1 (for 'REM')
1c58	CODE	Use all characters until end of line (REM line)
1c5a	CODE	; Use token or character in A
1c5a	CODE	DE = buffer pointer
1c5b	CODE	Text pointer + 1
1c5c	CODE	Store token in buffer
1c5d	CODE	Buffer pointer + 1
1c5e	CODE	Counter + 1
1c5f	CODE	':' ? (SUBtract !!)
1c61	CODE	Yes: release tokenizing and tokenize next character
1c63	CODE	'DATA' token ? (4EH + 3AH = 88H)
1c65	CODE	No: leave flag	 continue at 1C6AH
1c67	CODE	Yes: block tokenizing (A=4EH)
1c6a	CODE	'REM' token ? (SUBtract !!)
1c6c	CODE	No: tokenize next character Yes:
1c6f	CODE	Set B = 0 as compare char.
1c70	CODE	; Use all characters until end of line or until character = B
1c70	CODE	A = text character
1c71	CODE	End of line reached ?
1c72	CODE	Yes: done	 continue ar 1C7DH No:
1c74	CODE	Same as compare character ?
1c75	CODE	Yes: implement character. No:
1c77	CODE	Text pointer + 1
1c78	CODE	Store character in buffer
1c79	CODE	Counter + 1
1c7a	CODE	Buffer pointer + 1
1c7b	CODE	Next character
1c7d	CODE	; Line completely tokenized
1c7d	CODE	Add 5 bytes to total length
1c80	CODE	(2 bytes line pointer	 2 bytes
1c81	CODE	line number	 1 byte line end)
1c82	CODE	BC = number of bytes required
1c83	CODE	in memory
1c84	CODE	HL -> line buffer
1c87	CODE	HL -> tokenized line - 1
1c8a	CODE	Terminate tokenized line
1c8b	CODE	with 3 times 00H
1c90	CODE	; SUB RST 18H: 16 bit compare
*		; Compares DE with HL and set flags according to result
*		; (like CP HL	DE)
1c90	CODE	A = MSB of HL
1c91	CODE	Subtract MSB of DE H = D ?
1c92	CODE	No: return
1c93	CODE	Same with LSBs
1c96	CODE	; SUB RST 08H: syntax check
*		; Compare the byte in (HL) with the byte following the RST 08H in memory.
*		; If they are equal then a RST 10H is executed and the routine returns to
*		; the normal RET-address + 1 (because the compare byte is located at the
*		; RET-address). If both bytes are not equal a ?SN Error is generated
1c96	CODE	A = text character
1c97	CODE	HL -> compare character
1c98	CODE	The same ?
1c99	CODE	HL + 1 for RET-address
1c9a	CODE	RET-address on stack
1c9b	CODE	Yes: equal so RST 10H No:
1c9e	CODE	?SN Error
1ca1	CODE	; FOR statement
*		; -------------
1ca1	CODE	A <> 0
1ca3	CODE	Block array variables
1ca6	CODE	Execute LET (set loop variable and initialize it)
1ca9	CODE	Save PTP	 HL = RET-address DE = VARPTR on loop variable
1caa	CODE	Already a FOR-TO-loop active using this variable ?
1cad	CODE	Restore PTP
1cae	CODE	No: continue at 1CB5H Yes:
1cb0	CODE	HL = HL + 14 (BC = 000EH)
1cb1	CODE	Terminate previous loop using this variable (delete from stack)
1cb2	CODE	Save new SP
1cb5	CODE	HL = PTP
1cb6	CODE	Are there 16 bytes (2*C) free?
1cb8	CODE	(17 bytes are needed)
1cbb	CODE	Save PTP
1cbc	CODE	Increment PTP to next command (PTP is then pointing on the first command within the loop)
1cbf	CODE	Save new PTP	 HL = old PTP
1cc0	CODE	Save PTP
1cc1	CODE	HL= current LN
1cc4	CODE	Save LN	 restore PTP
1cc5	CODE	Next byte must be the
1cc6	BYTES	'TO' token
1cc7	CODE	TSTTYP STR type ?
1cc8	CODE	Yes: ?TM Error DBL type ?
1ccb	CODE	Yes: ?TM Error
1cce	CODE	Save type code - 3
1ccf	CODE	X = final value of loop
1cd2	CODE	Restore type code
1cd3	CODE	Save PTP Loop in SNG format ?
1cd4	CODE	Yes: continue at 1CECH
1cd7	CODE	; INT loop
1cd7	CODE	Convert final value to INT
1cda	CODE	Save final value	 restore PTP
1cdb	CODE	DE = default step value (1)
1cde	CODE	A = next character
1cdf	CODE	'STEP' token ?
1ce1	CODE	Yes: DE = step value
1ce4	CODE	Save step value
1ce5	CODE	Save PTP
1ce6	CODE	HL = step value
1ce7	CODE	A = SGN (step value)
1cea	CODE	Continue at 1D0EH
1cec	CODE	; SNG loop
1cec	CODE	Convert final value to SGN
1cef	CODE	BCDE = X = final value
1cf2	CODE	Restore PTP
1cf3	CODE	Save final value
1cf5	CODE	BCDE = default step value (1)
1cfa	CODE	A = next character
1cfb	CODE	'STEP' token ?
1cfd	CODE	A = SNG (default step value)
1cff	CODE	No: continue at 1D0FH Yes:
1d01	CODE	X = step value
1d04	CODE	Save PTP
1d05	CODE	X = CSGN (X)
1d08	CODE	BCDE = X = step value
1d0b	CODE	A = SNG(step value)
1d0e	CODE	; FOR stack wrap up
1d0e	CODE	Restore PTP
1d0f	CODE	Save step value
1d10	CODE	(for SNG loop)
1d11	CODE	C = SGN (step value)
1d12	CODE	TSTTYP (step value)
1d13	CODE	B = type code - 3
1d14	CODE	Save type code and SNG (step value)
1d15	CODE	Save PTP
1d16	CODE	HL = VARPTR of loop variable
1d19	CODE	Save VARPTR	 restore PTP
1d1a	CODE	B = 'FOR' token
1d1c	CODE	Mark stack
1d1d	CODE	Remove LSB
1d1e	CODE	; Program loop
*		; Return address after execution of a command in the program
*		; HL (PTP) must point to end of command (':') to end of line (00H)
1d1e	CODE	Get key
1d21	CODE	Key pressed ?
1d22	CODE	Yes: <SHIFT>+<@> or <BREAK> ?
1d25	CODE	Save PTP
1d28	CODE	Save SP
1d2c	CODE	A = next character
1d2d	CODE	= ':' ?
1d2f	CODE	Yes: ok	 continue at 1DA5H No:
1d31	CODE	= 00H ? (end of line)
1d32	CODE	No: ?SN Error
1d35	CODE	; Start new line
1d35	CODE	PTP + 1
1d36	CODE	Test pointer to next line
1d38	CODE	= 0000H (end of program) ?
1d39	CODE	Yes: end program. No:
1d3c	CODE	DE = line number
1d40	CODE	HL = LN	 DE = PTP
1d41	CODE	Store current LN
1d44	CODE	TRACE active ?
1d47	CODE	(411BH) <> 0 ?
1d48	CODE	No: continue at 1D59H
1d4a	CODE	; Execute TRACE
1d4a	CODE	Save PTP
1d4b	CODE	A = '<'
1d4d	CODE	Print it
1d50	CODE	Print HL as decimal number (line number)
1d53	CODE	A = '>'
1d55	CODE	Print it
1d58	CODE	Restore PTP
1d59	CODE	HL = PTP	 DE = LN
1d5a	CODE	Next character to A
1d5b	CODE	Set new RET address
1d5e	CODE	to 1D1EH
1d5f	CODE	RET when end of line reached
1d60	CODE	Token found ?
1d62	CODE	No: interpret character as a variable	 continue at LET
1d65	CODE	Statement or function ?
1d67	CODE	Colour-keyword found ?
1d6a	CODE	A = token-number * 2
1d6b	CODE	BC = offset for address table
1d6e	CODE	DE = PTP
1d6f	CODE	HL -> address table
1d72	CODE	Add offset
1d73	CODE	Load command address in BC
1d76	CODE	Put address on stack for RET
1d77	CODE	HL = PTP
1d78	CODE	; SUB RST 10H: increment PTP to next character <> 20H (space)
*		;
*		; I: HL = PTP
*		; O: HL = PTP (+1 at least)
*		;    A = character at (HL)
*		;    C-flag = 1 if digit found
*		;    Z-flag = 1 if end of command (':') or end of line (00H) found
1d78	CODE	PTP + 1
1d79	CODE	A = next character
1d7a	CODE	Character > digit ?
1d7c	CODE	Yes: done (Z-flag = 1 in case of ':')
1d7d	CODE	Space ?
1d7f	CODE	Yes: get next character
1d82	CODE	Character > 0AH ?
1d84	CODE	Yes: continue at 1D8BH
1d86	CODE	Character > 08H ?
1d88	CODE	Yes: get next character
1d8b	CODE	Digit found?
1d8d	CODE	Yes: C-flag = 1
1d8e	CODE	End of line reached ?
1d8f	CODE	(A = 00H) Yes: Z-flag = 1
1d91	CODE	; RESTORE statement
*		; -----------------
1d91	CODE	DE = PTP
1d92	CODE	HL = start of program
1d95	CODE	Hl = HL - 1
1d96	CODE	DATA pointer = start of program - 1
1d99	CODE	HL = PTP
1d9b	CODE	; <SHIFT>+<@> or <BREAK> pressed ?
1d9b	CODE	Get key
1d9e	CODE	Key pressed ?
1d9f	CODE	No: return
1da0	CODE	<SHIFT>+<@> pressed ?
1da2	CODE	Yes: freeze until new key pressed.
1da5	CODE	Save ASCII code of last key
1da8	CODE	<BREAK> pressed ? (01H)
1da9	CODE	; STOP statement
*		; --------------
1da9	CODE	No: done	 return or ?SN Error
1daa	CODE	; <BREAK> pressed
1daa	CODE	A = 01H (key code of BREAK)
1dab	CODE	Continue at 1DB4H
1dae	CODE	; END statement
*		; -------------
1dae	CODE	?SN Error ?
1daf	CODE	Save A (A = 00H !)
1db0	CODE	DOS
1db3	CODE	Restore A
1db4	CODE	Store PTP in system RAM
1db7	CODE	Reset string table pointer
1dbd	CODE	--
1dbe	ENTRY	; Entry for STOP in case <BREAK> was pressed during INPUT
1dbe	ENTRY	A <> 0	 Z-flag = 0
1dc0	CODE	Remove RET-address
1dc1	CODE	HL = current LN
1dc4	CODE	Save current LN
1dc5	CODE	Save flags
1dc6	CODE	LN = 65535 ?
1dc7	CODE	(Active command mode)
1dc9	CODE	Yes: no CONT possible No:
1dcb	CODE	Store LN and PTP for CONT
1dd4	CODE	End output to printer
1dd7	CODE	Start new line
1dda	CODE	Restore flags
1ddb	CODE	HL -> 'Break' STOP ?
1dde	CODE	Yes: continue at 1A06H No:
1de1	CODE	END	 back to active command mode
1de4	CODE	; CONT statement
*		; --------------
1de4	CODE	HL = previous PTP
1de7	CODE	HL = 0000H ?
1de9	CODE	E = error code for ?CN Error
1deb	CODE	Yes: ?CN Error
1dee	CODE	DE = PTP
1def	CODE	HL = previous LN
1df2	CODE	Save as current LN and program CRTC on last values
1df5	CODE	HL = PTP
1df6	CODE	Execute next command
1df7	CODE	; TRON statement
*		; --------------
1df7	CODE	A <> 0  (trace on)
1df8	ENTRY	; TROFF statement
*		; ---------------
1df8	ENTRY	A = 0  (trace off)
1df9	CODE	Update TRON/TROFF flag
1dfd	CODE	--
1e00	CODE	; DEFSTR statement
*		; ----------------
1e00	CODE	E = VT for STR
1e02	CODE	--
1e03	ENTRY	; DEFINT statement
*		; ----------------
1e03	ENTRY	E = VT for INT
1e05	CODE	--
1e06	ENTRY	; DEFSNG statement
*		; ----------------
1e06	ENTRY	E = VT for SNG
1e08	CODE	--
1e09	ENTRY	; DEFDBL statement
*		; ----------------
1e09	ENTRY	E = VT for DBL
1e0b	CODE	Check if valid var letter
1e0e	CODE	First set new return address
1e11	CODE	to 1997H (= ?SN Error)
1e12	CODE	Invalid character: return
1e13	CODE	A = offset for table
1e15	CODE	C = A
1e16	CODE	B = A
1e17	CODE	Get next character
1e18	CODE	Token for '-' ?
1e1a	CODE	No: set table Yes:
1e1c	CODE	Get 2nd letter
1e1d	CODE	Letter found ?
1e20	CODE	No: ?SN Error Yes
1e21	CODE	A = offset for table
1e23	CODE	B = A
1e24	CODE	Increment PTP to next char.
1e25	CODE	A = offset of 2nd letter
1e26	CODE	- offset of 1st letter
1e27	CODE	?SN Error if the letters were not in alphabetical order
1e28	CODE	A = counter
1e29	CODE	Save PTP	 remove RET-address
1e2a	CODE	HL -> table
1e2d	CODE	BC = offset to 1st letter
1e2f	CODE	HL -> 1st letter entry
1e30	CODE	Set VT in table
1e31	CODE	Pointer + 1
1e32	CODE	Counter - 1
1e33	CODE	Set next table entry
1e35	CODE	Restore PTP
1e36	CODE	A = next character
1e37	CODE	Comma indicated ?
1e39	CODE	No: done	 return Yes:
1e3a	CODE	Get next character
1e3b	CODE	And repeat DEF
1e3d	CODE	; Test if ASCII character at (HL) is an upper case letter (A-Z)
*		;
*		; I: HL -> ASCII character
*		; O: A = ASCII value of character
*		;    C-flag is 1 if not A-Z
1e3d	CODE	A = character
1e3e	CODE	Can it be an letter ?
1e40	CODE	No: return
1e41	CODE	Is it a upper case letter ?
1e43	CODE	No: C-flag = 1
1e45	CODE	; Convert argument at (HL) to INT number. If negative number then ?FC Error
1e45	CODE	Increment PTP
1e46	CODE	Get argument
1e49	CODE	If positive then return
1e4a	CODE	; ?FC Error
1e4a	CODE	E = error code for ?FC Error
1e4c	CODE	Continue at error routine
1e4f	CODE	; Decode line number (number of '.')
1e4f	CODE	A = character
1e50	CODE	'.' found ?
1e53	CODE	DE = '.'-LN
1e57	CODE	Yes: execute RST 10H	 done
1e5a	CODE	; Decode number at (HL) into DE
1e5a	CODE	PTP - 1 (because of RST 10H)
1e5b	CODE	Result = 0
1e5e	CODE	Get next character Digit found ?
1e5f	CODE	No: done	 return
1e60	CODE	Save PTP
1e61	CODE	Save digit
1e62	CODE	HL = 6552
1e65	CODE	Result already larger than 6552 ?
1e66	CODE	Yes: ?SN Error (with the current digit DE would become larger than 65529)
1e69	CODE	HL = previous result
1e6b	CODE	HL = HL * 10
1e6f	CODE	Restore digit
1e70	CODE	Convert to numberical value
1e72	CODE	DE = value
1e75	CODE	Add value
1e76	CODE	DE = new result
1e77	CODE	Restore PTP
1e78	CODE	Get next digit Argument indicated ?
1e7a	CODE	; CLEAR statement
*		; ---------------
1e7a	CODE	No: continue ar 1B61H
1e7d	CODE	; CLEAR with argument
1e7d	CODE	Get INT-argument	 if argument < 0 then ?FC Error
1e80	CODE	PTP - 1
1e81	CODE	End of command reached ?
1e82	CODE	No: ?SN Error
1e83	CODE	Save PTP
1e84	CODE	HL = TOPMEM
1e87	CODE	DE -> TOPMEM - (size of new
1e88	CODE	string space)
1e8d	CODE	String space too large ?; Yes: ?OM Error
1e90	CODE	HL -> program end
1e93	CODE	BC = 40
1e96	CODE	HL -> program end + 40
1e97	CODE	Compare HL and DE At least 40 bytes remain free?
1e98	CODE	No: ?OM error
1e9b	CODE	HL -> new start of string space
1e9c	CODE	Save it in system RAM
1e9f	CODE	Restore PTP
1ea0	CODE	Execute CLEAR	 done. Line number indicated ?
1ea3	CODE	; RUN statement
*		; -------------
1ea3	CODE	No: continue at 1B5DH
1ea6	CODE	DOS
1ea9	CODE	CLEAR
1eac	CODE	BC = RET-address on program loop
1eaf	CODE	Continue at GOTO
1eb1	CODE	; GOSUB statement
*		; ---------------
1eb1	CODE	Still 2 * C bytes free ?
1eb3	CODE	If not: ?OM Error
1eb6	CODE	BC = RET-address
1eb7	CODE	Save PTP (for GOSUB stack)
1eb8	CODE	Save PTP
1eb9	CODE	HL = current LN
1ebc	CODE	Save current LN	 restore PTP
1ebd	CODE	A = 'GOSUB' token
1ebf	CODE	Save as marker on stack
1ec0	CODE	Remove LSB from stack
1ec1	CODE	Put RET-address back
1ec2	CODE	; GOTO statement
*		; --------------
1ec2	CODE	Decode LN	 DE = LN
1ec5	CODE	Increment PTP to end of line
1ec8	CODE	Save new PTP
1ec9	CODE	HL = current LN
1ecc	CODE	Compare current LN with required LN
1ecd	CODE	Restore new PTP
1ece	CODE	HL = pointer on next line Required LN > current LN ?
1ecf	CODE	Yes: search line DE from line HL onwards
1ed2	CODE	No: search line DE from start of program onwards
1ed5	CODE	HL = pointer on required line
1ed7	CODE	HL - 1 Line found ?
1ed8	CODE	Yes: done	 return
1ed9	CODE	; ?UL Error
1ed9	CODE	E = error code for ?UL Error
1edb	CODE	Continue at error routine
1ede	CODE	; RETURN statement
*		; ----------------
1ede	CODE	?SN Error ?
1edf	CODE	Flag <> 0
1ee1	CODE	Search GOSUB stack
1ee4	CODE	SP = HL (delete GOSUB stack)
1ee5	CODE	Save new SP in system RAM
1ee8	CODE	GOSUB stack found ?
1eea	CODE	E = error code for ?RG Error
1eec	CODE	No: ?RG Error
1eef	CODE	HL = LN of gosub line
1ef0	CODE	Save as current LN
1ef3	CODE	LN = 65535 ?
1ef4	CODE	(GOSUB came from active
1ef5	CODE	command mode ?)
1ef6	CODE	No: increment PTP to next command following GOSUB and continue program execution from there
1ef8	CODE	STOP flag = 0 ?
1efc	CODE	No: back to active command mode
1eff	CODE	HL = RET_address for program loop
1f02	CODE	HL = PTP	 RET-address = 1D1EH
1f03	CODE	--
1f04	ENTRY	Restore PTP
1f05	CODE	; DATA statement
*		; --------------
*		; Increment PTP (HL) to next command
1f05	CODE	C = 3AH (':')
1f07	ENTRY	; REM statement
*		; -------------
*		; Increment PTP (HL) to next line
1f07	ENTRY	C = 00H
1f08	ENTRY	--
1f09	CODE	B = 00H
1f0b	CODE	A = search character (= 00H when string found	 PTP is then incremented to end of line
1f0c	CODE	C = 00H (search character when string found)
1f0d	CODE	B = search character
1f0e	CODE	A = next character
1f0f	CODE	End of line ?
1f10	CODE	Yes: done
1f11	CODE	Character found ?
1f12	CODE	Yes: done
1f13	CODE	PTP + 1
1f14	CODE	String found ?
1f16	CODE	Yes: increment PTP to end of line
1f18	CODE	'IF' found ?
1f1a	CODE	No: continue search
1f1c	CODE	If 3AH was searched C-flag = 1
1f1d	CODE	A = 00H + D + C-flag
1f1e	CODE	D = counter for nested IF THEN ELSE statements
1f1f	CODE	Continue search
1f21	CODE	; LET statement
*		; -------------
1f21	CODE	DE = VARPTR variable
1f24	CODE	Next character must be
1f25	BYTES	the token for '='
1f27	CODE	Store VARPTR
1f2b	CODE	Save VARPTR
1f2c	CODE	TSTTYP
1f2d	CODE	Save type code - 3
1f2e	CODE	Expression to X
1f31	CODE	Restore type code - 3
1f32	CODE	Save PTP	 restore VARPTR
1f33	CODE	Adjust type code
1f35	CODE	Convert X into desired type
1f38	CODE	DE -> LSB (X) for SNG	 DBL and INT	 TSTTYP
1f3b	CODE	Save VARPTR STR type ?
1f3c	CODE	No: continue at 1FF6H
1f3e	CODE	; Variable assignment to string variable
1f3e	CODE	HL -> vector of new string
1f41	CODE	Save pointer
1f43	CODE	DE -> new string
1f46	CODE	HL -> start of BASIC program
1f49	CODE	String address < program start? (string is in line buffer	 e.g. with INPUT)
1f4a	CODE	Yes: continue at 1F5AH
1f4c	CODE	HL -> start of string space
1f4f	CODE	String address < string space? (String constant in program text)
1f50	CODE	Restore string pointer
1f51	CODE	Yes: continue at 1F62H
1f53	CODE	HL -> start of variable space
1f56	CODE	Vector address of new string variable space ? (new string is a variable)
1f57	CODE	No: continue at 1F62H
1f59	CODE	--
1f5a	ENTRY	Restore string pointer
1f5b	CODE	BC -> last string in string table
1f5e	CODE	DE -> vector of last string in string table HL -> vector of new string
1f5f	CODE	Put new string in string space and string vector in string table
1f62	CODE	DE -> vector of new string
1f65	CODE	HL -> vector of variables Save vector of new string
1f66	CODE	Copy VT bytes from (DE) to (HL)
1f69	CODE	Restore vector to new string
1f6a	CODE	Restore PTP
1f6c	CODE	; ON statement
*		; ------------
1f6c	CODE	Next token = 'ERROR'
1f6e	CODE	No: continue at 1F95H
1f70	CODE	; ON ERROR GOTO
1f70	CODE	Get next non-space character
1f71	CODE	Next byte must be token
1f72	BYTES	for 'GOTO'
1f73	CODE	Decode line number
1f76	CODE	Line number = 0 ?
1f78	CODE	Yes: continue at 1F83H
1f7a	CODE	Save PTP and search line DE
1f7d	CODE	DE = address of line
1f7f	CODE	Restore PTP Line found ?
1f80	CODE	No: ?UL Error
1f84	CODE	Save line number
1f88	CODE	Line number <> 0 ?; Yes: done	 return
1f89	CODE	A = error flag
1f8c	CODE	ON ERROR GOTO active ?
1f8d	CODE	No: done	 return
1f8e	CODE	A = last error code
1f91	CODE	into E
1f92	CODE	Process error
1f95	CODE	; ON GOTO / GOSUB
1f95	CODE	DE = argument (0 - 255)
1f98	CODE	A = next character
1f99	CODE	B = A
1f9a	CODE	'GOSUB' token ?
1f9c	CODE	Yes: continue at 1F1AH No:
1f9e	CODE	It must be the
1f9f	BYTES	'GOTO' token
1fa0	CODE	PTP - 1 (because of RST 08H)
1fa1	CODE	C = argument (counter)
1fa2	CODE	Counter - 1
1fa3	CODE	A = token Counter = 0 ?
1fa4	CODE	Yes: HL points to required LN so execute command
1fa7	CODE	By decoding the number at (HL) increment PTP to the next character following the number
1faa	CODE	Separator must be a comma
1fac	CODE	Otherwise execute next command
1fad	CODE	Required LN reached ?
1faf	CODE	; RESUME statement
*		; ----------------
1faf	CODE	DE -> ON ERROR GOT flag
1fb2	CODE	A = ON ERROR GOTO flag
1fb3	CODE	ON ERROR GOTO active ?
1fb4	CODE	No: ?RW Error
1fb7	CODE	A + 1
1fb8	CODE	Set last error code <> 0
1fbb	CODE	Set error flag <> 0
1fbc	CODE	A = next program character
1fbd	CODE	'NEXT' token ?
1fbf	CODE	Yes: continue at 1FCDH
1fc1	CODE	Decode line number
1fc4	CODE	?SN Error ?
1fc5	CODE	Line number = 0 ?
1fc7	CODE	No: execute GOTO Yes:
1fca	CODE	A = 1 (Z-flag = 0)
1fcb	CODE	Execute RESUME NEXT
1fcd	CODE	; RESUME NEXT
1fcd	CODE	Increment PTP
1fce	CODE	?SN Error ?
1fcf	CODE	HL = PTP on next command
1fd2	CODE	DE = HL
1fd3	CODE	HL = LN of error line
1fd6	CODE	Store as current LN
1fd9	CODE	HL = PTP
1fda	CODE	Done if RESUME 0
1fdb	CODE	A = next character from program text
1fdc	CODE	End of line ?
1fdd	CODE	No: continue at 1FE3H Yes:
1fdf	CODE	Increment PTP to
1fe0	CODE	next line
1fe4	CODE	Error line = 65535 ?
1fe7	CODE	No: increment PTP to next command and continue program execution
1fea	CODE	A = STOP flag
1fed	CODE	A = 1 ?
1fee	CODE	Yes: STOP No:
1ff1	CODE	Continue program execution at next command
1ff4	CODE	; ERROR statement
*		; ---------------
1ff4	CODE	DE = argument (0 - 255)
1ff7	CODE	?SN Error ?
1ff8	CODE	ERROR 0 ?
1ff9	CODE	YEs: ?FC Error
1ffc	CODE	A = A - 1
1ffd	CODE	A = A * 2
1ffe	CODE	E = (argument - 1 ) * 2
1fff	CODE	Errorcode > 44H (out of range)
2001	CODE	No: process error code Yes:
2003	CODE	E = error code for ?UE Error
2005	CODE	Continue at error routine
2008	CODE	; AUTO statement
*		; --------------
2008	CODE	DE = default first LN
200b	CODE	Save first LN Any numbers indicated ?
200c	CODE	No: continue at 2025H
200e	CODE	DE = indicated first LN
2011	CODE	HL = LN	 DE = PTP
2012	CODE	Save first LN	 HL = default first LN. Distance indicated ?
2013	CODE	No: continue at 2026H
2015	CODE	PTP back to HL
2016	CODE	Next character must be
2017	ASCII	a comma
2019	CODE	DE = previous distance
201d	CODE	use previous distance ? (AUTO XX	 ); Yes: continue at 2025H
201f	CODE	DE = distance
2022	CODE	?SN Error
2025	CODE	DE = PTP	 HL = distance
2026	CODE	Distance =0 ?
2028	CODE	Yes: ?FC Error
202b	CODE	Store distance in system RAM
202e	CODE	Set AUTO flag <> 0
2031	CODE	Restore first LN
2032	CODE	and store it in system RAM
2035	CODE	Delete RET-address
2036	CODE	Input line
2039	CODE	; IF statement
*		; ------------
2039	CODE	X = expression (if condition is false then X = 0 else X = -1)
203c	CODE	Get next character
203d	CODE	Is it a comma ?
203f	CODE	Yes: increment PTP (like with 'THEN')
2042	CODE	'THEN' token ?
2044	CODE	Yes: increment PTP
2047	CODE	PTP - 1
2048	CODE	Save PTP
2049	CODE	TEST1
204c	CODE	Restore PTP X = 0 ? (condition: false)
204d	CODE	Yes: continue at 2056H
204f	CODE	; IF-condition is true
204f	CODE	Increment PTP Number indicated ?
2050	CODE	Yes: continue at GOTO No:
2053	CODE	execute command token
2056	CODE	; IF-condition is false
2056	CODE	D = counter for nested IF-THEN-ELSE conditions
2058	CODE	Increment PTP to next command
205b	CODE	End of line reached ?
205c	CODE	Yes: done	 return
205d	CODE	A = next character
205e	CODE	'ELSE' token found ?
2060	CODE	No: continue search
2062	CODE	Nesting level counter - 1
2063	CODE	Search outermost 'ELSE'
2065	CODE	Execute following command
2067	CODE	; LPRINT statement
*		; ----------------
2067	CODE	Set output flag to
2069	CODE	printer output
206c	CODE	Continue at PRINT
206f	CODE	; PRINT statement
*		; ---------------
206f	CODE	DOS
2072	CODE	PRINT@ ?
2074	CODE	No: continue at 208FH
2076	CODE	Get argument
2079	CODE	Save PTP
207a	CODE	Test argument and restore
207d	CODE	PTP (returns to 207EH)
207e	CODE	Save PTP
207f	CODE	HL -> start of screen mem
2082	CODE	Add @-argument
2083	CODE	Store new cursor position
2086	CODE	Calculate new POS
2089	CODE	and save it in system RAM
208c	CODE	Restore PTP
208d	CODE	After @ must follow
208f	CODE	PRINT# ?
2091	CODE	No	 continue at 209BH
2093	CODE	Write leader and sync
2096	CODE	Set output flag to
2098	CODE	cassette output
209b	CODE	PTP - 1
209c	CODE	A = next non space character
209d	CODE	End PRINT if no argument
20a0	CODE	and set next output to screen
20a3	CODE	'USING' token ?
20a5	CODE	Yes: continue at 2CBDH
20a8	CODE	'TAB(' token ?
20aa	CODE	Yes: continue at 2137H
20ad	CODE	Save PTP
20ae	CODE	'	' found ?
20b0	CODE	Yes: continue at 2108H
20b3	CODE	';' found ?
20b5	CODE	Yes: continue at 2164H
20b8	CODE	Correct stack
20b9	CODE	Put argument in X
20bc	CODE	Save PTP
20bd	CODE	TSTTYP STR type?
20be	CODE	Yes: continue at 202FH
20c0	CODE	Convert number into string
20c3	CODE	Take string
20c6	CODE	DOS
20c9	CODE	HL -> string vector
20cc	CODE	A = output flag
20cf	CODE	Test output flag Cassette output ?
20d0	CODE	Yes: continue at 20E9H Screen output?
20d3	CODE	Yes: continue at 20DDH
20d5	CODE	; Printer output
20d5	CODE	A = printer-POS
20d8	CODE	A = printer-POS + string len
20d9	CODE	> 132 ?
20db	CODE	Yes: start new line
20dd	CODE	; Screen output
20dd	CODE	A = maximum number of characters/line
20e0	CODE	B = A
20e1	CODE	A = screen-POS
20e4	CODE	A = screen-POS + string length
20e5	CODE	> length of 1 line ?
20e6	CODE	Yes: start new line
20e9	CODE	; Cassette output
20e9	CODE	Output string
20ec	CODE	A = ' '
20ee	CODE	Print it for separation
20f1	CODE	set Z-flag= 0: skip next CALL
20f2	CODE	Print string when argument was in STR format
20f5	CODE	Restore PTP
20f6	CODE	Process next argument
20f9	CODE	; Start a new line
20f9	CODE	A = screen-POS
20fc	CODE	POS = 0 ? (new line already started)
20fd	CODE	Yes: done
20fe	CODE	A = Carriage Return
2100	CODE	Print it
2103	CODE	DOS
2106	CODE	A = 0
2108	CODE	; '	' with PRINT
2108	CODE	DOS
210b	CODE	A = output flag
210e	CODE	Test output flag Cassette output ?
210f	CODE	No: continue at 2119H
2112	CODE	; Cassette output
2112	CODE	A = '	'
2114	CODE	Print it
2117	CODE	Process next argument
2119	CODE	; PRINT '	' on screen or printer
2119	CODE	continue at 2123H if screen output
211b	CODE	; Printer output
211b	CODE	A = printer-POS
211e	CODE	A > 112 ?
2120	CODE	Yes: start new line
2123	CODE	; Screen output
2123	CODE	A = highest TAB position
2126	CODE	B = A
2127	CODE	A = screen-POS
212a	CODE	POS above highest TAB TAB position
212b	CODE	Yes: start a new line
212e	CODE	and process next argument
2130	CODE	A = A MOD 10
2135	CODE	Print A times a space
2137	CODE	; PRINT TAB(
2137	CODE	DE = TAB argument
213a	CODE	E = new POS value
213d	CODE	Next character must be
213e	ASCII	a ')'
213f	CODE	PTP - 1
2140	CODE	Save PTP
2141	CODE	DOS
2144	CODE	A = output flag
2147	CODE	Test output flag Cassette output ?
2148	CODE	Yes: ?FC Error Screen output ?
214b	CODE	Yes: continue at 2153H
214e	CODE	; Printer output
214e	CODE	A = printer-POS
2151	CODE	Continue at 2156H
2153	CODE	; Screen output
2153	CODE	A = screen-POS
2156	CODE	A = -A
2157	CODE	A = E - A (new POS - old POS)
2158	CODE	Done when required POS already reached
215a	CODE	A + 1
215b	CODE	into B as counter
215c	CODE	A = ' ' Repeat
215e	CODE	Print space
2162	CODE	Until B = 0
2164	CODE	; ';' with PRINT	 do not generate at new line
2164	CODE	Restore PTP
2165	CODE	Skip spaces/LF etc and get next character
2166	CODE	Continue at 20A0H
2169	CODE	; Next output back to screen
2169	CODE	--
216c	CODE	--
2170	CODE	Set output flag to
2171	CODE	screen output
2174	CODE	DOS
2178	CODE	; Text '?REDO'
217d	BYTES	Carriage return
217e	BYTES	End of string
217f	CODE	; Data with INPUT or READ not separated by '	'
217f	CODE	A = READ/INPUT flag
2182	CODE	READ?
2183	CODE	Yes: ?SN Error
2186	CODE	Test E on correct TAB value (?)
2189	CODE	A = 0 (?)
218a	CODE	E = error code for ?FD Error
218c	CODE	Yes: ?FD Error
218f	CODE	No: correct stack
2190	CODE	HL -> '?REDO'
2193	CODE	Print text
2196	CODE	HL = last PTP
2199	CODE	Repeat last command
219a	CODE	; INPUT statement
*		; ---------------
219a	CODE	?ID Error?
219d	CODE	A = next character
219e	CODE	DOS
21a1	CODE	Character = '#' ?
21a3	CODE	Flag = 0 when INPUT#
21a6	CODE	A = character
21a7	CODE	No: continue at 21C9H
21a9	CODE	; INPUT#
21a9	CODE	Evaluate number and search for sync and leader
21ac	CODE	Save PTP
21ad	CODE	B = 250 (record length)
21af	CODE	HL -> line buffer
21b2	CODE	Read one byte
21b5	CODE	Store it in buffer
21b6	CODE	Pointer + 1
21b7	CODE	End of record ?
21b9	CODE	Yes: continue at 21BDH
21bb	CODE	Read next byte
21bd	CODE	Pointer - 1
21be	CODE	Replace last byte with 00H
21c0	CODE	--
21c1	CODE	(I guess motor off call used
21c2	CODE	to be here in the TRS80)
21c3	CODE	HL -> line buffer
21c6	CODE	Pointer - 1
21c7	CODE	Process data
21c9	CODE	; Normal INPUT
21c9	CODE	Set new RET address
21cc	CODE	to 21DBH
21cd	CODE	Text to be printed first?
21cf	CODE	No: continue at 21DBH
21d0	CODE	Get text
21d3	CODE	Text must be followed by
21d4	ASCII	a ';'
21d5	CODE	Save PTP
21d6	CODE	Print text
21d9	CODE	Restore PTP
21da	CODE	Continue at 21BDH
21db	CODE	Save PTP
21dc	CODE	Print '?' and goto line input
21df	CODE	BC = PTP <BREAK> pressed ?
21e0	CODE	Yes: continue at STOP
21e3	CODE	Pointer + 1
21e4	CODE	Get first character
21e5	CODE	<RETURN> pressed ?
21e6	CODE	Pointer - 1
21e7	CODE	Save PTP
21e8	CODE	Yes: set PTP to next instruction and leave variables unchanged
21eb	CODE	Put a comma in the buffer as a separator
21ed	CODE	Continue at 21F4H
21ef	CODE	; READ statement
*		; --------------
21ef	CODE	Save PTP
21f0	CODE	HL -> next data value
21f3	CODE	set flag to READ
21f4	ENTRY	set flag to INPUT
21f5	CODE	Store READ/INPUT flag
21f8	CODE	Restore PTP	 save DATA pointer
21f9	CODE	Continue at 21FDH
21fb	CODE	; Use next data
*		; DATA pointer = pointer on the data to use
*		; PTP = pointer on variables
21fb	CODE	Next character must be
21fc	ASCII	a comma (separator)
21fd	CODE	Get address of variable indicated after READ/INPUT
2200	CODE	Save PTP	 restore READ pointer
2201	CODE	Save variable address
2202	CODE	A = data character
2203	CODE	Separator ?
2205	CODE	Yes: continue at 222DH
2207	CODE	; No separator ('	') found
2207	CODE	A = READ/INPUT flag
220a	CODE	READ ?
220b	CODE	Yes: increment DATA pointer to next DATA line
220e	CODE	INPUT# ?
2212	CODE	E = error code for ?OD Error
2214	CODE	Yes: issue error
2217	CODE	A = '?'
2219	CODE	Print it
221c	CODE	Request missing data ('??')
221f	CODE	Restore variable address
2220	CODE	Restore PTP <BREAK> pressed ?
2221	CODE	Yes: continue at STOP
2224	CODE	Pointer + 1
2225	CODE	A = first character
2226	CODE	<RETURN> pressed ?
2227	CODE	Pointer - 1
2228	CODE	Save PTP
2229	CODE	Yes: set PTP to next instruction and leave variables unchanged
222c	CODE	No: Save variable address
222d	CODE	DOS
2230	CODE	TSTTYP
2231	CODE	Save VT - 3 STR type ?
2232	CODE	No: continue at 224DH
2234	CODE	; Put data in string variable
2234	CODE	First non-space/LF character to A
2235	CODE	D = A
2236	CODE	B = A
2237	CODE	String delimited by '"'
2239	CODE	Yes: B = D = string end
223b	CODE	String end can be ':' (3AH)
223d	CODE	or '	' (2CH)
223f	CODE	Pointer - 1
2240	CODE	Get string
2243	CODE	Restore VT - 3
2244	CODE	DE = DATA pointer
2245	CODE	Set RET address to 225AH
2248	CODE	HL -> variable
2249	CODE	Save DATA pointer
224a	CODE	Copy new value into variable and continue at 225AH
224d	CODE	; Put data in numerical variable
224d	CODE	Set pointer on first non-space character
224e	CODE	Restore VT - 3
224f	CODE	And save it again
2250	CODE	Set new RET address to 2243H
2253	CODE	(copy value into variable) INT or SNG value ?
2254	CODE	Yes: get INT or SNG value DBL value
2257	CODE	Yes: get DBL VALUE
225a	CODE	; Continuation after getting data
225a	CODE	PTP - 1
225b	CODE	End of line reached ?
225c	CODE	Yes: continue at 2263H
225e	CODE	Separator found ?
2260	CODE	No: process error at 217FH
2263	CODE	Save DATA pointer	 HL = PTP
2264	CODE	PTP - 1
2265	CODE	End of READ/INPUT ?
2266	CODE	No: process next variable
2269	CODE	Yes: restore DATA pointer
226a	CODE	--
226f	CODE	A = READ/INPUT flag
2272	CODE	READ ?
2273	CODE	DE = PTP	 HL = DATA pointer
2274	CODE	Yes: continue at 1D96H
2277	CODE	No: save PTP
2278	CODE	DOS
227b	CODE	Still data remaining in the buffer ?
227c	CODE	HL -> '?Extra ignored'
227f	CODE	Yes: print text
2282	CODE	Restore PTP
2283	CODE	Direct next output to screen
2286	CODE	; Text '?Extra ignored'
2294	BYTES	Carriage Return
2295	BYTES	End of string
2296	CODE	; Increment DATA pointer to next DATA line
2296	CODE	Increment HL to end of command or end of line
2299	CODE	End of line reached ?
229a	CODE	No: continue at 22AEH
229c	CODE	Program end reached ?
229d	CODE	(Line pointer = 0000H ?)
22a0	CODE	E = error code for ?OD Error
22a2	CODE	Yes: issue ?OD Error No:
22a5	CODE	DE = line number
22a9	CODE	Store line number of
22aa	CODE	DATA line
22ae	CODE	DATA line found ?
22af	CODE	First char. = 'DATA' token ?
22b1	CODE	No: continue search Yes:
22b3	CODE	HL = new DATA pointer
22b6	CODE	; NEXT statement
*		; --------------
22b6	CODE	Default address in case no loop variable is indicated
22b9	CODE	Get variable address in case loop variable is indicated
22bc	CODE	Save PTP
22bf	CODE	Search FOR stack with VARPTR = DE (next FOR stack in case DE = 0) FOR stack found ?
22c2	CODE	No: ?NF Error Yes:
22c5	CODE	SP = FOR stack pointer
22c6	CODE	Save SP value
22c9	CODE	Save variable address
22ca	CODE	A = step-SGN
22cb	CODE	Pointer + 1
22cc	CODE	Save step-SGN
22cd	CODE	Save variable address
22ce	CODE	Get variable type
22cf	CODE	Pointer + 1
22d0	CODE	Loop variable type INT ?
22d1	CODE	Yes: continue at 22EAH
22d4	CODE	; NEXT for SNG-variable
22d4	CODE	X = BCDE + (HL) (Step value into X)
22d7	CODE	Save pointer	 HL = VARPTR
22d8	CODE	Save address of loop var.
22d9	CODE	X = X + (HL)	 add step value to loop variable
22dc	CODE	Restore address
22dd	CODE	(HL) = X (copy new value into loop variable
22e0	CODE	Restore pointer (now on end value)
22e1	CODE	BCDE = (HL) = end value
22e4	CODE	Save pointer
22e5	CODE	CP X	BCDE (compare loop variable with end value)
22e8	CODE	Continue at 2313H
22ea	CODE	; NEXT for INT-variable
22ea	CODE	The first 4 bytes of the FOR
22eb	CODE	stack are not used
22ee	CODE	BC = step value
22f2	CODE	Save pointer	 HL = address
22f3	CODE	DE = loop value
22f6	CODE	Save address + 1
22f7	CODE	HL = step value
22f9	CODE	X = HL = HL + DE (add step value to loop variable)
22fc	CODE	Overflow ?
22ff	CODE	VT changed to SNG ?
2301	CODE	Yes: ?OV Error No:
2304	CODE	DE = new loop value
2305	CODE	Restore address + 1
2306	CODE	Save new loop variable value
2309	CODE	Restore pointer
230a	CODE	Save loop value
230b	CODE	DE = end value
230f	CODE	Save pointer	 HL = loop value
2310	CODE	CP HL	DE
2313	CODE	Restore pointer
2314	CODE	B = step-SGN B = 01H: End loop if          loop val. > end val. B = FFH: End loop if          loop val. < end val. A = FFH: loop val. < end val. A = 00H: loop val. = end val. A = 01H: loop val. > end val.
2315	CODE	Loop ended ?
2316	CODE	BCDE = (HL) (BC = LP on start of loop DE = line number)
2319	CODE	Yes: continue at 2324H
231b	CODE	; Loop continues
231b	CODE	HL = line number
231c	CODE	Save as current line number
231f	CODE	HL = line pointer
2321	CODE	Rebuild FOR stack and continue program execution at (HL)
2324	CODE	; Loop ends
2324	CODE	SP = end of stack (current FOR stack deleted)
2325	CODE	Save new SP in system RAM
2328	CODE	HL = PTP
232b	CODE	A = next character
232c	CODE	Is it a comma ?
232e	CODE	No: continue program at (HL) Yes:
2331	CODE	Increment PTP to next variable
2332	CODE	and process next variable
2335	CODE	; Process expression in parentheses and store result in X
2335	CODE	Next character must be
2336	ASCII	a '('
2337	CODE	; Process expression and store result in X
2337	CODE	PTP - 1
2338	CODE	Priority flag = 0
233a	CODE	Save flag
233b	CODE	Memory test: still 2 bytes
233d	CODE	free?
2340	CODE	Get 1st argument
2343	CODE	Save PTP in system RAM
2346	CODE	Restore PTP
2349	CODE	Restore priority flag
234a	CODE	A = token following argument (operator code)
234b	CODE	Operator flag = 0
234d	CODE	Comparison operator ? ( < 	 = 	 > )
234f	CODE	No: continue at 2364H
2351	CODE	Token value between D4H and D7H ?
2353	CODE	No: continue at 2364H
2355	CODE	; Process operators for compare ( < 	 = 	 > 	 =< 	 => 	 <= 	 >= 	 <> )
2355	CODE	C-flag = 1 in case of '<'
2357	CODE	'<' : A = 01 (bit 0 set) '=' : A = 02 (bit 1 set) '>' : A = 04 (bit 2 set)
2358	CODE	Xor A with last operator. A = 00 in case the same operator was indicated twice
2359	CODE	C-flag = 1 in case A = 00H !!
235a	CODE	D = new operator code Twice the same operator ?
235b	CODE	Yes: ?SN Error
235e	CODE	Save PTP
2361	CODE	Get next operator
2362	CODE	Another comparison operator ?
2364	CODE	; No operator for compare found
2364	CODE	A = operator flag
2365	CODE	Comparison operators found ?
2366	CODE	Yes: continue at 23ECH No:
2369	CODE	A = operator code
236a	CODE	Save PTP
236d	CODE	Code found ?
236f	CODE	No: done
2370	CODE	Valid code ( + 	 - 	 * 	 / 	 arrow up 	 AND 	 OR ) ?
2372	CODE	No: done
2373	CODE	DE = code offset (0 = '+'	 6 = 'OR')
2374	CODE	A = VT of 1st argument
2377	CODE	String argument ?
2379	CODE	And code = '+' ?
237a	CODE	Yes: string addition at 298FH
237d	CODE	; Priority test
237d	CODE	HL -> priority table
2380	CODE	Add offset
2381	CODE	A = old priority (at first = 0 !)
2382	CODE	D = current priority
2383	CODE	Compare both priorities Old priority was higher ?
2384	CODE	Yes: first calculate intermediate result
2385	CODE	Save old priority
2386	CODE	Set new RET-address
2389	CODE	to 2346H
238a	CODE	A = new priority
238b	CODE	Power calculation (^) ?
238d	CODE	Yes: continue at 23D4H
2390	CODE	boolean operator (AND	 OR) ?
2392	CODE	Yes: continue at 23E1H
2395	CODE	; Process operators '+'	 '-'	 '*' and '/'
*		; Store 1st argument or intermediate result on stack
2395	CODE	HL -> X
2398	CODE	C-flag = 0
2399	CODE	A = VT
239c	CODE	- 3
239e	CODE	Type of X = STR ?
239f	CODE	Yes: ?TM Error (for strings only '+' is allowed and this operator has already been checked)
23a2	CODE	BC = INT value
23a5	CODE	INT value on stack Type of X = INT ?
23a6	CODE	Yes: done
23a9	CODE	BC = MSBs of SNG value
23ad	CODE	MSBs of SNG-value on stack
23ae	CODE	Save VT - 3
23af	CODE	Type of X = SNG ?
23b0	CODE	Yes: done
23b3	CODE	Restore VT - 3
23b5	CODE	Jump is never executed
23b7	CODE	Save LSBs of DBL value
23ba	CODE	on stack
23c3	CODE	--
23c4	ENTRY	Restore VT - 3 (with INT- or SNG-value)
23c5	CODE	A = VT
23c7	CODE	C = offset of operator code
23c8	CODE	B = VT
23c9	CODE	Save both on stack
23ca	CODE	Set new RET-address
23cd	CODE	to 2406H
23ce	CODE	Restore PTP
23d1	CODE	Process next argument
23d4	CODE	X = CSNG (X)
23d7	CODE	(SP) = X
23da	CODE	BC -> power function
23dd	CODE	D = priority code
23df	CODE	Get 2nd argument and execute function
23e1	CODE	; Process logical expression
23e1	CODE	Save priority code
23e2	CODE	HL = X = CINT(X)
23e5	CODE	Restore priority code
23e6	CODE	Save 1st argument
23e7	CODE	BC -> AND/OR routine
23ea	CODE	Get 2nd argument and process logical expression
23ec	CODE	; Process compare operators
23ec	CODE	A = priority code
23ed	CODE	Last operator of higher priority?
23ef	CODE	Yes: compute intermediate result
23f0	CODE	No: save priority code
23f1	CODE	Save operator code
23f2	CODE	D = current priority E = offset for basic arithmatic (see table at 18ABH)
23f5	CODE	Set new RET-address
23f8	CODE	to 25B8H
23f9	CODE	TSTTYP STR type?
23fa	CODE	No: continue at 2395H Yes:
23fd	CODE	HL -> string vector
2400	CODE	Save pointer
2401	CODE	Set RET-address to 258CH (string compare)
2404	CODE	Get 2nd argument and execute function
2406	CODE	; Compute intermediate result
*		; 1st value: on stack	 2nd value: in X
2406	CODE	Restore VT of 1st argument
2407	CODE	A = operator code offset
2408	CODE	Save in system RAM
240b	CODE	A = VT
240c	CODE	1st argument in DBL format ?
240e	CODE	Yes: continue at 2438H
2410	CODE	A = VT of 2nd argument
2413	CODE	2nd argument in DBL format ?
2415	CODE	Yes: continue at 2460H
2418	CODE	D = VT of 2nd argument
2419	CODE	A = VT of 1st argument
241a	CODE	1st argument in SNG format ?
241c	CODE	Yes: continue at 2472H
241f	CODE	A = VT of 2nd argument
2420	CODE	2nd argument in STR format ?
2422	CODE	Yes: ?TM Error 2nd argument in SNG format ?
2425	CODE	Yes: continue at 247CH
2428	CODE	; 1st or 2nd argument in INT format
2428	CODE	HL -> jump table for basic arithmatic (INT)
242b	CODE	BC = operator offset
242d	CODE	Add offset twice
242e	CODE	(2 bytes address)
242f	CODE	BC = address
2432	CODE	DE = 1st argument
2433	CODE	HL = 2nd argument
2436	CODE	Put address on stack
2437	CODE	and execute routine
2438	CODE	; 1st argument in DBL format
2438	CODE	X = CDBL (X) (convert 2nd argument to DBL)
243b	CODE	Y = X
243e	CODE	Get 1st argument from stack
243f	CODE	and load into X
2448	CODE	X = BCDE
244b	CODE	X = CDBL (X) (convert 1st argument to DBL)
244e	CODE	HL -> jump table for basic arithmatic (DBL)
2451	CODE	A = operator code offset
2454	CODE	* 2 (2 bytes offset)
2455	CODE	Save BC
2456	CODE	BC = table offset
2459	CODE	Add offset
245a	CODE	Restore BC
245b	CODE	HL -> routine
245f	CODE	Execute routine
2460	CODE	; 2nd argument in DBL format
2460	CODE	Save VT offset
2461	CODE	Y = X (2nd argument to X)
2464	CODE	Restore VT
2465	CODE	Save VT in system RAM
2468	CODE	1st argument in SNG format ?
246a	CODE	Yes: get 1st argument from stack and convert to DBL
246c	CODE	No: 1st argument is an INT: Get 1st argument
246d	CODE	Put it into X
2470	CODE	and convert it to DBL
2472	CODE	; 1st argument in SNG format
2472	CODE	X = CSNG (X) (convert 2nd argument to SNG)
2475	CODE	Get 1st argument from stack
2477	CODE	HL -> jump table
247a	CODE	Execute function
247c	CODE	; 2nd argument in SNG format	 1st argument in INT format
247c	CODE	Restore 1st argument
247d	CODE	(SP) = X (save 2nd argument on stack)
2480	CODE	X = CSNG (HL)
2483	CODE	BCDE = X = 1st argument
2486	CODE	1st argument from stack
2487	CODE	Put it in X
248e	CODE	Continue at 2477H
2490	CODE	; IDIV: X = DE / HL
*		; Divides two integer numbers with the result in SNG format
*		;
*		; I: DE = Dividend
*		;    HL = Divisor
*		; O: X = Quotient
2490	CODE	Save divisor
2491	CODE	HL = dividend
2492	CODE	X = CSNG (DE) (X = dividend)
2495	CODE	Restore dividend
2496	CODE	(SP) = X (dividend to stack)
2499	CODE	X = CSNG (HL) (X = divisor)
249c	CODE	X = (SP) / X (execute SDIV)
249f	CODE	; Decode argument at (PTP) and store result in X
249f	CODE	Operand indicated ?
24a0	CODE	E = error code for ?MO Error
24a2	CODE	No: ?MO Error Yes: number indicated ?
24a5	CODE	Yes: decode number and store result in X No:
24a8	CODE	Variable indicated ?
24ab	CODE	Yes: continue at 2540H
24ae	CODE	'+' token ? (positive sign)
24b0	CODE	Yes: skip it	 get next character
24b2	CODE	'.' ? (decimal point)
24b4	CODE	Yes: decode number
24b7	CODE	'-' token ? (negative sign)
24b9	CODE	Yes: continue at 2532H
24bc	CODE	'"' ? (string constant)
24be	CODE	Yes: continue at 2866H
24c1	CODE	'NOT' token ?
24c3	CODE	Yes: continue at 25C4H
24c6	CODE	'&' ? (hexadecimal constant)
24c8	CODE	Yes: continue at 34E3H
24cb	CODE	'ERR' token ?
24cd	CODE	No: continue at 24D9H
24cf	CODE	; X = ERR
*		; -------
24cf	CODE	Adjust PTP
24d0	CODE	A = last error code
24d3	CODE	Save PTP
24d4	CODE	Save A to X as INT
24d7	CODE	Restore PTP
24d9	CODE	; Not ERR
24d9	CODE	'ERL' token ?
24db	CODE	No: continue at 24E7H
24dd	CODE	; X = ERL
*		; -------
24dd	CODE	Adjust PTP
24de	CODE	Save PTP
24df	CODE	HL = LN of last error line
24e2	CODE	X = HL (SNG) (no sign)
24e5	CODE	Restore PTP
24e7	CODE	; not ERL
24e7	CODE	'VARPTR' toekn ?
24e9	CODE	No: continue at 24FFH
24eb	CODE	; X = VARPTR()
*		; ------------
24eb	CODE	Adjust PTP
24ec	CODE	Next character must be
24ed	ASCII	a '('
24ee	CODE	DE = address of indicated variable. DE = 0000H in case variable not found
24f1	CODE	Next character must be
24f2	ASCII	a ')'
24f3	CODE	Save PTP
24f4	CODE	HL -> variable
24f5	CODE	Null pointer ?
24f7	CODE	Yes: ?FC Error No:
24fa	CODE	X = HL (INT)
24fd	CODE	Restore PTP
24ff	CODE	; Not VARPTR
24ff	CODE	'USR' token ?
2501	CODE	Intercept Colour BASIC token and continue at 27FEH in case 'USR' token found
2504	CODE	'INSTR' token ?
2506	CODE	Yes: continue at 41D9H
2509	CODE	'MEM' token ?
250b	CODE	Yes: continue at 27C9H
250e	CODE	'TIME$' token ?
2510	CODE	Yes: continue at 4176H
2513	CODE	'CHECK' token ?
2515	CODE	Yes: continue at 0132H
2518	CODE	'INKEY$' token ?
251a	CODE	Yes: continue at 01D9H
251d	CODE	'STRING$' token ?
251f	CODE	Yes: continue at 2A2FH
2522	CODE	'FN' token ?
2524	CODE	Yes: continue at 4155H
2527	CODE	Function token found ?
2529	CODE	Yes: continue at 254EH No:
252c	CODE	Since all other possibilities have been tested	 there can only be an expresssion enclosed in paranthesis at (PTP)
252f	CODE	Next character must be
2530	ASCII	a ')'
2531	CODE	return
2532	CODE	; Process negative sign
2532	CODE	D = priority code (next priority after power function)
2534	CODE	Argument to X
2537	CODE	Get PTP
253a	CODE	And save it
253b	CODE	Negate result (type conform)
253e	CODE	Restore PTP
2540	CODE	; Process variable as operand
2540	CODE	Get address of variable
2543	CODE	Save PTP
2544	CODE	HL = address
2545	CODE	Save address
2548	CODE	TSTTYP STR type ?
2549	CODE	No: X = (HL) (type conform)
254c	CODE	Restore PTP
254e	CODE	; Function token found
*		; A = 00H for SNG	 01H for INT	...	 22H for RIGHT$ and 24H for MID$
*		; (see keyword and address table at 1608H)
254e	CODE	MSB of offset = 00H
2550	CODE	A = A * 2 (2 bytes address)
2551	CODE	BC = offset of address table
2552	CODE	Save offset
2553	CODE	Adjust PTP
2554	CODE	A = offset LSB
2555	CODE	LSB > 41H ?
2557	CODE	No: continue at 256FH
2559	CODE	; Process 1st argument of LEFT$	 RIGHT$ or MID$
2559	CODE	Process expression
255c	CODE	Next character must be
255d	ASCII	a '	' 1st argument not a string ?
255e	CODE	Yes: ?TM Error
2561	CODE	DE = PTP
2562	CODE	HL -> 1st argument
2565	CODE	Save pointer
2566	CODE	Save offset to stack
2567	CODE	HL = PTP
2568	CODE	DE = 2nd argument
256b	CODE	DE = PTP	 HL = 2nd argument
256c	CODE	Save 2nd argument	 HL = offset
256d	CODE	Continue at 2583H
256f	CODE	; Get function argument and execute function
256f	CODE	Process expression
2572	CODE	Save PTP	 HL = offset
2573	CODE	A = LSB of offset
2574	CODE	LSB < 0CH ? (SNG/INT/ABS/FRE/ INP/POS)
2576	CODE	Yes: execute function No:
2578	CODE	LSB < 1BH ? (SQR/RND/LOG/EXP/ COS/SIN/TAN/ATN)
257a	CODE	Save offset
257b	CODE	Yes: X = CSNG (X)
257e	CODE	Restore offset
257f	CODE	Set new RET-address
2582	CODE	to 253EH
2583	CODE	BC -> jump table
2586	CODE	Add offset
2587	CODE	Load jump address in HL
258b	CODE	Execute function
258c	CODE	; String compare
*		;
*		; I: (SP-2) = RET addres to 25B8H
*		;    (SP)   = Vector address of 1st string
*		;     X     = Vector address of 2nd string
*		; O:  A     = FFH : 1st string < 2nd string
*		;           = 00H : 1st string = 2nd string
*		;           = 01H : 1st string > 2nd string
258c	CODE	Test 2nd argument if STR format	 HL -> vector of 2nd string
258f	CODE	A = LEN (2nd string)
2590	CODE	BC = address (2nd string)
2594	CODE	Restore vector address of 1st string in DE
2595	CODE	Save address and
2596	CODE	length of 2nd string
2597	CODE	HL -> vector of 2st string
259a	CODE	D = length of 2nd string
259b	CODE	E = length of 1st string
259c	CODE	BC = address of 1st string
25a0	CODE	HL = address of 2nd string
25a1	CODE	Both length counters zero ?
25a3	CODE	Yes: done	 return
25a4	CODE	A = 2nd length counter
25a5	CODE	Counter zero?
25a7	CODE	Yes: done	 return
25a8	CODE	A = 00H
25a9	CODE	1st length counter zero ?
25aa	CODE	A = 01H if so.
25ab	CODE	Yes: done	 return (A = 01H)
25ac	CODE	2nd length counter - 1
25ad	CODE	1st length counter - 1
25ae	CODE	Compare next character of 1st
25af	CODE	string with character of 2nd string
25b0	CODE	2nd pointer + 1
25b1	CODE	1st pointer + 1 Both characters identical ?
25b2	CODE	Yes: compare next characters
25b4	CODE	Negate C-flag
25b5	CODE	A = FFH in case C-flag = 1 A = 00H in case C-flag = 0
25b8	CODE	; Evaluate result of compare
*		;
*		; I: A = FFH : 1st argument < 2nd argument
*		;      = 00H : 1st argument = 2nd argument
*		;      = 01H : 1st argument > 2nd argument
25b8	CODE	A = A + 1 (C-flag = 1 if A was FFH)
25b9	CODE	A = 01H : 1st arg. < 2nd arg.   = 02H : 1st arg. = 2nd arg.   = 04H : 1st arg. > 2nd arg.
25ba	CODE	Restore compare operator code (see 2355H)
25bb	CODE	Set bits of operators done
25bc	CODE	A = A + FFH: C-flag = 1 if a condition was true (overflow in case A <> 0)
25be	CODE	A = 00H = 0 in case false else A = FFH = -1
25bf	CODE	X = HL = A (with sign)
25c2	CODE	Back to 2346H
25c4	CODE	; NOT
*		; ---
25c4	CODE	Priority code = 5AH (higher than AND and OR)
25c6	CODE	Argument to X
25c9	CODE	HL = X = CINT (X)
25cc	CODE	Negate result
25d2	CODE	And write back
25d5	CODE	Remove RET-address
25d6	CODE	and back to 2346H
25d9	CODE	; RST 20H
*		; -------
*		; TSTTYP: Test current VT and set corresponding flags
*		;
*		; I: -
*		; O: A = VT - 3
*		;    INT: A = FFH	 Z-flag = 0	 C-flag = 1	 S-flag = 1
*		;    STR: A = 00H	 Z-flag = 1	 C-flag = 1	 S-flag = 0
*		;    SNG: A = 01H	 Z-flag = 0	 C-flag = 1	 S-flag = 0
*		;    DBL: A = 05H	 Z-flag = 0	 C-flag = 0	 S-flag = 0
25d9	CODE	A = VT
25dc	CODE	DBL ?
25de	CODE	Yes: continue at 25E5H No:
25e0	CODE	A = VT - 3
25e2	CODE	Set flags
25e3	CODE	C-flag = 1
25e5	CODE	A = VT - 3
25e7	CODE	Set flags
25e9	CODE	; Process AND / OR
25e9	CODE	Save priority code
25ea	CODE	HL = X = CINT (X) = 2nd arg.
25ed	CODE	Restore priority code
25ee	CODE	DE = 1st argument
25ef	CODE	Set new RET-address
25f2	CODE	to 27FAH (X = HL (INT) )
25f3	CODE	Priority code = 46H (OR) ?
25f5	CODE	No: execute AND at 25FDH
25f7	CODE	; OR
*		; --
25f7	CODE	OR both arguments
25fc	CODE	Back to 27FAH
25fd	CODE	; AND
*		; ---
25fd	CODE	AND both arguments
2602	CODE	Back to 27FAH
2603	CODE	; Return after DIM
2603	CODE	PTP - 1
2604	CODE	End of command ?
2605	CODE	Yes: done	 return No:
2606	CODE	Next character must be
2607	ASCII	a comma
2608	CODE	; DIM statement
*		; -------------
2608	CODE	Set new return address
260b	CODE	to 2603H
260c	CODE	A <> 0 for DIM
260d	CODE	; Find address of variable in (PTP) and create variable if it does not
*		; exist.
*		;
*		; I: PTP -> variable name
*		; O: DE -> searched variable (0000H if variable does not exist)
260d	ENTRY	A = 0 for address search
260e	CODE	Store flag
2611	CODE	B = first character of name
2612	CODE	Is the character in (HL) a upper case character ?
2615	CODE	No: ?SN Error
2618	CODE	A = 00H
2619	CODE	C = default second character of variable name
261a	CODE	Second character present ?
261b	CODE	Jump when it is a number
261d	CODE	Upper case character present ?
2620	CODE	No: keep variable name at one character
2622	CODE	C = second character of name
2623	CODE	Get next character Is it a number ?
2624	CODE	Yes: get character
2626	CODE	Is it an upper case character ?
2629	CODE	Yes: get character
262b	CODE	Set new return address
262e	CODE	to 2652H
262f	CODE	D = 2 (type code for INT)
2631	CODE	'%' (INT indentifier) found ?
2633	CODE	Yes: D = type code
2634	CODE	D = 3 (type code for STR)
2635	CODE	'$' (STR indentifier) found ?
2637	CODE	Yes: D = type code
2638	CODE	D = 4 (type code for SNG)
2639	CODE	'!' (SNG indentifier) found ?
263b	CODE	Yes: D = type code
263c	CODE	D = 8 (type code for DBL)
263e	CODE	'#' (DBL indentifier) found ?
2640	CODE	Yes: D = type code
2641	CODE	; No type code indicated. Get type code from DEF table
2641	CODE	A = first character of name
2642	CODE	A = offset for type code table
2644	CODE	Clear highest bit
2646	CODE	DE = offset
2649	CODE	Save PTP
264a	CODE	HL -> type code table
264d	CODE	Add offset
264e	CODE	Get type code
264f	CODE	Restore PTP
2650	CODE	PTP - 1
2652	CODE	; Search variable / create variable
*		; BC = 1st and 2nd character of variable name
*		; D = type code of variable
2652	CODE	A = type code
2653	CODE	Save as VT
2656	CODE	Skip spaces/LF etc
2657	CODE	Array variables indicated ?
265a	CODE	(see 1CA1H)
265b	CODE	No: create normal variable
265e	CODE	A = next character following variable name.
265f	CODE	Is it a '('
2661	CODE	Yes: process array variable
2664	CODE	A = 00H
2665	CODE	Release array variable
2668	CODE	Save PTP
2669	CODE	Save type code
266a	CODE	HL -> start of variables
266d	CODE	DE = HL
266e	CODE	HL -> end of variables
2671	CODE	End reached ?
2672	CODE	Restore type code
2673	CODE	Yes: create new variable
2675	CODE	A = type code of variable addressed by DE
2676	CODE	L = type code
2677	CODE	Is it the searched code ?
2678	CODE	Pointer + 1
2679	CODE	No: continue at 2686H
267b	CODE	A = second character of name
267c	CODE	Same as in searched name ?
267d	CODE	No: continue at 2686H
2680	CODE	A = first charachter of name
2681	CODE	Same as in searched name ?
2682	CODE	Yes: continue at 26CCH
2685	CODE	--
2686	ENTRY	Pointer + 1
2687	CODE	Pointer + 1
2688	CODE	Save type code
2689	CODE	HL = length of variable found
268b	CODE	Put HL on next variable
268c	CODE	Repeat compare
268e	CODE	; Variable not found
268e	CODE	A = type code
268f	CODE	Restore PTP
2690	CODE	Save PTP	 HL = RET address
2691	CODE	Save type code
2692	CODE	Save pointer on end of variables
2693	CODE	Was routine CALLed by VARPTR function ?
2696	CODE	(RET address = 24F1H)
2697	CODE	Yes: continue at 26CFH
2699	CODE	CALLed from 2540H ?
269c	CODE	(RET address = 2543H)
269d	CODE	Restore pointer
269e	CODE	Yes: continue at 26D5H
26a0	CODE	; Create new variable
26a0	CODE	Restore type code
26a1	CODE	Save RET address	 restore PTP
26a2	CODE	Save PTP
26a3	CODE	Save variable name
26a4	CODE	C = type code
26a5	CODE	B = 00H
26a7	CODE	Save type code Calculate total length of var
26a8	CODE	BC + 1 for type code
26a9	CODE	BC + 2 for variable name
26ab	CODE	HL -> start of free space
26ae	CODE	Save pointer
26af	CODE	+ length = new start of free space
26b0	CODE	Restore old start address
26b1	CODE	Save new start address
26b2	CODE	Test memory space and move memory to create space for new variable
26b5	CODE	Restore new start address
26b6	CODE	Save it in system RAM
26b9	CODE	HL = new end address of
26ba	CODE	memory with single variables
26bb	CODE	Save it in system RAM
26be	CODE	Pointer - 1
26bf	CODE	Clear memory space for new variable
26c1	CODE	Done ?
26c2	CODE	No: continue clear
26c4	CODE	Restore type code HL -> new variable
26c5	CODE	Store type code
26c6	CODE	Pointer + 1
26c7	CODE	Restore variable name
26c8	CODE	Store 2nd character
26c9	CODE	Pointer + 1
26ca	CODE	Store 1st character
26cb	CODE	DE -> mantissa of new variable
26cc	CODE	DE -> new variable
26cd	CODE	Restore PTP
26cf	CODE	; VARPTR function: variable not found
26cf	CODE	DE = 0000H
26d1	CODE	Correct stack
26d3	CODE	Restore PTP	 save RET address
26d4	CODE	Done
26d5	CODE	; Variable at expression evaluation (2337H) not found
*		; Set result to 0
26d5	CODE	Exp (X) = 0 -> X = 0
26d8	CODE	Correct stack
26d9	CODE	HL = 0000H
26db	CODE	Set X (INT) to 0
26de	CODE	TSTTYP STR type ?
26df	CODE	No: X is ok	 continue at 26E7H Yes:
26e1	CODE	Vector address -> null string
26e4	CODE	X = HL
26e7	CODE	Restore PTP
26e9	CODE	; Array variable recognized
*		;
*		; BC = variable name
*		; HL = PTP
*		; A  = 00H
26e9	CODE	Save PTP
26ea	CODE	L = type code	 H = DIM flag
26ed	CODE	Save HL	 restore PTP
26ee	CODE	D = 0 (number of dimensions)
26ef	CODE	Save registers
26f1	CODE	Get next dimension at (PTP)
26f4	CODE	Restore registers
26f6	CODE	DE = PTP	 HL = dim. value
26f7	CODE	Save dim. value	 restore HL
26f8	CODE	Save HL again
26f9	CODE	HL = PTP
26fa	CODE	Dimension counter + 1
26fb	CODE	D = counter
26fc	CODE	Another dimension indicated ?
26fd	CODE	Separator found ?
26ff	CODE	Yes: get next dimension No:
2701	CODE	Next character must be
2702	ASCII	a ')'
2703	CODE	Save PTP
2706	CODE	Restore type code and DIM flag
2707	CODE	and save in system RAM
270a	CODE	Save dimension counter The stack now contains the dimension values and the number of dimensions
270b	CODE	HL -> start of array variable memory space
270e	CODE	--
270f	ENTRY	Add array size. HL now points on the next array
2711	CODE	DE -> end of array variable memory space
2715	CODE	End of array vars reached ?
2716	CODE	A = requested type code
2719	CODE	No: array variable not found. HL points to free memory space for the new array.
271b	CODE	Type code found ?
271c	CODE	Pointer + 1
271d	CODE	No: continue at 2727H
271f	CODE	2nd character of var. name
2720	CODE	and compare it
2721	CODE	Pointer + 1 Characters the same ?
2722	CODE	No: continue at 2728H
2724	CODE	Compare 1st character
2725	CODE	The same ?
2726	CODE	--
2727	ENTRY	Adjust pointer
2728	CODE	Pointer + 1
2729	CODE	DE = total length
272d	CODE	Array not found: check next
272f	CODE	New array to be created ?
2733	CODE	E = error code for ?DD Error
2735	CODE	Yes: the array already exists	 issue error.
2738	CODE	No: A = number of dimensions
2739	CODE	Does they match ?
273a	CODE	Yes: compute address of the requested array element
273d	CODE	E = error code for ?BS Error
273f	CODE	Issue error
2742	CODE	; Array not found
*		; HL -> free memory space for new array
2742	CODE	Save type code
2743	CODE	Pointer + 1
2744	CODE	DE = size of array element
2747	CODE	A = number of dimensions
2748	CODE	Save array name
274c	CODE	C = dimension counter
274d	CODE	Sufficient memory available ?
2750	CODE	Pointer + 1
2751	CODE	Pointer + 1
2752	CODE	Save pointer in system RAM
2755	CODE	Save number of dimensions
2756	CODE	Pointer + 1
2757	CODE	A = DIM flag
275a	CODE	If address search then C-flag = 0. If array create then C-flag = 1
275b	CODE	A = dimension counter
275c	CODE	BC = default dimension value Address search ?
275f	CODE	 Yes: continue at 2763H
2761	CODE	Restore dimension value
2762	CODE	+ 1 for zero element
2763	CODE	Save dimension value
2767	CODE	Save counter
2768	CODE	DE = DE * BC: calculate the total array size.
276b	CODE	Restore counter
276c	CODE	Counter - 1 All dimensions done ?
276d	CODE	No: next dimension Yes:
276f	CODE	Save 00H on stack
2770	CODE	BC = array size
2772	CODE	DE -> start of new array HL = array size
2773	CODE	HL -> new end of array variable memory space Memory overflow ?
2774	CODE	Yes: ?BS Error
2776	CODE	Still free memory remaining ?
2779	CODE	Save new end address
277c	CODE	Pointer - 1
277d	CODE	Clear array byte
277f	CODE	Start of array reached ?
2780	CODE	No: clear next byte
2782	CODE	BC = number of required bytes + 1
2783	CODE	D = 0
2784	CODE	HL -> number of dimensions
2787	CODE	DE = number of dimensions
2788	CODE	HL = dimension counter DE = pointer
2789	CODE	HL = 2 * number of dimensions (Every dimension value is stored in 2 bytes)
278a	CODE	+ number of bytes required by the array elements = total size (in bytes)
278b	CODE	DE = total size
278c	CODE	Pointer - 2
278e	CODE	Save total size
2792	CODE	Restore flags from stack Creation of new array (DIM) ?
2793	CODE	Yes: done.
2795	CODE	; Compute address of required variable
2795	CODE	BC = 0000H
2797	CODE	A = dimension counter
2798	CODE	Pointer + 1
2799	CODE	--
279a	ENTRY	Restore pointer
279b	CODE	DE = next dimension value
279f	CODE	Save pointer	 HL = requested dimension
27a0	CODE	Save counter
27a1	CODE	Requested dimension found ? Requested dim. > found dim. ?
27a2	CODE	Yes: ?BS Error No:
27a5	CODE	DE = DE * BC = found dimension * last value
27a8	CODE	HL = requested dimension + found dimension * last value
27a9	CODE	Restore counter
27aa	CODE	Counter - 1
27ab	CODE	BC = array element counter
27ad	CODE	Process next dimension
27af	CODE	A = type code
27b2	CODE	BC = index value of array
27b3	CODE	element
27b4	CODE	* 2 = offset for INT
27b5	CODE	Typecode = INT or STR ?
27b7	CODE	Yes: continue at 27BDH No:
27b9	CODE	* 2 = offset for SNG Type code = SNG ?
27ba	CODE	Yes: continue at 27C2H No:
27bc	CODE	* 2 = offset for DBL
27bd	CODE	Type code = INT or DBL ?
27be	CODE	Yes: HL contains proper offset No:
27c1	CODE	Add again: offset for STR
27c2	CODE	Start address array to BC
27c3	CODE	+ offset = requested address
27c4	CODE	DE = address
27c5	CODE	HL = PTP
27c9	CODE	; MEM = FRE (numerical variable )
27c9	CODE	A = 0
27ca	CODE	Save PTP
27cb	CODE	Set type code to 0
27ce	CODE	X = end of stack - start of free memory = number of free bytes
27d1	CODE	Restore PTP
27d2	CODE	Increase PTP
27d4	CODE	; X = FRE ( arg )
*		; ---------------
27d4	CODE	HL = start of free memory
27d7	CODE	DE = HL
27d8	CODE	HL = 0000H
27db	CODE	HL = 0 + SP = SP
27dc	CODE	TSTTYP STR ? (number of free bytes in string space required)
27dd	CODE	No: continue at 27ECH Yes:
27df	CODE	Clear argument from string space
27e2	CODE	Sort string space
27e5	CODE	HL -> start of string space
27e8	CODE	DE = HL
27e9	CODE	HL -> last string in string space
27ec	CODE	Compute the number of free
27ed	CODE	bytes; result in HL
27f2	CODE	X = HL
27f5	CODE	; X = POS (dummy)
*		; ---------------
27f5	CODE	A = cursor position in line
27f8	CODE	HL = A (without sign)
27fb	CODE	X =  HL (INT)
27fe	CODE	; X = USR ( X )
*		; -------------
27fe	CODE	DOS
2801	CODE	Increase PTP
2802	CODE	Process expression
2805	CODE	Save PTP
2806	CODE	Set new RET address
2809	CODE	to 0890H
280a	CODE	A = type code
280d	CODE	Save type code
280e	CODE	STR argument?
2810	CODE	Yes: remove argument from string space
2813	CODE	Restore type code
2814	CODE	DE = 0890H (numerical argument) DE = vector address (string argument)
2815	CODE	HL -> USR routine
2818	CODE	Execute routine
2819	CODE	; Conversion of X into desired type
*		;
*		; I: A = desired type code
*		; (see 1F35H)
2819	CODE	Save HL
281a	CODE	A = offset for jump table INT: A = 2	 STR A = 3 SNG: A = 4	 DBL A = 0
281c	CODE	HL -> jump table for type conversion
281f	CODE	BC = offset
2822	CODE	Add offset to pointer
2823	CODE	Add offset again (2 bytes per address) and execute routine
2826	CODE	restore HL
2828	CODE	; SUB for INPUT
*		; Test for ?ID Error
*		; (see 219AH)
2828	CODE	Save PTP
2829	CODE	HL = current LN
282c	CODE	Current LN = 65535 ?
282d	CODE	(HL + 1 = 0000H)
282e	CODE	(65535 = LN for command mode)
282f	CODE	Restore PTP
2830	CODE	No: ok	 return
2831	CODE	; ?ID Error
2831	CODE	E = error code for ?ID Error
2833	CODE	Issue error
2836	CODE	; X = STR$ ( X )
*		; --------------
2836	CODE	Convert X into string from 4130H onwards
2839	CODE	Take string constant
283c	CODE	and remove from string space HL -> string vector
283f	CODE	Set new Return address
2842	CODE	to 2A2BH
2843	CODE	; Insert new string into string space
*		;
*		; I: HL -> vector to new string (somewhere in memory)
*		; O: DE -> vector to new string (in string space)
2843	CODE	A = string length
2844	CODE	Pointer + 1
2845	CODE	Save pointer
2846	CODE	Are there still A bytes free in string space ? Yes: DE -> 1st free byte for the new string No: ?OS Error
2849	CODE	Restore pointer
284a	CODE	String address to BC
284d	CODE	Store length and address of free memory (in string space) as last entry in string table
2850	CODE	Save vector address of new string space
2851	CODE	L = string length
2852	CODE	Copy string from (BC) to (DE): Copy string to string space
2855	CODE	DE -> vector to new string
2857	CODE	; Search for room in string space
*		;
*		; I: A = length of new string
*		; O: DE = start address in string space of the new string
*		;    HL = 40D3H = vector address of free string
2857	CODE	Still A bytes free in string space ? Yes: DE -> 1st free byte No: ?OS Error
285a	CODE	HL -> vector of free string
285d	CODE	Save pointer
285e	CODE	A = string length
2860	CODE	Store address of free string
2861	CODE	space memory
2863	CODE	Retore vector address
2865	CODE	; Process string constant at (HL) and store in string table
*		;
*		; I: HL -> string constant (terminated with '"' or 00H
*		; O: A = last string character
*		;    HL -> end of string
*		;    X = vector address of new string
2865	CODE	Pointer - 1
2866	CODE	B = 1st delimiter char. ('"')
2868	CODE	D = 2nd delimiter character
2869	CODE	Save pointer
286a	CODE	Set length counter to -1
286c	CODE	Pointer + 1
286d	CODE	Get string character
286e	CODE	Counter + 1
286f	CODE	End of string (00H) ?
2870	CODE	Yes: continue 2878H
2872	CODE	2nd delimiter reached?
2873	CODE	Yes: end of string No:
2875	CODE	Start delimiter reached ?
2876	CODE	No: get next character Yes:
2878	CODE	String terminated by '"' ?
287a	CODE	Yes: increase pointer
287d	CODE	Save end pointer	 HL = start pointer
287e	CODE	Pointer + 1
287f	CODE	DE = start pointer
2880	CODE	C = length
2881	CODE	Store length and pointer as last entry in string table
2884	CODE	DE = string vector
2887	CODE	--
2888	ENTRY	Called from FN routine in DOS
2889	CODE	HL = next free position in string table
288c	CODE	Save vector address in X
288f	CODE	Set VT to STR
2894	CODE	Copy 3 bytes from (DE) to (HL) (copy length and address into string table)
2897	CODE	End of string table reached ?
289a	CODE	(HL = 40D6H)
289b	CODE	Save table pointer
289e	CODE	Restore end pointer
289f	CODE	A = last character
28a0	CODE	No: done	 return Yes:
28a1	CODE	E = error code for ?ST Error
28a3	CODE	Issue error
28a6	CODE	; Process and output text constant at (HL)
*		;
*		; I: HL -> string constant
28a6	CODE	Pointer + 1
28a7	CODE	Copy string constant
28aa	CODE	and remove it from string table
28ad	CODE	D = length	 BC = start address of string
28b0	CODE	Counter + 1
28b1	CODE	Counter - 1; counter = 0 ?
28b2	CODE	Yes: done	 return
28b3	CODE	Get character
28b4	CODE	Output character
28b7	CODE	CR/LF ?
28b9	CODE	Yes: call DOS
28bc	CODE	Pointer + 1
28bd	CODE	Next character
28bf	CODE	; Check for room in string space
*		; In case there are less than A bytes free in string space	 the string space
*		; is sorted (garbage collection) and the routine is called again.
*		; If the string space is full a ?OS Error is generated
*		;
*		; I: A = number of required bytes
*		; O: DE -> A bytes free space in string space
*		;    HL -> start of string space
28bf	CODE	Z-flag = 0: 1st run
28c0	CODE	--
28c1	ENTRY	; Entry at 2nd call (after sorting)
28c1	ENTRY	Restore AF (Z-flag is now 1 !)
28c2	CODE	Save AF
28c3	CODE	HL -> start of string space
28c6	CODE	DE = HL
28c7	CODE	HL -> first free byte in string space (the string space is filled top down!)
28ca	CODE	A = -A
28cb	CODE	BC = number of required bytes
28ce	CODE	HL = HL + (-number of required bytes) = start address for the new string
28cf	CODE	+ 1 (HL already pointed to a free byte)
28d0	CODE	Still inside string space ?
28d1	CODE	No: sort string space and try     again at 1st run     ?OS Error at 2nd run Yes:
28d3	CODE	Store pointer
28d6	CODE	Pointer + 1
28d7	CODE	DE -> free space
28d8	CODE	Restore AF
28da	CODE	; Sort string space (garbage collection)
*		; Check if there are string in the string space	 that belong to already
*		; cleared variables. If so	 remove this garbage and move the used string
*		; space accordingly.
28da	CODE	Restore flag Already the 2nd run ?
28db	CODE	E = error code for ?OS Error
28dd	CODE	Yes: issue error
28e0	CODE	Z-flag = 1 (mark 2nd run)
28e1	CODE	Save flag
28e2	CODE	Set new RET address
28e5	CODE	to 28C1H
28e6	CODE	HL -> End of string space
28e9	CODE	; Search next highest string in string space and sort
*		; (highest string is the string with the highest start address)
*		; HL = address of string last inserted and sorted in string space
*		; (= address of last string in string space at last run)
28e9	CODE	Store address of last string sorted
28ec	CODE	HL = 0000H (default address)
28ef	CODE	Save it on stack
28f0	CODE	HL -> start of string space
28f3	CODE	Save pointer on stack
28f4	CODE	; Test on highest string starts at the string space start address and ends
*		; on the last inserted and sorted string.
*		; The highest string in this range is then sorted and the routine is
*		; repeated until no highest string is found (all strings are sorted)
*		; Looks like bubblesort is used!
28f4	CODE	HL -> start of string table = vector address of the first string in the string table
28f7	CODE	; Test all string variables
*		; First the entries in the string table	 then the string (single) variables
*		; and finally the string array variables are tested to see if they are
*		; located in string space
28f8	CODE	DE -> next free location in string space
28fc	CODE	End of table reached?
28fd	CODE	BC = new RET address
2900	CODE	No : continue at 29A4H
2903	CODE	HL -> start of BASIC var space
290a	CODE	DE -> start of array variables
290b	CODE	End of single variables storage space reached?
290c	CODE	Yes: continue at 2921H
290e	CODE	A = type code
290f	CODE	Pointer + 1 (type code)
2910	CODE	Pointer + 2 (name)
2912	CODE	String variable found ?
2914	CODE	No: test next variable Yes:
2916	CODE	Test address
2919	CODE	A = 00H
291a	CODE	DE = offset to next variable
291d	CODE	Add offset: HL -> vector of next variable
291e	CODE	Test next variable
2920	CODE	; End of single variable space reached.
*		; Test array variables.
2920	CODE	Correct stack
2922	CODE	DE -> end of array variable
2925	CODE	space
2926	CODE	End reached ?
2927	CODE	Yes: insert highest string and sort No:
292a	CODE	A = type code of array element
292b	CODE	Pointer + 1
292c	CODE	BCDE = (HL): DE = name	 BC = length of array
292f	CODE	Save pointer
2930	CODE	HL = pointer on next array
2931	CODE	String array found ?
2933	CODE	No: test next array Yes:
2935	CODE	Save pointer
2938	CODE	HL -> number of dimensions
2939	CODE	BC = number of dimensions
293c	CODE	Add twice (every dimension
293d	CODE	is stored in 2 bytes) HL now contains the vector address of the first array element - 1
293e	CODE	HL + 1: vector
293f	CODE	DE -> next array (= end address
2940	CODE	of current array	 see 2935H)
2944	CODE	End of array reached ?
2945	CODE	Yes: test next array No:
2947	CODE	Set new RET address
294a	CODE	to 293FH
294b	CODE	; Check string address of found string variable
*		; Two criteria exist:
*		; 1. Is the string in string space and not reused again ?
*		;    (Is the string address smaller than the address of the last string
*		;     sorted and inserted ?)
*		; 2. Is the string located at a higher position in string space than the
*		;    string that is accepted to be the highest string in string space ?
*		;    (Is the string address bigger than the string address of the string
*		;     that is the highest accepted string ?)
*		;
*		; If both criteria are true	 the address of the found string is stored on stack
*		; as the highest address.
*		;
*		; I: HL = vector address of string variable
*		; O: HL = vector address on the next variable
294b	CODE	A = 00H
294c	CODE	A = string length
294d	CODE	Pointer + 1
294e	CODE	DE -> string
2952	CODE	String length = 0 ?; Yes: done	 return No:
2953	CODE	; 1st criterium
2953	CODE	BC -> vector of next variable
2955	CODE	HL = address of last inserted variable
2958	CODE	Is the found string already re-inserted into the string space ? (Is the string address greater thean de address of the last inserted string ?)
2959	CODE	HL -> vector
295b	CODE	Yes: done	 return No:
295c	CODE	; 2nd criterium
295c	CODE	HL = RET address
295d	CODE	Save RET address HL = address of last inserted highest string (see 2968H)
295e	CODE	Start address of string > HL ?
295f	CODE	Put HL and RET adrress
2960	CODE	back on the stack
2961	CODE	HL -> vector
2963	CODE	No: done	 return Yes:
2964	CODE	; New highest string found
*		; Save string address and vector address on stack
2964	CODE	BC = RET address
2965	CODE	Remove start address of last inserted highest string
2966	CODE	and its vector address from stack
2967	CODE	Save current vector address
2968	CODE	and start address of string on stack
2969	CODE	Put RET address back on stack
296b	CODE	; All stringvariables tested
*		; Sort and insert new highest string behind last sorted and inserted string
*		; and clear all garbage in between.
296b	CODE	Take address of highest string
296c	CODE	and the vector address
296d	CODE	Address changes since 28ECH ?
296e	CODE	(new highest string found ?)
296f	CODE	No: done	 return
2970	CODE	; A new highest string has been found
2970	CODE	BC = address of new highest
2971	CODE	string
2972	CODE	( = DE because the address
2973	CODE	belongs to DE )
2974	CODE	Save address + 1
2975	CODE	HL - 1 = vector address of last tested string
2977	CODE	HL = string length
2979	CODE	HL = length + string address
297a	CODE	DE = string address
297c	CODE	HL = end address of string
297d	CODE	BC = HL
297f	CODE	HL = address of last inserted string
2982	CODE	Insert new string by attaching the new string to the last inserted string
2985	CODE	Restore vector address + 1
2986	CODE	Use new start address
2989	CODE	HL = start address of inserted
298a	CODE	string
298b	CODE	HL - 1 = address of last inserted string
298c	CODE	Search next highest string
298f	CODE	; String addition
*		;
*		; I: HL = PTP on '+'
*		;    BC = priority code
*		;    X  = 1st string
*		; O: X  = new string
298f	CODE	Save priority code
2990	CODE	Save PTP
2991	CODE	HL -> vector of 1st string
2994	CODE	Save vector adrress and restore PTP
2995	CODE	X = 2nd string
2998	CODE	Save PTP and restore vector of 1st string
2999	CODE	?TM Error if X is not STR type
299c	CODE	A = length of 1st string
299d	CODE	Save vector address of 1st string
299e	CODE	HL -> vector of 2nd string
29a1	CODE	Save vector address of 2nd string
29a2	CODE	A = total length of new string
29a3	CODE	E = error code for ?LS Error Overflow ? (new string too long)
29a5	CODE	Yes: ?LS Error No:
29a8	CODE	Reserve A bytes of free space in string space. HL -> vector new string (space)
29ab	CODE	Restore vector address of 2nd string
29ac	CODE	Delete 2nd string from string table and string space ?
29af	CODE	Save vector address of 2nd string and restore vector address of 1st string
29b0	CODE	Delete 1nd string from string table and string space ?
29b3	CODE	Save vector address of 1st string
29b4	CODE	HL = address of free space for new string
29b7	CODE	DE = HL
29b8	CODE	Copy 1st string into new space
29bb	CODE	Copy 2nd string behind 1st string
29be	CODE	Jump back to decoding of expression ar 2349H
29c1	CODE	New RET address on stack
29c2	CODE	Save old RET address on stack
29c3	CODE	Insert new string into string table
29c6	CODE	; Copy string to (DE)
*		;
*		; I: (SP - 2) -> string vector
*		;          DE =  new string address
29c6	CODE	RET address to HL
29c7	CODE	Get vector address and put RET address back on stack
29c8	CODE	A = length
29ca	CODE	BC = string address
29cd	CODE	L = counter
29ce	CODE	Adjust counter
29cf	CODE	Counter - 1 Counter = 0 ?
29d0	CODE	Yes: done	 return No:
29d1	CODE	Copy byte from (BC)
29d2	CODE	to (DE)
29d3	CODE	Source pointer + 1
29d4	CODE	Destination pointer + 1
29d5	CODE	Next byte
29d7	CODE	; Remove string in X from string table and string space ?
*		;
*		; When using string-functions all string constants and intermediate results
*		; are basically intermediate in the string table and string space.
*		; Since these strings are only used by the function	 they can be removed
*		; after completion of the function
*		;
*		; I: X   = string
*		; O: HL -> string vector
29d7	CODE	Test if X in STR format
29da	CODE	HL -> string vector
29dd	CODE	; Remove from string table and string space ?
29dd	CODE	DE -> string vector
29de	CODE	If the vector address points to the last entry in the string table	 it will be deleted (in this case it is an intermediate result or a string constant)
29e1	CODE	HL -> string vector Last entry deleted ?
29e2	CODE	No: done	 return
29e3	CODE	Save vector address
29e4	CODE	BC = string address
29e6	CODE	DE - 1
29e7	CODE	C = string lenght
29e8	CODE	HL = address of last string in string space - 1
29eb	CODE	Is the string the last one in string space ? (this means it is a string constant !)
29ec	CODE	No: done Yes:
29ee	CODE	B = 0	 BC = string length
29ef	CODE	Add string length to HL HL now points on the new last string in string space
29f0	CODE	Store address (the string constant is now removbed from string space)
29f3	CODE	Restore vector address
29f5	CODE	; Does DE point to the last entry of the string table ?
*		; If it does	 then the last entry is deleted.
*		;
*		; I: DE -> string vector
*		; O: BC =  string address of last entry in string table
*		;    DE -> string vector
*		;    HL =  DE
*		;    Z-flag = 1: the entry was deleted
29f5	CODE	HL -> next free entry of string table
29f9	CODE	BC = string address
29fd	CODE	Does DE point to this entry ?
29fe	CODE	No: done	 return Yes:
29ff	CODE	Save new address (overwrite old entry)
2a03	CODE	; X = LEN ( X )
*		; -------------
2a03	CODE	Set new return address
2a06	CODE	to 27F8H
2a07	CODE	Test X has STR format Remove string from string table and string space ? HL -> vector of string arg.
2a0a	CODE	A = 00H
2a0b	CODE	D = 00H
2a0c	CODE	A = string length
2a0d	CODE	Set flags
2a0e	CODE	Return to 27F8H: write A to X as INT
2a0f	CODE	; X = ASC (  )
*		; ------------
2a0f	CODE	Set new return address
2a12	CODE	to 27F8H
2a13	CODE	Get string length and vector address Length zero ?
2a16	CODE	Yes: ?FC Error HL -> string variable
2a1a	CODE	DE -> string
2a1d	CODE	A = first string character
2a1e	CODE	Return to 27F8H: write A to X as INT
2a1f	CODE	; X = CHR$ (  )
*		; -------------
2a1f	CODE	A = length of resulting string
2a21	CODE	Create room in string space
2a24	CODE	Argument to DE
2a27	CODE	HL -> string
2a2a	CODE	Write ASCII value into string
2a2b	CODE	Remove RET address
2a2c	CODE	Put string in string space
2a2f	CODE	; X = STRING$
*		; -----------
2a2f	CODE	Adjust PTP
2a30	CODE	Next character must be
2a31	ASCII	a '('
2a32	CODE	Get and save string length
2a36	CODE	Next character must be
2a37	ASCII	a comma
2a38	CODE	Put argument into X
2a3b	CODE	Next character must be
2a3c	ASCII	a ')'
2a3d	CODE	Save PTP	 restore length
2a3e	CODE	Save length
2a3f	CODE	TSTTYP: STR argument ?
2a40	CODE	Yes: continue at 2A47H No:
2a42	CODE	Is the number in range from 0 to 255 ? No: ?FC Error
2a45	CODE	Continue at 2A4AH (A = number)
2a47	CODE	A = ASCII value of first character of string argument
2a4a	CODE	Restore length
2a4b	CODE	Dummy push because of jump to 2A2BH after ending
2a4c	CODE	Save character
2a4d	CODE	A = length
2a4e	CODE	Reserve space
2a51	CODE	E = counter
2a52	CODE	Restore character
2a53	CODE	Counter = 0?
2a55	CODE	Yes: use string No:
2a57	CODE	HL -> free space
2a5a	CODE	Store character
2a5b	CODE	Pointer + 1
2a5c	CODE	Counter - 1	 counter = 0 ?
2a5d	CODE	No: next character Yes:
2a5f	CODE	Use string
2a61	CODE	; LEFT$
*		; -----
*		;
*		; I: (SP - 2) -> vector of the string argument
*		;    (SP)     =  number
2a61	CODE	')'? B = number = new string length
2a64	CODE	Set starting point on 0
2a65	CODE	; Entry for RIGHT$
*		;
*		; I: A = starting point of new string
*		;    B = length of new string
2a65	CODE	Save PTP	 HL -> vector
2a66	CODE	C = A = starting point of new string - 1
2a67	CODE	--
2a68	ENTRY	; Entry for MID$
*		;
*		; I: B = length of new string
*		;    C = starting point of new string inside string argument - 1
2a68	ENTRY	Save vector address
2a69	CODE	; Get substring from string argument (in X) and store in X
*		;
*		; I: X = string argument
*		;    B = length of new string
*		;    C = starting point of new string inside string argument - 1
*		; O: X = requested substring
2a69	CODE	Save vector address
2a6a	CODE	A = length of argument string
2a6b	CODE	Substring longer than argument string ?
2a6c	CODE	Yes: set C to 0 and use the complete argument string No:
2a6e	CODE	A = required length
2a6f	CODE	--
2a70	ENTRY	Starting point = 0
2a72	CODE	Save BC
2a73	CODE	Free up A bytes of space DE -> free space
2a76	CODE	Restore BC
2a77	CODE	Resore vector address
2a78	CODE	and save it again
2a79	CODE	Vector address + 1
2a7a	CODE	HL -> argument string
2a7e	CODE	BC = offset to new starting point
2a80	CODE	HL -> start of substring
2a81	CODE	BC -> start of substring
2a83	CODE	Store length and address of new string in string table
2a86	CODE	L = length of substring
2a87	CODE	Copy characters of argument string to (DE)
2a8a	CODE	Restore vector address of argument string
2a8b	CODE	Delete argument string from string space and string table?
2a8e	CODE	Use new string
2a91	CODE	; RIGHT$
*		; ------
*		;
*		; I: (SP - 2) -> vector of the string argument
*		;    (SP)     =  number (start of new string)
2a91	CODE	')'? B = number
2a94	CODE	DE = vector address
2a95	CODE	Back into stack
2a96	CODE	A = argument string length
2a97	CODE	A = length - number = starting point of new string
2a98	CODE	Continue at 2A65H
2a9a	CODE	; MID$
*		; ----
*		; (on the right hand side of the equal sign
*		;
*		; I: (SP - 2) -> vector of the string argument
*		;    (SP)     =  number (start of new string)
2a9a	CODE	HL = PTP
2a9b	CODE	A = next character
2a9c	CODE	B = starting point
2a9f	CODE	Starting point = 0 ?
2aa1	CODE	Yes: ?FC Error No:
2aa4	CODE	Save starting point
2aa5	CODE	E = default length (in case of missing length indication the total string length from starting point onwards is used)
2aa7	CODE	Next character = ')' ?
2aa9	CODE	Yes: E = length No:
2aab	CODE	Next character must be
2aac	ASCII	a comma
2aad	CODE	Get length and store in E
2ab0	CODE	Next character must be
2ab1	ASCII	a ')'
2ab2	CODE	A = starting point
2ab3	CODE	Save PTP	 restore vector addr.
2ab4	CODE	Set new RET address
2ab7	CODE	to 2A69H
2ab8	CODE	A = starting point - 1
2ab9	CODE	Compare with length of argument string
2aba	CODE	Length of new string = 0
2abc	CODE	Create string with length = 0 in case starting point is larger than string length
2abd	CODE	C = starting point - 1
2abe	CODE	A = length of arg. string
2abf	CODE	- statring point = remaining string length
2ac0	CODE	Requested length > remaining length
2ac1	CODE	B = remaining length
2ac2	CODE	Yes: B = length No:
2ac3	CODE	B = requested length
2ac4	CODE	Use this
2ac5	CODE	; X = VAL (  )
*		; ------------
2ac5	CODE	Get vector address and length of argument. D = 00H String length zero ?
2ac8	CODE	Yes: result = 0. No:
2acb	CODE	E = length
2acc	CODE	Vector address + 1
2acd	CODE	HL -> string
2ad1	CODE	Save pointer
2ad2	CODE	Calculate string end address
2ad3	CODE	Get next character
2ad4	CODE	and replace it by 00H
2ad5	CODE	Save end address	 restore start address
2ad6	CODE	Save character
2ad7	CODE	A = 1st character
2ad8	CODE	Decode string	 X = number
2adb	CODE	Restore characater
2adc	CODE	Restore end address
2add	CODE	Insert character
2adf	CODE	; SUB for LEFT$	 RIGHT$ and MID$
*		; Test for closing bracket and get first number from stack
2adf	CODE	HL = PTP
2ae0	CODE	Next character must be
2ae1	ASCII	a ')'
2ae2	CODE	BC = RET address
2ae3	CODE	DE = number
2ae4	CODE	Put RET address on stack
2ae5	CODE	B = number
2ae7	CODE	; Token found not in the range from 80H to BBH (see 1D67H)
*		; (not a command)
2ae7	CODE	Is it MID$ ? (left of '=' sign !)
2ae9	CODE	No: ?SN Error
2aec	CODE	Yes: DOS
2aef	CODE	; IN statement
*		; ------------
2aef	CODE	A = port address
2af2	CODE	Save it
2af5	CODE	Perform IN
2af8	CODE	Write A to X as INT
2afb	CODE	; OUT statement
*		; -------------
2afb	CODE	Get port address and value
2afe	CODE	Perform OUT
2b01	CODE	; Decode argument at (HL) and store in X as an INT
*		;
*		; I: HL = PTP
*		; O: DE = number
*		;    A = MSB of number
*		;    Z-flag = 1 if number < 256 (MSB = 0)
2b01	CODE	Get next non-space character
2b02	CODE	Decode argument
2b05	CODE	Save PTP
2b06	CODE	HL = X = CINT ( X )
2b09	CODE	DE = INT number
2b0a	CODE	Restore PTP
2b0b	CODE	A = MSB
2b0c	CODE	MSB = 0 ?
2b0e	CODE	; SUB for OUT
*		; Get port address and prepare RAM at 4096H
2b0e	CODE	Get port address
2b11	CODE	Store for IN
2b14	CODE	and OUT
2b17	CODE	Next character must be
2b18	ASCII	a comma
2b19	CODE	Get value and return
2b1b	CODE	; Decode argument at (HL) and store in X as INT
*		; ?FC Error if the result is not in the range from 0 to 255
*		;
*		; I: HL = PTP
*		; O: A = number
*		;    DE = number
2b1b	CODE	Get next non-space character
2b1c	CODE	Decode argument
2b1f	CODE	In range [0..255] ?
2b22	CODE	No: ?FC Error
2b25	CODE	PTP - 1
2b26	CODE	And increment again
2b27	CODE	A = number
2b29	CODE	; LLIST statement
*		; ---------------
2b29	CODE	Set output flag to
2b2b	CODE	printer output
2b2e	CODE	; LIST statement
*		; --------------
2b2e	CODE	Remove RET address
2b2f	CODE	Get line number
2b32	CODE	LP on first line
2b33	CODE	Set current LN to 65535
2b39	CODE	HL = LP on line
2b3a	CODE	DE = LN of last line
2b3b	CODE	BC = LP on next line
2b3f	CODE	End of program reached ?
2b41	CODE	Yes: done	 continue at 1A19H
2b44	CODE	DOS
2b47	CODE	<SHIFT>+<@> or <BREAK> pressed ?
2b4a	CODE	Save LP
2b4b	CODE	BC = line number
2b4c	CODE	of current line
2b4f	CODE	Save line number
2b50	CODE	Save pointer	 restore LN
2b51	CODE	DE = current line number HL = last line number
2b52	CODE	Current line number > last line number ?
2b53	CODE	Pointer on current line back in BC
2b54	CODE	Yes: done	 continue at 1A18H
2b57	CODE	Save last line number HL = LP on next line
2b58	CODE	Save LP on next line
2b59	CODE	Save LP on current line
2b5a	CODE	HL = current line number
2b5b	CODE	Save as '.'-line
2b5e	CODE	Print HL as decimal number
2b61	CODE	A = ' '
2b63	CODE	Restore pointer on current line
2b64	CODE	Print space
2b67	CODE	Decode line from (HL) onwards and store in line buffer
2b6a	CODE	HL -> start of line buffer
2b6d	CODE	Print line
2b70	CODE	Start new line
2b73	CODE	Process next line
2b75	CODE	; SUB for LIST
*		; Print text from (HL) onwards	 00H = end of text
*		;
*		; I: HL -> text to be printed
*		; O: HL -> end of text (00H)
2b75	CODE	A = next character
2b76	CODE	End of text ?
2b77	CODE	Yes: done	 return
2b78	CODE	Print it
2b7b	CODE	Pointer + 1
2b7c	CODE	Next character
2b7e	CODE	; SUB for LIST and EDIT
*		; Decode line from (HL) onwards and store result in line buffer
*		;
*		; I: HL -> program text
2b7e	CODE	Save pointer
2b7f	CODE	HL -> start of line buffer
2b82	CODE	BC -> start of line buffer
2b84	CODE	Restore pointer
2b85	CODE	D = counter (maximum length = 255 characters)
2b87	CODE	Continue at 2B8CH
2b89	CODE	; Decode next character
2b89	CODE	Pointer + 1
2b8a	CODE	Counter - 1 Maximum length reached ?
2b8b	CODE	Yes: done	 return
2b8c	CODE	; Decode line from (HL) onwards and store at (BC)
2b8c	CODE	A = next character
2b8d	CODE	End of line reached ?
2b8e	CODE	Pointer + 1
2b8f	CODE	First store character
2b90	CODE	Yes: done	 return Token found ?
2b91	CODE	No: continue at 3FD2H
2b94	CODE	"'" token found ? (REM)
2b96	CODE	No: continue at 2BA0H
2b98	CODE	Yes: delete last 4 characters
2b99	CODE	in line buffer because the
2b9a	CODE	apostroph is stored as
2b9b	CODE	'::REM'
2b9c	CODE	Counter + 1
2ba0	CODE	'ELSE' token found ?
2ba2	CODE	Yes: buffer pointer - 1 ('ELSE' is stored as ':ELSE')
2ba5	CODE	A = token value - 7FH
2ba7	CODE	Save pointer
2ba8	CODE	E = token value
2ba9	CODE	Colour-Token found ? HL -> start of corresponding keyword table
2bac	CODE	A = next character
2bad	CODE	Next keyword reached ?
2bae	CODE	Pointer + 1
2baf	CODE	No: increment HL to next keyword
2bb2	CODE	Token counter - 1
2bb3	CODE	Increment pointer further until right token is reached
2bb5	CODE	Clear bit 7
2bb7	CODE	Store character
2bb8	CODE	Buffer pointer + 1
2bb9	CODE	Counter - 1 Buffer full ?
2bba	CODE	Yes: done	 continue at 28D8H
2bbd	CODE	A = next character
2bbe	CODE	Table pointer + 1
2bbf	CODE	Next keyword reached ?
2bc0	CODE	No: store character in buffer
2bc3	CODE	Yes: restore line pointer
2bc4	CODE	Process next character
2bc6	CODE	; DELETE statement
*		; ----------------
2bc6	CODE	Get start and end LN
2bc9	CODE	DE = LN of end line
2bca	CODE	Save pointer on start line
2bcb	CODE	twice
2bcc	CODE	Search end line Does it exist?
2bcf	CODE	No: ?FC Error Yes:
2bd1	CODE	DE = end line pointer
2bd3	CODE	Save pointer to end line HL = pointer to start line
2bd4	CODE	Save it
2bd5	CODE	Compare both pointer End >= start ?
2bd6	CODE	No: ?FC Error Yes:
2bd9	CODE	HL -> 'READY'
2bdc	CODE	Print text
2bdf	CODE	Restore pointer to start line
2be0	CODE	Set new RET address to 1AE8H
2be3	CODE	and restore end line pointer
2be4	CODE	; Delete line(s)
*		;
*		; I: BC -> start line
*		;    HL -> line following end line
2be4	CODE	DE -> line following end
2be5	CODE	HL -> end of program
2be8	CODE	Copy next line
2be9	CODE	onto line to be deleted
2bea	CODE	Pointer + 1
2beb	CODE	Pointer + 1
2bec	CODE	End of program reached ?
2bed	CODE	No: continue copying Yes:
2bef	CODE	HL = new end address
2bf0	CODE	of program
2bf1	CODE	Save it
2bf5	CODE	; CSAVE statement
*		; ---------------
2bf5	CODE	Get filename
2bf8	CODE	Save PTP
2bf9	CODE	DE -> filename
2bfc	CODE	Save registers
2c00	CODE	Write leader and sync
2c03	CODE	Restore registers
2c07	CODE	A = filename character
2c08	CODE	Write to cassette
2c0b	CODE	HL -> start of program
2c0e	CODE	DE = HL
2c0f	CODE	HL -> end of program
2c12	CODE	A = byte from program text
2c13	CODE	Program pointer + 1
2c14	CODE	Write program byte to cassette
2c17	CODE	End of program reached ?
2c18	CODE	No	 write next byte
2c1a	CODE	--
2c1d	CODE	Restore PTP
2c1f	CODE	; CLOAD statement
*		; ---------------
2c1f	CODE	--
2c27	CODE	A = 00H
2c28	CODE	--
2c29	ENTRY	; Entry for VERIFY
2c29	ENTRY	A <> 00H
2c2a	ENTRY	PTP + 1
2c2b	CODE	Save flag
2c2c	CODE	PTP - 1
2c2d	CODE	Filename indicated ?
2c2e	CODE	A = default filename
2c30	CODE	No: continue at 2C39H Yes:
2c32	CODE	Put filename
2c35	CODE	into A
2c39	CODE	L = filename
2c3a	CODE	Restore flag
2c3b	CODE	CLOAD ?
2c3c	CODE	H = flag
2c3d	CODE	Save flag and filename
2c40	CODE	Yes: NEW
2c43	CODE	Restore flag and filename
2c46	CODE	D = flag	 E = filename
2c47	CODE	Save registers
2c4b	CODE	Search for leader and sync
2c4e	CODE	Restore registers
2c52	CODE	Get filename char from tape
2c55	CODE	Filename indicated ?
2c57	CODE	No: continue at 2C5CH
2c59	CODE	Specified filename found ?
2c5a	CODE	No: search for next file
2c5c	CODE	HL = program start address
2c5f	CODE	B = counter ( 3 times 00H indicates program end)
2c61	CODE	Read 1 byte
2c64	CODE	E = byte
2c65	CODE	Does memory also contain this byte ? Yes: A = 00H
2c66	CODE	AND it with flag A = 00H if CLOAD or VERIFY is ok. A <> 00H if VERIFY is bad. Bad VERIFY ?
2c67	CODE	Yes: continue at 2C8AH
2c69	CODE	Store byte
2c6a	CODE	Check free memory remaining.
2c6d	CODE	Byte read = 00H ?
2c6f	CODE	Pointer + 1
2c70	CODE	No: next byte Yes:
2c72	CODE	Blink '*'
2c75	CODE	Counter - 1	 read next byte
2c77	CODE	Store new end of program
2c7a	CODE	HL -> 'READY'
2c7d	CODE	Print text
2c80	CODE	--
2c83	CODE	Reset PTP to start of BASIC program
2c86	CODE	Save PTP
2c87	CODE	Renew all pointers in program text	 active command mode
2c8a	CODE	; Error at VERIFY
2c8a	CODE	HL -> 'BAD'
2c8d	CODE	Print text and give tone
2c90	CODE	Back to active command mode
2c93	CODE	; Filename not found
2c93	CODE	Print actual filename found
2c96	CODE	Seach for end of program (3 times 00H)
2c98	CODE	Read byte
2c9b	CODE	00H found ?
2c9c	CODE	No: next byte
2c9e	CODE	Counter - 1: read next byte
2ca0	CODE	--
2ca3	CODE	Retry CLOAD
2ca5	CODE	; Text 'BAD'
2ca9	BYTES	End of text
2caa	CODE	; X = PEEK ( X )
*		; --------------
2caa	CODE	HL = X = CINT (X) = address
2cad	CODE	A = memory value
2cae	CODE	Save A to X as INT
2cb1	CODE	; POKE statement
*		; --------------
2cb1	CODE	DE = address
2cb4	CODE	Save address
2cb5	CODE	Next byte must be
2cb6	ASCII	a comma
2cb7	CODE	Get poke value
2cba	CODE	Get address
2cbb	CODE	Store value in memory
2cbd	CODE	; PRINT USING
*		; -----------
2cbd	CODE	Get format string
2cc0	CODE	?TM Error if no string found
2cc3	CODE	Next character must
2cc4	ASCII	be ';'
2cc5	CODE	DE = PTP
2cc6	CODE	HL -> string vector
2cc9	CODE	Continue at 2CD3H
2ccb	CODE	; Re-entry in case multiple nuerical values have to be printed using the same
*		; format string
2ccb	CODE	A = character following separator
2cce	CODE	Separator followed by a variable ?
2ccf	CODE	No: ?FC Error Yes:
2cd1	CODE	Restore vector address of format string
2cd2	CODE	HL -> vector	 DE = PTP
2cd3	CODE	; Execute PRINT USING
*		;
*		; I: DE =  PTP on variable to be printed
*		;    HL -> format string vector
2cd3	CODE	Save vector address
2cd4	CODE	A = 0
2cd5	CODE	Clear character
2cd8	CODE	C-flag = 1	 Z-flag = 0
2cd9	CODE	Save AF
2cda	CODE	Save PTP
2cdb	CODE	B = format string length
2cdc	CODE	Null string ?
2cdd	CODE	Yes: ?FC Error No:
2ce0	CODE	Vector address + 1
2ce1	CODE	HL = string pointer
2ce5	CODE	Continue at 2D03H
2ce7	CODE	; '%' found
*		;
*		; I: B  = remaining string length
*		;    HL = pointer on string (on next character following '%')
*		; O: C  = number of spaces + 2 found between both '%' characters
2ce7	CODE	Save counter
2ce8	CODE	Save pointer
2ce9	CODE	C = counter for spaces (2 for the 2 '%' delimiters)
2ceb	CODE	Get next character
2cec	CODE	Pointer + 1
2ced	CODE	2nd '%' found ?
2cef	CODE	Yes: done	 continue at 2E17H No:
2cf2	CODE	Space?
2cf4	CODE	No: use '%' as text character (only spaces are allowed between '%' delimiters)
2cf6	CODE	Counter + 1
2cf7	CODE	Get next character
2cf9	CODE	Restore string pointer in case no 2nd '%' was found
2cfa	CODE	Restore previous counter value
2cfb	CODE	and use '%' as text character
2cfd	CODE	; The character found is not a formatting character but a part of a text to be
*		; printed
2cfd	CODE	If D <> 0 then print '+'
2d00	CODE	Print character
2d03	CODE	; Process format string
*		;
*		; I: (SP - 4) -> format string vector
*		;    (SP - 2) =  AF (A = 00H	 C-flag = 1	 Z-flag = 0. see 2CD9H)
*		;    (SP)     =  PTP
*		;     B       =  string length (remaining length)
*		;     HL      =  string pointer
2d03	CODE	A = 00H
2d04	CODE	E = number of positions before the decimal point = 0
2d05	CODE	Format byte = 0 (For composition of format byte see 0FBEH)
2d06	CODE	If D <> 0 then print '+'
2d09	CODE	D = format byte
2d0a	CODE	Get next character
2d0b	CODE	Pointer + 1
2d0c	CODE	'!' found ?
2d0e	CODE	Yes: continue at 2E14H
2d11	CODE	'#' found ?
2d13	CODE	Yes: continue at 2D4CH
2d15	CODE	Counter - 1 String end reached ?
2d16	CODE	Yes: continue at 2DFEH
2d19	CODE	'+' found ?
2d1b	CODE	Set bit 3 of format byte
2d1d	CODE	Yes: continue at 2D06H
2d1f	CODE	Pointer - 1
2d20	CODE	Get character again
2d21	CODE	Pointer + 1
2d22	CODE	'.' found ?
2d24	CODE	Yes: continue at 2D66H
2d26	CODE	'%' found ?
2d28	CODE	Yes: continue at 2CE7H
2d2a	CODE	Same character twice ?
2d2b	CODE	No: character not recognized Yes:
2d2d	CODE	'$$' found ?
2d2f	CODE	Yes: continue at 2D45H
2d31	CODE	'**' found ?
2d33	CODE	No: character not recognized
2d35	CODE	; '**' found
2d35	CODE	A = remaining length
2d36	CODE	Less than 2 bytes remaining?
2d38	CODE	Pointer + 1
2d39	CODE	Yes: continue at 2D3EH
2d3b	CODE	Get next character
2d3c	CODE	Is it a '$' ?
2d3e	CODE	Set bit 5 (for '*' output)
2d40	CODE	No: only '**' found Yes:
2d42	CODE	'**$' found	 counter - 1
2d43	CODE	Positions before decimal point + 1
2d44	CODE	--
2d45	ENTRY	; '$$' found
2d45	CODE	A = 0
2d46	CODE	Set bit 4 ('$' in front)
2d48	CODE	Pointer + 1
2d49	CODE	Positions before decimal point + 1
2d4a	CODE	update A with format byte
2d4b	CODE	D = format byte
2d4c	CODE	; '#' found
2d4c	CODE	Positions before decimal point + 1
2d4d	CODE	Clear counter for text output
2d4f	CODE	String counter - 1 Last character ?
2d50	CODE	Yes: continue at 2D99H
2d52	CODE	Get next character
2d53	CODE	Pointer + 1
2d54	CODE	Decimal point found ?
2d56	CODE	Yes: continue at 2D70H
2d58	CODE	'#' found ?
2d5a	CODE	Yes: back to 2D4CH
2d5c	CODE	'	' found ?
2d5e	CODE	No: continue at 2D7AH
2d60	CODE	; '.' found
2d60	CODE	Set bit 6 of format byte
2d63	CODE	D = format byte
2d64	CODE	Get next character
2d66	CODE	; '.' in front of '#' found
2d66	CODE	A = next character
2d67	CODE	Next character a '#' ?
2d69	CODE	A = '.'
2d6b	CODE	No: use '.' as text character Yes:
2d6d	CODE	Set counter for positions behind the decimal point to 1
2d6f	CODE	Pointer + 1
2d70	CODE	; '.' behind '#' found
2d70	CODE	Positions behind decimal point + 1
2d71	CODE	Counter - 1 String end ?
2d72	CODE	Yes: continue at 2D99H
2d74	CODE	Get next character
2d75	CODE	Pointer + 1
2d76	CODE	'#' ?
2d78	CODE	Yes: Positions behind decimal point + 1
2d7a	CODE	; Exponential format specified ?
*		; (4 consecutive times arrow up)
2d7a	CODE	Save format byte and counter
2d7b	CODE	Set new RET address
2d7e	CODE	to 2D97H
2d7f	CODE	DE = string pointer
2d81	CODE	Arrow up found ?
2d83	CODE	No: RET to 2D79H
2d84	CODE	2 times arrow up ?
2d85	CODE	No: RET to 2D79H
2d86	CODE	Pointer + 1
2d87	CODE	3 times arrow up ?
2d88	CODE	No: RET to 2D79H
2d89	CODE	Pointer + 1
2d8a	CODE	4 times arrow up ?
2d8b	CODE	No: RET to 2D79H
2d8c	CODE	Pointer + 1
2d8d	CODE	A = string counter
2d8e	CODE	Subtract 4	 overflow ?
2d90	CODE	Yes: the 4 arrow ups are not all part of the format string
2d91	CODE	; 4 consecutive arrow ups found: print number in exponential format
2d91	CODE	Remove RET address (2D97H)
2d92	CODE	Restore format byte and number of positions before the decimal point
2d93	CODE	B = string counter
2d94	CODE	Set bit 0 (exponential format)
2d95	CODE	Pointer + 1
2d96	CODE	Jump is never executed because Z-flag <> 0 (because of 2D94H)
2d97	ENTRY	; No exponential format output
2d97	ENTRY	HL = old string pointer
2d98	ENTRY	Restore format byte and number positions before decimal point
2d99	CODE	; Last string character was '.' or '#'
2d99	CODE	A = format byte
2d9a	CODE	Pointer - 1
2d9b	CODE	Positions before decimal point + 1
2d9c	CODE	Print positive sign ?
2d9e	CODE	Yes: continue at 2DB5H No:
2da0	CODE	Positions before decimal point - 1
2da1	CODE	Any string characters left ?
2da3	CODE	No: continue at 2DB5H
2da5	CODE	A = next character
2da6	CODE	'-' found ?
2da8	CODE	Yes: continue at 2DB0H
2daa	CODE	'+' found ?
2dac	CODE	No: continue at 2DB5H
2dae	CODE	Set bit 3 (print sign)
2db0	CODE	Set bit 2 (behind number)
2db2	CODE	Update with format byte
2db3	CODE	D = format byte
2db4	CODE	String counter - 1
2db5	CODE	; Processing of format string ready
*		;
*		; I: B = string counter
*		;    C = number of positions behind decimal point + 1 (for decimal point)
*		;    D = format byte
*		;    E = number of positions in front of decimal point
2db5	CODE	Restore PTP
2db6	CODE	Restore flags (see 2CD9H)
2db7	CODE	Done when Z-flag = 0
2db9	CODE	Save registers
2dbb	CODE	Get value to be printed
2dbe	CODE	Restore registers
2dc0	CODE	Save string counter
2dc1	CODE	Save PTP
2dc2	CODE	B = number of positions in front of decimal point
2dc3	CODE	A = B
2dc4	CODE	Add number of positions behind the decimal point
2dc5	CODE	More than 24 positions ?
2dc7	CODE	Yes: ?FC Error	 the maximum number of positions is 24 ( 1 for sign	  17 for DBL format   1 for decimal point   4 for exponent   1 for sign following number)
2dca	CODE	A = format byte
2dcb	CODE	Execute formatting (bit 7 set ?)
2dcd	CODE	Store number in X as formatted string at 4130H. HL -> string
2dd0	CODE	Print string
2dd3	CODE	Restore PTP
2dd4	CODE	Adjust PTP
2dd5	CODE	Get next character
2dd6	CODE	C-flag = 1 End of assignment reached ?
2dd7	CODE	Yes: continue at 2DE6H
2dd9	CODE	Store next character (see 2CCBH)
2ddc	CODE	';' found ?
2dde	CODE	Yes: character ok
2de0	CODE	'	' found ?
2de2	CODE	No: ?SN Error
2de5	CODE	Adjust PTP
2de6	CODE	Restore string counter
2de7	CODE	DE = PTP
2de8	CODE	HL -> format string vector
2de9	CODE	Save vector address
2dea	CODE	Save next character
2deb	CODE	Save PTP
2dec	CODE	A = format string length
2ded	CODE	Subtract remaining length
2dee	CODE	Vector address + 1
2def	CODE	HL -> format string
2df3	CODE	DE = offset for next format
2df5	CODE	string (format character for next value to print)
2df6	CODE	Add offset. HL now points to next format indication
2df7	CODE	A = remaining length
2df8	CODE	Length = 0 ?
2df9	CODE	No: process format string from (HL) onwards
2dfc	CODE	Yes: use old format string also for the next value
2dfe	CODE	; End of string found
2dfe	CODE	If D <> 0 then print '+'
2e01	CODE	Print last character
2e04	CODE	Restore PTP
2e05	CODE	Restore flags/next character (see 2DEAH)
2e06	CODE	Process next number with same format string
2e09	CODE	End PRINT if end of assigment is reached (see 2DD6H)
2e0c	CODE	Save PTP	 restore vector address
2e0d	CODE	Remove format string from string table and string space
2e10	CODE	Restore PTP
2e11	CODE	Output back to screen
2e14	CODE	; '!' found
2e14	CODE	Print 1 text character
2e16	CODE	--
2e17	ENTRY	; 2nd '%' character found
*		; C = number of characters to be printed
2e17	ENTRY	Remove string pointer from stack
2e18	CODE	Counter - 1
2e19	CODE	If D <> 0 then print '+'
2e1c	CODE	Restore PTP
2e1d	CODE	Restore flags: done ?
2e1e	CODE	Yes: end PRINT operation No:
2e20	CODE	Save string counter
2e21	CODE	Get string to be printed
2e24	CODE	?TM Error if not a string
2e27	CODE	Restore string counter
2e28	CODE	Save string counter
2e29	CODE	Save PTP
2e2a	CODE	HL -> vector of string to be printed
2e2d	CODE	B = number of characters to be printed
2e2e	CODE	C = 0: ouput is started at start of string
2e30	CODE	Save counters
2e31	CODE	Get characters to be printed via LEFT$
2e34	CODE	Print characters
2e37	CODE	HL -> vector of printed string
2e3a	CODE	A = number of printed chars
2e3b	CODE	- total string length
2e3c	CODE	B = remaining string length
2e3d	CODE	A = space
2e3f	CODE	Counter + 1
2e40	CODE	Counter reached 0 ?
2e41	CODE	Yes: process next argument No:
2e44	CODE	Replace missing characters by spaces
2e47	CODE	next character
2e49	CODE	; If D <> 0 then print '+'
2e49	CODE	Save AF
2e4a	CODE	D <> 0 ?
2e4c	CODE	A = '+'
2e4e	CODE	Yes: print '+'
2e51	CODE	Restore AF
2e53	CODE	; Entry for EDIT after ?SN Error
2e53	CODE	Clear last error code
2e56	CODE	HL = ERL
2e59	CODE	ERL = 65535 ?
2e5a	CODE	(Syntax error in active
2e5b	CODE	command mmode)
2e5c	CODE	DE = ERL
2e5d	CODE	Yes: no EDIT has to be done No:
2e5e	CODE	Call EDIT with LN = DE
2e60	CODE	; EDIT statement
*		; --------------
2e60	CODE	Load line number into DE
2e63	CODE	?SN Error ?
2e64	CODE	Remove RET address from stack
2e65	CODE	HL = line number
2e66	CODE	Save as '.'
2e69	CODE	DE = line number
2e6a	CODE	Search for line DE
2e6d	CODE	?UL Error in case the line does not exist
2e70	CODE	HL = line pointer
2e72	CODE	HL + 2
2e73	CODE	BC = line number
2e78	CODE	Save LN
2e79	CODE	Decode line from (HL) onwards and store in line buffer
2e7c	CODE	Restore LN
2e7d	CODE	And save it again
2e7e	CODE	Print HL as decimal number
2e81	CODE	A = ' '
2e83	CODE	Print it
2e86	CODE	HL -> line buffer
2e89	CODE	Cursor on
2e8e	CODE	Save pointer
2e8f	CODE	C = counter (set to -1 because of following INC C)
2e91	CODE	Counter + 1
2e92	CODE	A = next characater
2e93	CODE	End of line reached
2e94	CODE	Pointer + 1
2e95	CODE	No: continue counting Yes:
2e97	CODE	Restore pointer
2e98	CODE	B = 00H (number of already printed characaters) C = length of line
2e99	CODE	D = 0 (repetition counter)
2e9b	CODE	Get character from keyboard
2e9e	CODE	Can is be a digit ?
2ea0	CODE	No: continue at 2EB0H Yes:
2ea2	CODE	Digit ?
2ea4	CODE	No: continue at 2EB0H Yes:
2ea6	CODE	E = number value (00H-09H)
2ea7	CODE	A = last value
2ea8	CODE	*2
2ea9	CODE	*2 (*4 in total)
2eaa	CODE	+value (*5 in total)
2eab	CODE	*2 (*10 in total)
2eac	CODE	Add next decimal position
2ead	CODE	D = counter
2eae	CODE	Get next character
2eb0	CODE	; No digit entered
*		; D = repetition counter
*		; A = ASCII code of entered character - 30H (!)
2eb0	CODE	Save pointer
2eb1	CODE	Set new RET address
2eb4	CODE	to 2E99H and restore pointer
2eb5	CODE	Repetition required ?
2eb6	CODE	Is D <> 0 ?
2eb7	CODE	Yes: leave D as it is No:
2eba	CODE	Set D to 1 (execute required function at least once)
2ebb	CODE	08H = Backspace ?
2ebd	CODE	Yes: continue at 2FD2H
2ec0	CODE	0DH = RETURN ?
2ec2	CODE	Yes: continue at 2FE0H
2ec5	CODE	20H = space ?
2ec7	CODE	Yes: continue at 2F0AH
2ec9	CODE	Lower case (char > 60H) ?
2ecb	CODE	No: character ok. Yes:
2ecd	CODE	Convert to upper case
2ecf	CODE	51H = 'Q' ?
2ed1	CODE	Yes: continue at 2FF6H
2ed4	CODE	4CH = 'L' ?
2ed6	CODE	Yes: continue at 2F40H
2ed9	CODE	53H = 'S' ?
2edb	CODE	Yes: continue at 2F1CH
2edd	CODE	49H = 'I' ?
2edf	CODE	Yes: continue at 2F7DH
2ee2	CODE	44H = 'D' ?
2ee4	CODE	Yes: continue at 2F4AH
2ee7	CODE	43H = 'C' ?
2ee9	CODE	Yes: continue at 2F65H
2eec	CODE	45H = 'E' ?
2eee	CODE	Yes: continue at 2FE3H
2ef1	CODE	58H = 'X' ?
2ef3	CODE	Yes: continue at 2F78H
2ef6	CODE	4BH = 'K' ?
2ef8	CODE	Yes: continue at 2F16H
2efa	CODE	48H = 'H' ?
2efc	CODE	Yes: continue at 2F75H
2eff	CODE	41H = 'A' ?
2f01	CODE	No: back to 2E99H
2f02	CODE	; 'A': start again
2f02	CODE	Remove RET address
2f03	CODE	Restore LN
2f04	CODE	Start new line on screen
2f07	CODE	Restart EDIT
2f0a	CODE	; Space bar: print next character
2f0a	CODE	Get next character
2f0b	CODE	End of line reached ?
2f0c	CODE	Yes: done	 return
2f0d	CODE	Counter + 1
2f0e	CODE	Print character
2f11	CODE	Pointer + 1
2f12	CODE	Repeat ?
2f13	CODE	Yes: next character
2f16	CODE	; 'K': delete line up to character entered
2f16	CODE	Save pointer
2f17	CODE	Set new RET address to 2F5FH (to print '!' at the end)
2f1a	CODE	Restore pointer
2f1b	CODE	C-flag = 0 (indicator for delete character)
2f1c	CODE	; 'S': search for character entered
2f1c	CODE	Save flags
2f1d	CODE	Get character
2f20	CODE	E = character
2f21	CODE	Restore flags
2f22	CODE	And save them again
2f23	CODE	Print '!' for 'K' operation
2f26	CODE	A = next character
2f27	CODE	End of line reached ?
2f28	CODE	Yes: done. No:
2f2b	CODE	Print character
2f2e	CODE	Restore flags
2f2f	CODE	And save them again 'K' operation ?
2f30	CODE	Yes: Delete character
2f33	CODE	Yes: Skip next operation (counter and pointer are adjusted at 2FA1H)
2f35	CODE	Pointer + 1
2f36	CODE	Counter + 1
2f37	CODE	A = next character
2f38	CODE	= searched character ?
2f39	CODE	No: next character Yes:
2f3b	CODE	Repeat done ?
2f3c	CODE	No: next character Yes:
2f3e	CODE	Restore flags
2f40	CODE	; 'L': list line and start again
2f40	CODE	Print line
2f43	CODE	Start new line on screen
2f46	CODE	Remove RET address
2f47	CODE	Restart EDIT
2f4a	CODE	; 'D': Delete character
2f4a	CODE	A = character
2f4b	CODE	End of line reached?
2f4c	CODE	Yes: done	 return. No:
2f4d	CODE	A = '!'
2f4f	CODE	Print it
2f52	CODE	A = character
2f53	CODE	End of line ?
2f54	CODE	Yes: done. No:
2f56	CODE	Print character
2f59	CODE	and delete
2f5c	CODE	Repeat ?
2f5d	CODE	Yes: next character
2f5f	CODE	; Print '!'
2f5f	CODE	A = '!'
2f61	CODE	Print it
2f65	CODE	; 'C': change character
2f65	CODE	A = character
2f66	CODE	End of line reached ?
2f67	CODE	Yes : done	 return.
2f68	CODE	Get new character
2f6b	CODE	Use it
2f6c	CODE	And print it
2f6f	CODE	Pointer + 1
2f70	CODE	Counter + 1
2f71	CODE	Repeat ?
2f72	CODE	Yes: next character No:
2f74	CODE	Done.
2f75	CODE	; 'H': Hack off rest of the line and jump to 'I'
2f75	CODE	Set end of line at current position
2f77	CODE	C = number of already printed characters = new line length
2f78	CODE	; 'X': print rest of the line and jump to 'I'
2f78	CODE	Execute 255 times the space
2f7a	CODE	bar function to print the remaining part of the line
2f7d	CODE	; 'I': insert new characters
2f7d	CODE	Get new character
2f80	CODE	(why ?)
2f81	CODE	(see 0384H)
2f84	CODE	Arrow left ?
2f86	CODE	Yes: delete character
2f88	CODE	RETURN ?
2f8a	CODE	Yes: execute RETURN function
2f8d	CODE	SHIFT+arrow up ? (End I-func)
2f8f	CODE	Yes: done	 return No:
2f90	CODE	Insert character
2f92	CODE	; Arrow left: Delete character in I-function
2f92	CODE	A = ASCII code of delete character = backspace
2f94	CODE	Any character already printed?
2f95	CODE	(is there anything to delete)
2f96	CODE	No: done Yes:
2f98	CODE	Delete character from screen
2f9b	CODE	Pointer - 1
2f9c	CODE	Counter - 1
2f9d	CODE	Set new RET address
2fa0	CODE	to 2F7DH
2fa1	CODE	; Delete character at (HL)
2fa1	CODE	Save pointer
2fa2	CODE	Length of line - 1
2fa3	CODE	Get character
2fa4	CODE	End of line reached ?
2fa5	CODE	C-flag = 1
2fa6	CODE	Yes: restore pointer and done No:
2fa9	CODE	Pointer + 1
2faa	CODE	Get next character
2fab	CODE	pointer - 1
2fac	CODE	And store at current position
2fad	CODE	Pointer + 1
2fae	CODE	Shift line until end of line is reached
2fb0	CODE	; Insert character  at (HL)
2fb0	CODE	Save character
2fb1	CODE	A = length of line
2fb2	CODE	Maximum length reached ?
2fb4	CODE	No: insert character Yes:
2fb6	CODE	restore character
2fb7	CODE	Back to the 'I'-function
2fb9	CODE	; Insert character
2fb9	CODE	A = length of line - number of characters already printed = remaining length
2fba	CODE	Length of line + 1
2fbb	CODE	Printed characters + 1
2fbc	CODE	Save counter
2fbd	CODE	DE = pointer
2fbe	CODE	HL = remaining length
2fc1	CODE	HL = current length + remaining length = pointer to the end of line
2fc2	CODE	BC = end pointer
2fc4	CODE	HL = end pointer + 1
2fc5	CODE	Shift line
2fc8	CODE	Restore counter
2fc9	CODE	Restore character
2fca	CODE	Insert character
2fcb	CODE	Print character
2fce	CODE	ointer + 1
2fcf	CODE	Back to the 'I'-function
2fd2	CODE	; Arrow left: delete character left from cursor
2fd2	CODE	A = number of printed characters (+ number of characters left from cursor)
2fd3	CODE	Anything printed ?
2fd4	CODE	No: done	 return Yes:
2fd5	CODE	Counter - 1
2fd6	CODE	Pointer - 1
2fd7	CODE	Delete character
2fd9	CODE	on screen
2fdc	CODE	Repeat ?
2fdd	CODE	Yes: next character
2fe0	CODE	; RETURN: Print remaining part of line and end EDIT
2fe0	CODE	Print remaining line
2fe3	CODE	; 'E': end EDIT
2fe3	CODE	Start new line on screen
2fe6	CODE	Remove RET address
2fe7	CODE	Restore LN
2fe8	CODE	LN = 65535 ?
2fe9	CODE	(set Z-flag for 2FEFH
2fea	CODE	see 1A71H)
2feb	CODE	HL = line buffer address
2fee	CODE	Pointer - 1 LN = 65535 ?
2fef	CODE	Yes: done	 return
2ff0	CODE	C-flag = 1
2ff1	CODE	Pointer + 1
2ff2	CODE	Save flags
2ff3	CODE	Insert line at HL into program text
2ff6	CODE	; 'Q': terminate edit	 ignore changes
2ff6	CODE	Restore RET address
2ff7	CODE	Restore LN
2ff8	CODE	Back to active command mode
2ffb	CODE	--
3000	CODE	; Keyboard input with FKEY evaluation
*		; (Is only used by line input (at 05D9H) and has
*		; therefor 05E3H as return address!!
3000	CODE	Continue at 3415H
3003	CODE	; No Function Key pressed (start of 3458H)
*		; CTRL + number 1 to 8 pressed for colour change ?
3003	CODE	Save pointer
3004	CODE	HL = CTRL byte
3007	CODE	CTRL pressed ?
3009	CODE	No: done Yes:
300b	CODE	Clear bit
300d	CODE	A number pressed ?
300f	CODE	No: put character in A
3011	CODE	Valid number ?
3013	CODE	No: done Yes:
3015	CODE	A = Colour code 0 to 7
3017	CODE	Store new colour code and cursor on
301a	CODE	Restore pointer
301b	CODE	Get new character
301d	CODE	; Give character in A to input routine
301d	CODE	Restore pointer
301e	CODE	Return to line input routine
3021	CODE	--
3022	CODE	; Graphic character (> 7FH) recognized
3022	CODE	This comparison was used in a previous version to output the characters 192-255 (C0H-FFH) as tab-function. (output of 0 to 63 spaces) In the current version all values > 7FH are printed as graphic characters.
3024	CODE	Print character
3027	CODE	; Previously used Tab-function (not used)
3027	CODE	A = value - 192 (= number of spaces to print)
3029	CODE	A = 0: done
302c	CODE	B = counter
302d	CODE	A = space
302f	CODE	Save counter
3030	CODE	Print character
3033	CODE	Restore counter
3034	CODE	Next character
3039	CODE	; Move cursor one position to the right (= CHR$(25) )
3039	CODE	Cursor address + 1
303a	CODE	Save cursor address
303b	CODE	HL -> actual line
303e	CODE	DE = HL
303f	CODE	Restore cursor address
3040	CODE	Next line reached ?
3041	CODE	No: done Yes:
3042	CODE	DE = -40
3045	CODE	Subtract 40 (length of 1 line) from new address. The cursor is located at the start of line again
3047	CODE	; This routine loads the CRTC register pair A and A + 1 with HL:
*		; 16 bit load for CRTC register
*		;
*		; I: A = register number of lower register of register pair
*		;    HL = value to be written into CRTC
3047	CODE	Save BC
3048	CODE	Save HL
3049	CODE	Counter = 2
304b	CODE	C = CRTC select register
304d	CODE	Select register A
304f	CODE	C = CRTC data register
3050	CODE	Write data to CRTC register
3052	CODE	Next register
3053	CODE	H = L
3054	CODE	Loop
3056	CODE	Restore HL
3057	CODE	Restore BC
3059	CODE	; Cursor off (= CHR$(15) )
3059	CODE	Save address
305a	CODE	Set H and L for CRTC programming
305d	CODE	Continue at 3063H
305f	CODE	; Cursor on (= CHR$(14) )
305f	CODE	Save address
3060	CODE	H and L = value for CRTC programming
3063	CODE	Select CRTC registers 10+11
3065	CODE	Write HL into CRTC
3068	CODE	A = cursor start scan line
3069	CODE	Restore address
306a	CODE	Save registers
306c	CODE	Cursor off ?
306e	CODE	No: set colour of new cursor
3071	CODE	--
3072	CODE	Select CRTC registers 14+15 (Cursor position)
3074	CODE	Write address into CRTC
3077	CODE	Restore registers
307a	CODE	; Save registers and set colour
*		;
*		; I: A = character at (HL)
*		;    HL -> screen location in LGR screen memory
307a	CODE	Save registers
307d	CODE	Continue at 35F8H
3080	CODE	; This routine updates the colour memory at position HL + DE with the current
*		; text colour set (see 35F8H)
*		;
*		; I: HL + DE -> Colour memory byte to be updated
*		; O: -
3080	CODE	Set pointer into colour mem.
3081	CODE	Save colour memory pointer
3082	CODE	HL -> colour codes table
3085	CODE	DE = offset = 0;
3088	CODE	Take current colour value
308b	CODE	Use it as offset in table
308c	CODE	Set pointer into table
308d	CODE	A = colour code
308e	CODE	Restore colour memory pointer
308f	CODE	Write value into colour mem.
3090	CODE	Restore registers
3094	BYTES	--
309d	CODE	; Calculate new POS value (AF)
*		;
*		; I: --
*		; O: A = new POS value
309d	CODE	Save registers
30a0	CODE	HL = new cursor address
30a3	CODE	Save address
30a4	CODE	Calculate start of line
30a7	CODE	DE -> start of line
30a8	CODE	HL = cursor address
30a9	CODE	C-flag = 0
30aa	CODE	HL = cursor address - start of line = cursor position inside line
30ac	CODE	A = POS value
30ad	CODE	Restore registers
30b1	CODE	; Test TAB value
30b1	CODE	A = TAB value
30b2	CODE	E = TAB value
30b3	CODE	A = output flag
30b6	CODE	Test output flag Cassette output ?
30b7	CODE	Yes: ?FC Error Screen output ?
30ba	CODE	Yes: continue at 30C1H Printer output:
30bc	CODE	A = highest possible TAB value.
30bf	CODE	Continue at 30C4H
30c1	CODE	; Screen output
30c1	CODE	A = number of characters per line
30c4	CODE	Desired TAB value bigger as length of line ?
30c5	CODE	No: value ok Yes:
30c7	CODE	Save BC
30c8	CODE	Exchange A and E
30cb	CODE	Restore BC
30cc	CODE	Subtract line length
30cd	CODE	Continue when > 0
30cf	CODE	Undo last subtract
30d0	CODE	E = new TAB value (never bigger than length of line)
30d2	CODE	; TAB value is ok.
30d2	CODE	Put value in A
30d4	CODE	; SUB for PRINT@ (see 207AH)
*		;
*		; I: DE = @ argument
30d4	CODE	HL = 999
30d7	CODE	@ value > 999 ?
30d8	CODE	Restore PTP
30d9	CODE	Yes: ?FC Error No:
30dc	CODE	Done
30df	CODE	; Calculate new POS value (as 309DH but with value in E and A)
30df	CODE	Calculate POS
30e2	CODE	Put result also in E
30e4	CODE	; Screen routine (called via DCB call)
*		;
*		; I: IX -> Screen DCB (= 401DH)
*		;    C = character to be written
30e4	CODE	HL = actual cursor address
30e7	CODE	(from DCB) False DCB type ?
30ea	CODE	Yes: continue at 317DH No:
30ed	CODE	Cursor is on ?
30f1	CODE	Yes: continue at 30F8H No:
30f3	CODE	Cursor off
30f6	CODE	Continue at 30F8H
30f8	CODE	Cursor on
30fb	CODE	A = character to be output
30fc	CODE	Control character
30fe	CODE	Yes: continue at 3122H No:
3100	CODE	Graphic character ?
3102	CODE	Yes: continue at 3022H No:
3105	CODE	Output character
3108	CODE	A = character at new cursor position
3109	CODE	D = character
310a	CODE	Cursor is on ?
310e	CODE	No: continue at 3118H Yes:
3110	CODE	Store character
3113	CODE	Cursor on
3116	CODE	Continue at 311BH
3118	CODE	Cursor off
311b	CODE	Save new cursor address
3122	CODE	; Control character ( value < 32 ) recognized.
*		;
*		; I: A = control character
*		;    HL = cursor address
3122	CODE	Set return address
3125	CODE	to 3108H
3126	CODE	Backspace ?
3128	CODE	Yes: continue at 31DFH No:
312b	CODE	Code < 10 ?
312d	CODE	Yes: done
312e	CODE	Cursor on ?
3130	CODE	Jump when character < 0EH
3133	CODE	Yes: continue at 31F8H No:
3136	CODE	Cursor off ?
3138	CODE	Yes: continue at 31FDH
313b	CODE	Character < 24
313d	CODE	Yes: done
313e	CODE	Cursor left ?
3140	CODE	Yes: continue at 31E5H No:
3143	CODE	Cursor right ?
3145	CODE	Yes: continue at 3039H No:
3148	CODE	Cursor down ?
314a	CODE	Yes: continue at 3200H No:
314d	CODE	Cursor up ?
314f	CODE	Yes: continue at 3212H No:
3152	CODE	Cursor home ?
3154	CODE	Yes: continue at 31D4H No:
3157	CODE	Cursor to start of line ?
3159	CODE	Yes: continue at 31D9H No:
315c	CODE	CLear until end of line ?
315e	CODE	Yes: continue at 31BFH No:
3160	CODE	Clear until end of screen ?
3162	CODE	Yes: continue at 31A9H
3165	CODE	; Calculate start of line address of current line
*		;
*		; I: HL = current cursor address
*		; O: HL = address of start of line
3165	CODE	DE = -4400H
3168	CODE	Counter = 1
316a	CODE	HL = current @ value (= address - 4400H)
316b	CODE	DE = 40 (length of line)
316e	CODE	C-flag = 0
316f	CODE	Subtract 40
3171	CODE	Jump when < 0
3173	CODE	Counter + 1
3174	CODE	Again
3176	CODE	HL = 4400H - 28H
3179	CODE	Add length of 1 line
317a	CODE	Loop B times
317d	CODE	; False DCB type detected
317d	CODE	Cursor is on ?
3181	CODE	Yes: ok. No:
3182	CODE	A = character at next screen location
3184	CODE	; Print character on screen
*		;
*		; I: HL -> screen location
*		;    A = character
3184	CODE	Update character colour
3187	CODE	Put character in screen memory
3188	CODE	Next screen location
3189	CODE	DE -> last screen location on LGR screen + 1
318c	CODE	End of screen reached ?
318d	CODE	No: done
318e	CODE	HL = address of screen end
3191	CODE	DE = -40
3194	CODE	HL = HL - 40 = start of last line
3195	CODE	Save address
3196	CODE	Prepare registers
3199	CODE	Move character memory
319b	CODE	Switch registers
319c	CODE	Move colour memory
319e	CODE	Switch registers
319f	CODE	Done ?
31a1	CODE	No: move again
31a3	CODE	Switch registers
31a4	CODE	Restore second registerset
31a7	CODE	Switch registers
31a8	CODE	Restore start of last line
31a9	CODE	; Clear until end of screen (= CHR$(31) )
31a9	CODE	DE = highest LGR screen address + 1
31ac	CODE	Save cursor address
31ad	CODE	Clear character at cursor address and set colour
31b0	CODE	Next address
31b1	CODE	End reached ?
31b2	CODE	No: clear next
31b4	CODE	Restore cursor address
31b6	CODE	; RENUM statement
*		; ---------------
31b6	CODE	Save IY
31b8	CODE	Continue at 3222H
31ba	CODE	; Return from RENUM
31ba	CODE	Restore IY
31bc	CODE	Renew all pointers in BASIC program
31bf	CODE	; Clear until end of line (= CHR$(30) )
31bf	CODE	Save cursor address
31c0	CODE	Calculate start address of current line
31c3	CODE	result in DE	 HL = 40
31c4	CODE	HL = start address of next line
31c5	CODE	Result in DE
31c6	CODE	Restore cursor address
31c7	CODE	Continue at 31ACH
31c9	CODE	; Start new line (= CHR$(13) )
31c9	CODE	Clear current line
31cc	CODE	HL = start address next line
31cd	CODE	DE -> end of LGR screen + 1
31d0	CODE	End reached ?
31d1	CODE	Yes: scroll No:
31d3	CODE	done
31d4	CODE	; Move cursor home (= CHR$(28) )
31d4	CODE	HL -> start of screen memory = new cursor address
31d7	CODE	Set as new address
31d9	CODE	; Move cursor to start of line (= CHR$(29) )
31d9	CODE	Calculate start of line address
31dc	CODE	Program CRTC with new values
31df	CODE	; Backspace (= CHR$(8) )
31df	CODE	Cursor address - 1
31e0	CODE	A = space character
31e2	CODE	Continue at 35EEH
31e5	CODE	; Move cursor one position to the left (= CHR$(24) )
31e5	CODE	Save cursor address
31e6	CODE	Calculate start of line address
31e9	CODE	Put result in DE
31ea	CODE	Restore cursor address
31eb	CODE	Are we at start of line ?
31ec	CODE	Yes: add one line of characters for wrap around
31ee	CODE	Cursor address - 1
31ef	CODE	Set as new address
31f1	CODE	; Cursor to end of line
31f1	CODE	HL - 1
31f2	CODE	DE = characters per line
31f5	CODE	HL + 40
31f6	CODE	Continue at 31DCH
31f8	CODE	; Cursor on
31f8	CODE	A = character at cursor pos.
31f9	CODE	Store it in DCB
31fd	CODE	; Cursor off
31fd	CODE	A = 0
31fe	CODE	Continue at 31F9H
3200	CODE	; Move cursor one line down (= CHR$(26) )
3200	CODE	Set screen colour and DE = 40
3203	CODE	Set cursor address into next line
3204	CODE	Clear C-flag
3205	CODE	C-flag = 1
3206	CODE	DE = highest LGR screen address + 1
3209	CODE	Cursor now beyound LGR screen ?
320a	CODE	No: continue at 3210H Yes:
320c	CODE	DE = -960
320f	CODE	Add to cursor location to create wrap around to top line
3210	CODE	Continue at 31DCH
3212	CODE	; Move cursor one line up (= CHR$(27) )
3212	CODE	Set screen colour and DE = -40
3215	CODE	Set cursor address into previous line
3216	CODE	DE = lowest LGR screen address
3219	CODE	Cursor now before LGR screen ?
321a	CODE	No: continue at 3220H Yes:
321c	CODE	DE = 1000 (size of LGR screen)
321f	CODE	Add to cursor location to create a wrap around to bottom line
3220	CODE	Continue at 31DCH
3222	CODE	; RENUM entry from 31B8H
*		;
*		; I: HL = PTP
3222	CODE	PTP - 1
3223	CODE	Character indicated
3224	CODE	Yes: continue at 323FH
3226	CODE	Starting LN = 10
3229	CODE	Save it
322a	CODE	Continue at 323FH
322c	CODE	; Indicate starting line number and increment
322c	CODE	?FC Error when not a number
322f	CODE	DE = starting LN
3232	CODE	Next character must be
3233	ASCII	a comma
3234	CODE	?FC Error when comma is not followed by a number
3236	CODE	Save starting LN
3237	CODE	DE = increment
323a	CODE	Increment = 0 ?
323c	CODE	Yes: ?FC Error
323f	CODE	Store increment in system RAM
3244	CODE	Store starting LN in system RAM
3248	CODE	IY -> End of program
324c	CODE	DE = 256
324f	CODE	IY = IY + 256
3251	CODE	Save end of program address + 256
3253	CODE	HL -> start of program
3256	CODE	Save it
3257	CODE	; Build RENUM table
3257	CODE	End of program reached ?
3258	CODE	Pointer + 1
3259	CODE	Next line pointer = 0 ?
325a	CODE	Yes: continue at 32A6H
325c	CODE	Pointer + 2
325e	CODE	Search line for GOTO	 GOSUB etc.
3261	CODE	Pointer + 1
3262	CODE	Process next line when no keyword was found
3264	CODE	LN indicated? (in case of THEN or ELSE there can be either a command of a line number!)
3267	CODE	Pointer - 1
3268	CODE	No: continue search
326a	CODE	Pointer + 1
326b	CODE	Save program pointer
326c	CODE	Save table pointer
326d	CODE	Save end of program address
326f	CODE	and put it in DE
3270	CODE	HL = TOPMEM
3273	CODE	Subtract program end address Free memory space available ?
3275	CODE	No: ?OM Error Yes:
3278	CODE	Additional 4 bytes free ?
327d	CODE	No: ?OM Error Yes:
3280	CODE	Store number of digits of LN found
3283	CODE	Restore table pointer in HL
3284	CODE	DE = LN found
3287	CODE	Store LN
328d	CODE	And mark with 00H
3291	CODE	Increase IY by 4
3294	CODE	Restore program pointer
3295	CODE	Program pointer - 1
3296	CODE	Program pointer + 1
3297	CODE	A = next character
3298	CODE	Space found ?
329a	CODE	Yes: get next character
329c	CODE	Comma found ? (with ON GOTO or ON GOSUB)
329e	CODE	Yes: continue ar 32A3H
32a0	CODE	Program pointer - 1
32a1	CODE	Continue searching line
32a3	CODE	Program pointer + 1
32a4	CODE	Serach next LN
32a6	CODE	; RENUM table completed
*		; Now use the new line numbers from the table
32a6	CODE	Table end
32aa	CODE	Restore program start
32ab	CODE	Restore table start
32ad	CODE	DE = starting LN
32b1	CODE	Save new LN
32b2	CODE	Save table start
32b4	CODE	Save program start
32b5	CODE	Save starting LN
32b6	CODE	BCDE = (HL): DE = pointer to next line	 BC = line number
32b9	CODE	Program end reached ?
32bb	CODE	Yes: continue at 32FEH
32bd	CODE	HL -> next line
32be	CODE	Restore new LN
32bf	CODE	Save table pointer
32c1	CODE	Table end reached ?
32c4	CODE	(FFH + 1 = 00H)
32c5	CODE	Yes: continue at 32E8H
32c7	CODE	A = table marker
32ca	CODE	Marker <> 0 ?
32cb	CODE	Yes: this entry has already the new line number
32cd	CODE	No: Is the current line number
32d0	CODE	already in the table ?
32d7	CODE	No: check next entry Yes:
32d9	CODE	Insert new line number in
32dc	CODE	the table
32df	CODE	Mark entry
32e3	CODE	Increase table pointer by 4
32e6	CODE	Check next entry
32e8	CODE	; Table end reached	 insert next line number
32e8	CODE	Restore table start
32ea	CODE	Save program pointer
32eb	CODE	HL = increment
32ee	CODE	HL = new LN + increment = next new LN Next LN > 65535 ?
32ef	CODE	Yes: ?OM Error (wrong error code !!)
32f2	CODE	DE = new LN
32f3	CODE	New LN > 65529 ?
32f8	CODE	Yes: ?OM Error (?!?)
32fb	CODE	Restore program pointer
32fc	CODE	Search for next line number in table
32fe	CODE	; Use new line numbers in program
32fe	CODE	Correct stack
32ff	CODE	Restore program start
3300	CODE	Restore table start
3302	CODE	Restore starting LN
3303	CODE	Program end reached ?
3306	CODE	Yes: RENUM done
3309	CODE	Put new line number
330a	CODE	into program
330d	CODE	Search for GOTO	 GOSUB etc.
3310	CODE	Pointer + 1
3311	CODE	Token found: continue at 33C1H
3313	CODE	Save pointer
3314	CODE	HL = increment
3317	CODE	Calculate next LN
3318	CODE	DE = new LN
3319	CODE	Restore pointer
331a	CODE	Put new LN into program
331c	CODE	; GOTO	 GOSUB etc. found
331c	CODE	Save pointer
331d	CODE	Save new LN
331e	CODE	Transfer LN found into line buffer and determine the number of digits
3321	CODE	Restore new LN
3322	CODE	Restore pointer
3323	CODE	Pointer - 1
3324	CODE	Search for next token if no LN was found (e.g. after THEN or ELSE)
3326	CODE	Pointer + 1
3327	CODE	A = next character
3328	CODE	Space ?
332a	CODE	Yes: update pointer and take next character
332c	CODE	Save new LN
332d	CODE	Save pointer
332e	CODE	HL = new LN for this spot
3334	CODE	Put new LN in line buffer (in ASCII format!)
3337	CODE	C = number of digits (=length) of old LN
333a	CODE	Increment IY to next entry
333d	CODE	DE -> new LN in line buffer
333e	CODE	HL = program pointer (points to old LN)
333f	CODE	Replace old LN at this spot
3342	CODE	Restore new LN
3343	CODE	Pointer - 1
3344	CODE	Pointer + 1
3345	CODE	Increment pointer until
3346	CODE	the next non-space
3348	CODE	character is found
334a	CODE	Comma found ?
334c	CODE	Yes: check for following LN No:
334e	CODE	Pointer - 1
334f	CODE	Search for next token
3351	CODE	; '	' found (with ON GOTO or ON GOSUB)
3351	CODE	Pointer + 1
3352	CODE	Replace next LN
3354	CODE	; Delete B characters from program
*		;
*		; I: B = number of characters to be deleted
*		;    HL -> program text
*		;    (from (HL) onwards	 B bytes are removed from the program text)
3354	CODE	Save registers
3358	CODE	DE -> program text
3359	CODE	Save DE twice
335b	CODE	HL -> end of program
335e	CODE	Save it
335f	CODE	End address - 1
3360	CODE	Program pointer + 1
3361	CODE	Repeat until B = 0
3363	CODE	Save new end address
3366	CODE	Restore old end address
3367	CODE	Restore program pointer
3368	CODE	Calcute the number of bytes
336a	CODE	that have to be moved
336b	CODE	Put the resulting blocksize
336c	CODE	into BC
336d	CODE	Restore program pointer
336e	CODE	DE -> characters to be deleted HL -> remaining program text (following the characters to be deleted)
336f	CODE	Move program text
3371	CODE	Restore registers
3375	CODE	; Insert B characters into program
*		;
*		; I: B = number of characters to be inserted
*		;    HL -> program text
*		;    (from (HL) onwards	 B bytes are inserted in the program text)
3375	CODE	Save registers
3378	CODE	HL -> end of program
337b	CODE	Copy pointer
337c	CODE	into DE
337d	CODE	End address + 1
337e	CODE	Repeat until B = 0
3380	CODE	Save new end address
3383	CODE	Restore program text pointer
3384	CODE	and save it again
3385	CODE	Save end address
3386	CODE	C-flag = 0
3387	CODE	Calculate the number of remaining characters upto program end
3389	CODE	Put the resulting blocksize
338a	CODE	into BC
338b	CODE	Adjust blocksize + 1
338c	CODE	Restore new end address
338d	CODE	Put it in DE
338e	CODE	Move program text
3394	CODE	; Convert line number to ASCII format and put it in line buffer
*		;
*		; I: HL = line number
*		; O: B = number of digits (line number length)
*		;    HL -> line number in ASCII format
3394	CODE	Save DE
3395	CODE	X = HL
3398	CODE	No formatting
339b	CODE	HL -> line buffer
339e	CODE	Save line buffer pointer
339f	CODE	Decode number
33a2	CODE	Restore line buffer pointer
33a3	CODE	B = maximum length
33a5	CODE	A = character from line buffer
33a6	CODE	Leading zero ?
33a8	CODE	No: done Yes:
33aa	CODE	Line buffer pointer + 1
33ab	CODE	Get next character
33ad	CODE	All digits = '0': pointer - 1
33ae	CODE	Counter + 1 (1 digit)
33af	CODE	Restore DE
33b1	CODE	; Increment table pointer to next entry
33ba	CODE	; Search line from (HL) for GOTO	 GOSUB etc.
*		;
*		; I: HL -> line text
*		; O: A = token found
*		;    Z-flag = 1 if no token found
*		;    HL -> token found or end of line
33ba	CODE	pointer + 1
33bb	CODE	A = char from program text
33bc	CODE	End of line ?
33bd	CODE	Yes: return
33be	CODE	Token for GOTO ?
33c0	CODE	Yes: continue at 33CEH
33c2	CODE	Token for GOSUB ?
33c6	CODE	Token for THEN ?
33ca	CODE	Token for ELSE
33cc	CODE	No: next character
33ce	CODE	; Token found
33ce	CODE	Was it a Colour BASIC token ?
33cf	CODE	Does the previous byte
33d0	CODE	equal FFH ?
33d2	CODE	Put pointer back
33d3	CODE	And character back
33d4	CODE	Yes: continue search
33d6	CODE	No: Z-flag = 0
33d8	CODE	; Determine length of line number found and put line number in line buffer
*		;
*		; I: HL -> line number (= token found + 1)
*		; O: B = number of digits (line number length)
*		;    DE -> line buffer (line number is in line buffer from (DE) onwards)
*		;    HL -> next character after the line number
*		;    Z-flag = 0 in case of digits found
33d8	CODE	DE -> line buffer
33dc	CODE	Save DE
33dd	CODE	Counter = 0
33df	CODE	Get next character
33e0	CODE	Space ?
33e2	CODE	Yes: get next character
33e4	CODE	Possible digit ?
33e6	CODE	No: done.
33e8	CODE	Digit ?
33ea	CODE	No: done.
33ec	CODE	Counter + 1
33ed	CODE	Store digit
33ee	CODE	Buffer pointer + 1
33ef	CODE	Line pointer + 1
33f0	CODE	Loop
33f2	CODE	A = 00H
33f3	CODE	Mark line number end in line buffer
33f4	CODE	Restore buffer address
33f5	CODE	Set Z-flag
33f6	CODE	Z-flag = 0 when digits found
33f8	CODE	; Shift program text in such a way	 that a new line number can be inserted
*		; and then insert the new line number
*		;
*		; I: B = new line number length
*		;    C = old line number length
*		;    HL -> program text
*		;    (new line number is inserted from (HL) onwards)
*		;    DE -> new line number in ASCII format
33f8	CODE	Save lengths
33f9	CODE	A = new length
33fa	CODE	- old length
33fb	CODE	Insert new line number when both lengths are identical
33fd	CODE	New length - 1
33fe	CODE	Old length > new length: continue at 3408H
3400	CODE	Old length - 1
3401	CODE	New length > old length: continue at 33F9H
3403	CODE	Insert character
3406	CODE	And transfer line number
3408	CODE	; Old length is bigger than new length
3408	CODE	B = remaining length
3409	CODE	B - 1
340a	CODE	Delete B characters
340d	CODE	Restore lengths
340e	CODE	Transfer digit from line
340f	CODE	buffer to program text
3410	CODE	Line buffer pointer + 1
3411	CODE	Program text pointer + 1
3412	CODE	Repeat until B = 0
3415	CODE	; Get key from keyboard and check for FKEY (see 3000H)
3415	CODE	Wait for key pressed
3418	CODE	Possible FKEY ?
341a	CODE	No: continue at 3458H Yes:
341c	CODE	Is an FKEY ?
341e	CODE	No: continue at 3458H
3420	CODE	A = FKEY number 1..4
3422	CODE	; Transfer FKEY text into line buffer
*		; A = FKEY code (01 to 08 for FKEY1 to FKEY8)
3422	CODE	D = FKEY code
3423	CODE	A = maximum number of characters (see 05D9H)
3424	CODE	Are 7 characters still allowed ?
3426	CODE	No: ignore FKEY and get next key input
3428	CODE	FKEY code back into A
3429	CODE	Save counter
342a	CODE	Save buffer pointer
342b	CODE	; Set HL as pointer to FKEY definition string belonging to FKEY pressed
342b	CODE	HL -> FKEY definition strings in system RAM - length of one string
342e	CODE	DE = length of FKEY string
3431	CODE	HL -> next string
3432	CODE	Proper definition string ?
3433	CODE	No: next
3435	CODE	Restore buffer pointer
3436	CODE	B = length of FKEY string
3438	CODE	A = character of FKEY string
3439	CODE	Is it a 00H (= execute a CR) ?
343b	CODE	Yes	 execute FKEY command
343d	CODE	Store character
343e	CODE	Save buffer pointer
343f	CODE	Output byte
3442	CODE	Restore buffer pointer
3443	CODE	Next position in FKEY string
3444	CODE	Buffer pointer + 1
3445	CODE	Process next
3447	CODE	HL = buffer pointer
3448	CODE	Restore counter
3449	CODE	A = counter
344a	CODE	Subtract 7 characters
344c	CODE	Counter back in B
344d	CODE	Wait for next key press
344f	CODE	; Insert a 'RETURN' to execute FKEY command
344f	CODE	HL = buffer pointer
3450	CODE	A = remaining length of FKEY text
3451	CODE	Restore counter
3452	CODE	A = maximum number of characters + remaining length
3453	CODE	Subtract 7 characters
3455	CODE	New counter back in B
3456	CODE	A = 'RETURN'
3458	CODE	; <SHIFT>+<FKEY> pressed ? (FKEY5 to FKEY8)
3458	CODE	Possible FKEY pressed ?
345a	CODE	No: continue at 3003H
345d	CODE	FKEY pressed ?
345f	CODE	No: continue at 3003H
3462	CODE	A = FKEY code (05H to 08H)
3464	CODE	Continue at 3422H
3466	CODE	; FKEY statement
*		; --------------
3466	CODE	PTP - 1
3467	CODE	Get FKEY number Digit ?
3468	CODE	No: ?FC Error
346b	CODE	Convert character to number
346d	CODE	Save FKEY number
346e	CODE	PTP + 1
346f	CODE	Next character must be
3470	BYTES	the token for '='
3471	CODE	Next character must be
3472	BYTES	double quotes
3473	CODE	A = FKEY number
3474	CODE	FKEY number < 1
3476	CODE	Yes: ?FC Error
3479	CODE	FKEY number > 8
347b	CODE	Yes: ?FC Error
347d	CODE	Save PTP
347e	CODE	HL -> FKEY definitions - 7
3481	CODE	DE = 7 characters length
3484	CODE	HL -> FKEY definition
3485	CODE	FKEY number - 1 Down to 0 ?
3486	CODE	No: next FKEY text
3488	CODE	DE -> proper FKEY definition
3489	CODE	HL = PTP
348a	CODE	PTP - 1
348b	CODE	7 characters definition length
348d	CODE	Get next character
348e	CODE	Is it double quotes ?
3490	CODE	Yes: end of new definition
3492	CODE	Insert 'RETURN'
3494	CODE	Yes: copy 00H and finish
3496	CODE	Copy into FKEY definition
3497	CODE	Pointer + 1
3498	CODE	Next character
349a	CODE	PTP + 1
349b	CODE	Next character must be
349c	BYTES	double quotes
349e	CODE	; End of text reached: fill remaining characters with spaces
349e	CODE	A = space
34a0	CODE	Copy into FKEY definition
34a1	CODE	Next position in definition All done ?
34a2	CODE	Yes: continue ar 34A7H
34a4	CODE	Pointer + 1
34a5	CODE	Loop
34a7	CODE	A = 00H ?
34a8	CODE	Yes: done
34a9	CODE	Test on double quotes
34ab	CODE	; Default definition for FKEY 1 to 8. (This table is copied into system RAM
*		; from 4350H onwards)
34ab	ASCII	FKEY 1 = 'LIST   '
34b2	ASCII	FKEY 2 = 'RUN    '
34b9	ASCII	FKEY 3 = 'AUTO   '
34c0	ASCII	FKEY 4 = 'EDIT   '
34c7	ASCII	FKEY 5 = 'RENUM  '
34ce	ASCII	FKEY 6 = 'SYSTEM',CR
34d5	ASCII	FKEY 7 = 'CLOAD  '
34dc	ASCII	FKEY 8 = 'CSAVE "'
34e3	CODE	; &H
34e3	CODE	Get character following &
34e4	CODE	Is it 'H' (hexadecimal)
34e6	CODE	No: test for &O
34e8	CODE	; Decode hexadecimal constant
34e8	CODE	PTP + 1
34e9	CODE	DE = constant
34ec	CODE	Save PTP
34ed	CODE	HL = constant
34ee	CODE	Write HL to X as INT
34f1	CODE	Restore PTP
34f3	CODE	; DE = &H (HL)
34f3	CODE	Result = 0
34f6	CODE	Decode MSB
34f9	CODE	D = MSB
34fa	CODE	Decode LSB
34fd	CODE	E = LSB
34fe	CODE	PTP + 1
3501	CODE	; A = &H (HL)
3501	CODE	Decode nibble
3504	CODE	Shift bits 4-7
3508	CODE	PTP + 1
3509	CODE	Temporary result in B
350a	CODE	Decode second nibble
350d	CODE	And add previous result
350f	CODE	; Decode a hexadecimal digit
350f	CODE	A = character
3510	CODE	Character < '0'
3512	CODE	Yes: ?FC Error
3515	CODE	Character > '9'
3517	CODE	No: value ok	 done
3518	CODE	Character < 'A'
351a	CODE	Yes: ?FC Error
351d	CODE	Character > 'F'
351f	CODE	Yes: ?FC Error
3523	CODE	; &O
3523	CODE	Is it 'O' (octal)
3525	CODE	No: ?SN Error
3528	CODE	; Decode octal constant
3528	CODE	Result = 0
352b	CODE	PTP + 1
352c	CODE	Decode highest octal digit
352f	CODE	Shift free bits 0-2
3532	CODE	PTP + 1
3533	CODE	Temporary result in B
3534	CODE	Decode next octal digit
3537	CODE	Add previous result
3538	CODE	Shift free bits 0-2
353b	CODE	PTP + 1
353c	CODE	Temporary result in B
353d	CODE	Decode last octal digit
3540	CODE	Add previous result
3541	CODE	LSB value into E
3542	CODE	PTP + 1
3543	CODE	Write HL to X as INT
3545	CODE	; Decode highest octal digit ('0' - '3')
3545	CODE	A = character
3546	CODE	Character < '0'
3548	CODE	Yes: ?FC Error
354a	CODE	Character < '4'
354c	CODE	Yes: value ok	 done
354d	CODE	No: ?FC Error
354f	CODE	; Decode lower octal digit ('0' - '7')
354f	CODE	A = character
3550	CODE	Character < '0'
3552	CODE	Yes: ?FC Error
3554	CODE	Character < '8'
3556	CODE	Yes: value ok	 done
3557	CODE	No: ?FC Error
355a	CODE	; CALL statement
*		; --------------
355a	CODE	DE = address following CALL
355d	CODE	Save PTP
355e	CODE	HL = address of routine
355f	CODE	Set return address for routine
3562	CODE	that is called to 3567H
3563	CODE	activate routine
3564	CODE	--
3567	CODE	; Return from CALL-routine
3567	CODE	Restore PTP
3569	CODE	; Translation table for colour codes (is copied into system RAM from 4390H
*		; onwards). With the first Colour Genies	 the COLOUR value was directly
*		; written into the colour-RAM (from F000H onwards).
*		; Due to hardware changes in later models	 colour codes changed. In order to
*		; keep it compatible this table is used to regain the original colour settings.
*		; This table indicates for every COLOUR value	 which value has to be
*		; written into the colour-RAM in order to regain the old order.
*		;
*		;                    Value in colour-RAM        COLOUR value
3569	BYTES	     1
356a	BYTES	     2
356b	BYTES	     3
356c	BYTES	     4
356d	BYTES	     5
356e	BYTES	     6
356f	BYTES	     7
3570	BYTES	     8
3571	BYTES	     9
3572	BYTES	    10
3573	BYTES	    11
3574	BYTES	    12
3575	BYTES	    13
3576	BYTES	    14
3577	BYTES	    15
3578	BYTES	    16
3579	CODE	; Print text from (HL) onwards and generate sound (with error message)
3579	CODE	Print text
357c	CODE	Set various values to write
357f	CODE	into the PSG
3588	CODE	DE = PSG value
358b	CODE	Write 0078H in frequency reg
358d	CODE	of channel A
3593	CODE	envelope shape use and switch on channel A
3597	CODE	Amplitude channel B = 8
3599	CODE	Amplitude channel C = 0
359f	CODE	Set envelope and return
35a2	CODE	; SUB for SHAPE (see 3CF2H).
*		; Load HL with the start address of the SHAPE table
*		;
*		; I:
*		; O: HL -> start of SHAPE table
35a2	CODE	HL = TOPMEM
35a5	CODE	HL -> start of SHAPE table
35a6	CODE	Continue at 3CF5H
35a9	CODE	; SUB for PRINT#
35a9	CODE	Decode number
35ac	CODE	Write leader and sync
35af	CODE	; SUB for INPUT#
35af	CODE	Decode number
35b2	CODE	Search for leader and sync
35b5	CODE	; Decode number at PRINT# and INPUT#
35b5	CODE	A = 0
35b6	CODE	DE = number
35b9	CODE	Next character must be
35ba	ASCII	a comma
35bb	CODE	A = LSB
35bc	CODE	AND with MSB. MSB must be FFH because a negative number is required.
35bd	CODE	Number was -1 or -2 ?
35bf	CODE	No: ?FC Error
35c3	CODE	; Set volume of indicated channel to 0 (not used)
*		; Is the value of the argument between 1 and 3	 then the corresponding PSG
*		; channel volume will be set to 0. If no argument is given	 the volume of
*		; all PSG channels will be set to 0.
*		; This routine can be used by redirecting e.g. the KILL command
*		; (so the command will be KILL n or KILL).
*		; POKE	 &H4192	195 : POKE &H4193	53
*		;
*		; I: HL = PTP on argument or command/line end
35c3	CODE	PTP -1
35c4	CODE	Channel number provided ?
35c5	CODE	No: continue at 35E1H
35c7	CODE	A = Channel number
35ca	CODE	Register = 8
35cc	CODE	Channel 1 ?
35ce	CODE	Yes: register number is ok
35d0	CODE	Register = 9
35d1	CODE	Channel 2 ?
35d3	CODE	Yes: register number is ok
35d5	CODE	Register = 10
35d6	CODE	Channel 3 ?
35d8	CODE	No: ?FC Error
35db	CODE	A = register number
35dc	CODE	E = 00H
35de	CODE	Write to PSG (SOUND A	E)
35e1	CODE	; No channel number provided: set volume of all channels to 0.
35e1	CODE	Switch off channel 2 and 3
35e9	CODE	Switch off channel 1
35ee	CODE	; SUB for screen output
*		; Write character in A at (HL) and update screen colour
*		;
*		; I: A = character
*		;    HL -> screen position
35ee	CODE	Write character
35ef	CODE	Update character colour
35f2	CODE	Next position
35f3	CODE	Update character colour
35f6	CODE	Back to original position
35f8	CODE	; SUB for screen output
*		; Update the colour of a screen location addressed by HL
*		;
*		; I: HL -> screen location of character in LGR screen memory
35f8	CODE	DE = difference between LGR screen memory (4400H) and corresponding colour memory (0F000H)
35fb	CODE	Space character ?
35fd	CODE	No: set colour according to current colour setting
3600	CODE	; Spaces get the first colour in the colour code table
3600	CODE	A = first entry in colour code table
3603	CODE	Set pointer into colour mem
3604	CODE	Set colour
3607	CODE	; SUB for 'cursor one line down'
3607	CODE	DE = 40 (characters per line)
360a	CODE	Character = ' '
360c	CODE	Output space (delete cursor)
360f	CODE	; SUB for 'cursor one line up'
360f	CODE	DE = -40
3612	CODE	Continue at 360AH
3614	CODE	; SUB for 'cursor on/off'
3614	CODE	Continue at 3618H (see 306EH)
3616	CODE	--
3618	CODE	Output character in A
361b	CODE	; SUB for 'Carriage Return'
361b	CODE	Delete cursor character
361e	CODE	Continue at 3165H
3621	CODE	; SUB for COLOUR change (see 3017H)
3621	CODE	Save new COLOUR value
3624	CODE	HL = actual cursor address
3627	CODE	Switch on cursor
362a	CODE	; SUB for PRINT@ (see 2086H)
*		; Calculate new screen-POS
*		;
*		; I: DE = @ argument
*		; O: A = POS value
362a	CODE	Save HL
362b	CODE	HL = @ argument
362c	CODE	DE = 40 (length of 1 line)
362f	CODE	Add line length
3630	CODE	C-flag = 0
3631	CODE	Subtract line length until
3633	CODE	result becomes negative
3635	CODE	Compensate last subtract
3636	CODE	A = L = actual POS
3637	CODE	Restore HL
3639	CODE	; SUB for scroll (see 3196H)
3639	CODE	Switch registers
363a	CODE	RET-address to AF
363b	CODE	Save registers
363e	CODE	Prepare second register set
3641	CODE	for scroll of colour memory
3647	CODE	Save BC as counter
3648	CODE	Switch back registers
3649	CODE	Prepare first register set
364c	CODE	for scroll of LGR screen mem.
364f	CODE	Restore counter
3650	CODE	RET address back on stack
3652	CODE	; JOY statement
*		; -------------
3652	CODE	A = char. from program text
3653	CODE	PTP + 1
3654	CODE	Token for INP ?
3656	CODE	Yes: continue at 36C5H
3659	CODE	Token for OUT ?
365b	CODE	Yes: continue at 36B3H
365e	CODE	?SN Error
3661	CODE	; COLOUR function (right of = sign)
*		; *** WARNING: NEVER USE THIS! ***
*		; It can lead to a system crash or total program destruction
*		; If you want to perform this function do a PEEK(&H4023) + 1. Much safer....
3661	CODE	A = colour value
3664	CODE	Adjust to get proper value as with COLOUR n (1-16) Colour value zero ?
3665	CODE	Yes: continue at 370DH Note: It would have been ok if the jump would have been unconditional! :-(
3668	CODE	Compare with what ?
3669	CODE	Write A using PTP! Yikes!!!
366a	CODE	; Read a BASIC program from I/O port (JOYINP)
366a	CODE	HL -> start of user BASIC RAM
366d	CODE	Pointer - 1
366e	CODE	B = counter
3670	CODE	Save pointer
3671	CODE	Select register 15 (port B)
3673	CODE	A = PSG port B
3676	CODE	Strobe signal high ?
3678	CODE	No	 wait for strobe pulse
367a	CODE	A = contents of PSG register
367d	CODE	Stobe signal low again ?
367f	CODE	No	 wait for strobe pulse end
3681	CODE	Select register 14 (port A)
3683	CODE	A = PSG port A
3686	CODE	Restore pointer
3687	CODE	Save in memory
3688	CODE	Set flags
3689	CODE	Update memory pointer A = zero ?
368a	CODE	No: next character of program 3 consecutive zeros ?
368c	CODE	No: continue read
368f	CODE	; Write a BASIC program to I/O port (JOYOUT)
368f	CODE	HL -> start of user BASIC RAM
3692	CODE	Pointer - 1
3693	CODE	DE -> end of program text + 2
3697	CODE	Get byte from program text
3698	CODE	Save pointer
3699	CODE	Data in L
369a	CODE	Use PSG port A register
369c	CODE	Output data by port A
369f	CODE	Use PSG port B register
36a0	CODE	Start strobe pulse
36a5	CODE	B = delay time
36a7	CODE	Wait
36a9	CODE	End strobe pulse
36aa	CODE	Output A
36ad	CODE	Restore pointer
36ae	CODE	Pointer + 1
36af	CODE	End of program reached ?
36b0	CODE	No	 send next byte of program
36b3	CODE	; JOYOUT
*		; ------
36b3	CODE	Save PTP
36b4	CODE	Select PSG enable register
36b6	CODE	A = contents of PSG register
36b9	CODE	Set port A and B to output
36bd	CODE	Write to PSG enable register
36c0	CODE	Write BASIC program
36c3	CODE	Restore PTP
36c5	CODE	; JOYINP
*		; ------
36c5	CODE	Select PSG enable register
36c9	CODE	Set Port A and B to input
36cd	CODE	Read BASIC program
36d0	CODE	Renew all pointers in program
36d3	CODE	; SWAP statement
*		; --------------
36d3	CODE	Find or create 1st variable
36d6	CODE	Save pointer on 1st variable
36d7	CODE	A = variable type of X
36da	CODE	Save it
36db	CODE	Next character must be
36dc	ASCII	a comma
36dd	CODE	Find or create 2nd variable
36e0	CODE	Restore 1st variable type
36e1	CODE	Take variable type of X
36e4	CODE	Both variables same type ?
36e5	CODE	No: ?FC Error
36e8	CODE	; Now swap all bytes from both variables. The number of bytes to swap is
*		; indicated by the VT in B
36e8	CODE	HL -> 1st variable
36e9	CODE	C = byte from 1st var
36ea	CODE	A = byte from 2nd var
36eb	CODE	Byte from 2nd var in 1st var
36ec	CODE	A = byte from 1st var
36ed	CODE	Byte from 1st var in 2nd var
36ee	CODE	Pointer on 1st var + 1
36ef	CODE	Pointer on 2nd var + 1
36f0	CODE	Until all var bytes swapped
36f2	CODE	Restore PTP
36f4	CODE	; X = SOUND(register)
36f4	CODE	Next character must be
36f5	ASCII	a '('
36f6	CODE	A = register parameter value
36f9	CODE	Save it
36fa	CODE	Next character must be
36fb	ASCII	a ')'
36fc	CODE	Restore parameter value
36fd	CODE	In range (0 to 15)
36ff	CODE	No: ?FC Error
3702	CODE	Save PTP
3703	CODE	H = PSG register number
3704	CODE	A = contents PSG register H
3707	CODE	Put A in X and return
370a	CODE	; X = SCALE
370a	CODE	A = current scale value
370d	CODE	Save PTP
370e	CODE	Put A in X as INT and return
3711	BYTES	; Table with colour codes (not used)
3721	BYTES	; Table with colour codes (not used)
3731	BYTES	; Table with colour codes (not used)
3741	SPACE	; Unused ROM space
3741	SPACE	--
37cb	CODE	; Print text on screen (not used)
*		;
*		; I: HL -> text
37cb	CODE	Save DE
37cc	CODE	DE -> screen DCB
37cf	CODE	Continue at 36D5H
37d1	CODE	; Print text on printer (not used)
*		; The end of text must be indicated with 03H or 0DH.
*		; The 0DH is printed	 the 03H not.
*		;
*		; I: HL -> text
37d1	CODE	Save DE
37d2	CODE	DE -> printer DCB
37d5	CODE	Save text pointer
37d6	CODE	A = character from text
37d7	CODE	End of text ?
37d9	CODE	Yes: continue at 37E4H
37db	CODE	Print character (using DCB)
37de	CODE	A = character from text
37df	CODE	End of text ?
37e1	CODE	Pointer + 1
37e2	CODE	No: next character
37e4	CODE	Restore original text pointer
37e5	CODE	Restore DE
37e7	CODE	; Conversion of the binary value in DE to 4 hex digits
*		; Used by DOS system call $HEXDE
*		; (reverse of the &H command)
*		;
*		; I: DE = binary value
*		;    HL -> memory space for storage of the 4 hex characters
37e7	CODE	A = D
37e8	CODE	Convert A into 2 hex chars
37eb	CODE	A = E
37ec	CODE	Save binary value
37ed	CODE	Isolate upper nibble
37f4	CODE	Restore binary value
37f5	CODE	Isolate lower nibble
37f7	CODE	Make hex character out of
37f9	CODE	the binary value 0-15
37fd	CODE	Save hex character
37fe	CODE	Update pointer
3800	BYTES	; CTRC programming table for PAL standard
*		; The table entries are written into the CTRC register 15 downwards to
*		; register 0
*		; The table is copied into system RAM from 42F0H onwards
*		; LGR mode
3800	BYTES	Cursor position LSB
3801	BYTES	                MSB
3802	BYTES	Start address of page LSB
3803	BYTES	Start address of page MSB
3804	BYTES	Cursor stop scan line
3805	BYTES	Cursor start scan line
3806	BYTES	Scan lines/row
3807	BYTES	Interlace mode
3808	BYTES	VSYNC position
3809	BYTES	Character rows/frame
380a	BYTES	VSYNC adjust
380b	BYTES	Vertical total
380c	BYTES	HSYNC width
380d	BYTES	HSYNC position
380e	BYTES	Characters/row
380f	BYTES	Horizontal total
3810	BYTES	; FGR mode
3810	BYTES	Cursor position LSB
3811	BYTES	                MSB
3812	BYTES	Start address of page LSB
3813	BYTES	Start address of page MSB
3814	BYTES	Cursor stop scan line
3815	BYTES	Cursor start scan line
3816	BYTES	Scan lines/row
3817	BYTES	Interlace mode
3818	BYTES	VSYNC position
3819	BYTES	Character rows/frame
381a	BYTES	VSYNC adjust
381b	BYTES	Vertical total
381c	BYTES	HSYNC width
381d	BYTES	HSYNC position
381e	BYTES	Characters/row
381f	BYTES	Horizontal total
3820	BYTES	; The next 3 bytes determine the baudrate at which characters are read/written
*		; from/to cassette tape. These values are copies into system RAM at
*		; 4310H	 4311H and 4312H. See also routines at 01FAH and 021FH.
3823	BYTES	; CTRC programming table for NTSC standard (not used)
*		; Using NTSC requires also hardware alterations on the video
*		; hardware. Therefor	 this table is useless for non-NTSC
*		; computers
*		; LGR mode
3823	BYTES	Cursor position LSB
3824	BYTES	                MSB
3825	BYTES	Start address of page LSB
3826	BYTES	Start address of page MSB
3827	BYTES	Cursor stop scan line
3828	BYTES	Cursor start scan line
3829	BYTES	Scan lines/row
382a	BYTES	Interlace mode
382b	BYTES	VSYNC position
382c	BYTES	Character rows/frame
382d	BYTES	VSYNC adjust
382e	BYTES	Vertical total
382f	BYTES	HSYNC width
3830	BYTES	HSYNC position
3831	BYTES	Characters/row
3832	BYTES	Horizontal total

3833	BYTES	; FGR mode	 NTSC standard
3833	BYTES	Cursor position LSB
3834	BYTES	                MSB
3835	BYTES	Start address of page LSB
3836	BYTES	Start address of page MSB
3837	BYTES	Cursor stop scan line
3838	BYTES	Cursor start scan line
3839	BYTES	Scan lines/row
383a	BYTES	Interlace mode
383b	BYTES	VSYNC position
383c	BYTES	Character rows/frame
383d	BYTES	VSYNC adjust
383e	BYTES	Vertical total
383f	BYTES	HSYNC width
3840	BYTES	HSYNC position
3841	BYTES	Characters/row
3842	BYTES	Horizontal total
3843	BYTES	; Default values for timing of cassette I/O (not used)
*		; These values are used for the American version of the
*		; Colour Genie
3846	CODE	; FCLS (without parameter)
3846	CODE	A = FCOLOUR code (0)
3848	CODE	Execute FCLS
384a	CODE	; Continuation of FCLS routine of 3C87H (with parameter)
384a	CODE	If there is a parameter: get parameter
384d	CODE	Value in range (1 to 4)
384f	CODE	No: ?FC Error
3852	CODE	; SUB for FCLS (AF	BC	DE	HL)
*		; Perform an FCLS A
*		;
*		; I: A = FCOLOUR value
3852	CODE	Value in C Build byte value for FGR memory to FCLS with the proper colour
3853	CODE	4 pixels per byte
3855	CODE	Shift 2 positions
3857	CODE	or with C
385a	CODE	FCLS byte value in C
385b	CODE	Save PTP
385c	CODE	HL -> start of user BASIC RAM
385f	CODE	DE -> start of FGR memory + 1
3862	CODE	FGR mode disabled at startup with <MOD SEL> ?
3863	CODE	Yes	 nothing to do so return
3865	CODE	HL -> start of FGR memory
3868	CODE	Put FCLS value in first byte
3869	CODE	BC = bytes to fill
386c	CODE	Fill all bytes in FGR memory
386e	CODE	Restore PTP
3870	CODE	; This routine initializes the CRTC. The screen mode (LGR or FGR) is taken
*		; from the port 255 status byte
3870	CODE	Take port 255 status byte
3873	CODE	; Entry with port 255 status byte already in A
3873	CODE	Save HL
3874	CODE	HL -> CRTC table for LGR mode
3877	CODE	LGR mode ?
3879	CODE	Yes: continue at 387EH
387b	CODE	HL -> CRTC table for FGR mode
387e	CODE	Set CRTC mode
3883	CODE	B = CRTC registers 16
3885	CODE	C = CTRC register select port
3887	CODE	register counter - 1
3888	CODE	Select register
388a	CODE	Adjust B for OUTI
388b	CODE	C = CTRC data register port
388c	CODE	Write value from CRTC table to register. All registers done ?
388e	CODE	No: update next register
3890	CODE	Restore HL
3892	CODE	; This routine sets the screen to LGR and NBGRD. Then it prints the text
*		;
*		; I: HL -> text
*		; O: -
3892	CODE	Save registers
3893	CODE	Take port 255 ouput status
3896	CODE	Set LGR and NBGRD. Leave other bits as they are
3898	CODE	Initialize CRTC
389b	CODE	Restore registers
389c	CODE	Print text
38a0	CODE	; SUB for CONT (see 1DF2H)
*		; Program CRTC on last value and store last LN as actual LN
38a0	CODE	Save registers
38a1	CODE	Initialize CRTC
38a4	CODE	Restore registers
38a5	CODE	Renew actual LN
38a9	CODE	; FGR statement
*		; -------------
38a9	CODE	A = port 255 output status
38ac	CODE	FGR/LGR bit to FGR
38ae	CODE	Initialize CTRC
38b0	CODE	; LGR statement
*		; -------------
38b0	CODE	A = port 255 output status
38b3	CODE	FGR/LGR bit to LGR
38b5	CODE	Initialize CRTC
38b7	CODE	; Old BRGD routine. Replaced by BGRD n at 3FE4H.
38b7	CODE	--
38bb	CODE	; NBGRD statement
*		; ---------------
38bb	CODE	BGRD value = 0
38bd	CODE	A = port 255 output status
38c0	CODE	Clear old BGRD bits
38c2	CODE	Set new BGRD bits
38c3	CODE	Store status in system RAM
38c6	CODE	Set new BGRD
38c9	CODE	; COLOUR statement
*		; ----------------
38c9	CODE	A = colour value - 1
38cc	CODE	Value in range (1 to 16) ?
38ce	CODE	No: ?FC Error
38d1	CODE	Store new value in system RAM
38d5	CODE	; FCOLOUR statement
*		; -----------------
*		; The FCOLOUR token is stored in 3 bytes! (FFH	 81H	 52H)
*		; Because of an error in the old ROM	 only the keyword FCOLOU was recognized.
*		; The missing 'R' had to be stored seperately.
38d5	CODE	Next character must be a 'R'
38d6	ASCII	because token is only FCOLOU
38d7	CODE	A = fcolour value - 1
38da	CODE	Value in range (1 to 4) ?
38dc	CODE	No: ?FC Error
38de	CODE	Store new FCOLOUR value
38e2	CODE	; SUB for tokenizing (see 1C15H)
*		; Scan Colour-keywords table when the end of the normal keyword table
*		; has been reached.
*		;
*		; I: A = current table character
*		;    B = token counter
*		;    C = current text character
*		;    DE = text pointer
*		;    HL = table pointer
38e2	CODE	Table end reached ?
38e4	CODE	No: return
38e5	CODE	HL = text pointer
38e6	CODE	DE -> Colour keyword table
38e9	CODE	Save token counter
38ea	CODE	Set new token counter
38ec	CODE	A = current text character
38ed	CODE	Possible lower case ?
38ef	CODE	No: ok	 continue at 38F7H
38f1	CODE	Lower case ?
38f3	CODE	No: ok	 continue at 38F7H
38f5	CODE	Convert to upper case
38f7	CODE	C = current text character
38f8	CODE	HL = table pointer
38f9	CODE	Table pointer + 1
38fa	CODE	Next keyword reached ?
38fb	CODE	No: increment pointer until next keyword reached
38fe	CODE	Token counter + 1
38ff	CODE	A = keyword table character
3900	CODE	End of keyword table reached ?
3902	CODE	Yes: return
3904	CODE	Compare with text character The same ?
3905	CODE	No: try next keyword
3907	CODE	DE = keyword table pointer
3908	CODE	Save text pointer
3909	CODE	Table pointer + 1
390a	CODE	A = next table character
390b	CODE	Next keyword reached ?
390c	CODE	Yes: all characters match! continue ar 391EH
390f	CODE	No: C = table character
3910	CODE	Text pointer + 1
3911	CODE	A = next text character
3912	CODE	Convert to upper case
3918	CODE	Compare to table character
3919	CODE	Next character when indentical
391b	CODE	Restore old text pointer
391c	CODE	And compare next keyword
391e	CODE	; Keyword found
391e	CODE	Text pointer
391f	CODE	Old token counter
3920	CODE	Remove RET address to 1C18H
3921	CODE	and to 1C3DH
3922	CODE	Restore counter of characters per line
3923	CODE	Save text pointer	 restore buffer pointer
3924	CODE	Store FFH in buffer as Colour-keyword identifier
3926	CODE	A = token value of keyword that has been found
3927	CODE	BC = DE
3929	CODE	Restore text pointer in DE
392a	CODE	Store token
392d	CODE	; End of keyword table reached	 no keyword matched
392d	CODE	Restore old counters
392e	CODE	Remove RET address to 1C18H
392f	CODE	Return to 1C3DH
3930	ASCII	; Keyword table for Colour BASIC statements
3930	ASCII	COLOUR
3936	ASCII	FCOLOU (sic!)
393c	ASCII	KEYPAD
3942	ASCII	JOY
3945	ASCII	PLOT
3949	ASCII	FGR
394c	ASCII	LGR
394f	ASCII	FCLS
3953	ASCII	PLAY
3957	ASCII	CIRCLE
395d	ASCII	SCALE
3962	ASCII	SHAPE
3967	ASCII	NSHAPE
396d	ASCII	XSHAPE
3973	ASCII	PAINT
3978	ASCII	CPOINT
397e	ASCII	NPLOT
3983	ASCII	SOUND
3988	ASCII	CHAR
398c	ASCII	RENUM
3991	ASCII	SWAP
3995	ASCII	FKEY
3999	ASCII	CALL
399d	ASCII	VERIFY
39a3	ASCII	BGRD
39a7	ASCII	NBGRD
39ac	ASCII	end of table
39ad	CODE	; SUB for LIST (see 2BA9H)
*		; Establish start of keyword table.
*		;
*		; O: HL -> keyword table
39ad	CODE	Token value = FFH? (FFH - 7FH)
39af	CODE	HL -> BASIC keyword table
39b2	CODE	No: HL is set properly: return
39b3	CODE	RET address to HL
39b4	CODE	RET address back	 Line pointer to HL
39b5	CODE	A = next character
39b6	CODE	Is it a token ?
39b8	CODE	E = character - 7FH
39b9	CODE	Pointer + 1
39ba	CODE	Save pointer	 RET address in HL
39bb	CODE	Save RET address
39bc	CODE	HL -> Colour keyword table
39c0	CODE	; SUB for program loop (see 1D67H)
*		; Establish start address of jump address table
39c0	CODE	Colour token found ?
39c2	CODE	Yes: continue at 39CCH
39c4	CODE	Command found ?
39c6	CODE	No: continue at 2AE7H
39c9	CODE	Execute command
39cc	CODE	; Colour token found
39cc	CODE	PTP + 1
39cd	CODE	Get real token value
39ce	CODE	Subtract 80H
39d0	CODE	*2 = table offset
39d1	CODE	BC = table offset
39d4	CODE	DE = PTP
39d5	CODE	HL  -> Colour jump table
39d8	CODE	Get jump address as execute routine
39db	WORDS	; Address table for Colour BASIC statements
39db	WORDS	COLOUR
39dd	WORDS	FCOLOUR
39df	WORDS	KEYPAD  (= ?SN Error!)
39e1	WORDS	JOY
39e3	WORDS	PLOT
39e5	WORDS	FGR
39e7	WORDS	LGR
39e9	WORDS	FCLS
39eb	WORDS	PLAY
39ed	WORDS	CIRCLE
39ef	WORDS	SCALE
39f1	WORDS	SHAPE
39f3	WORDS	NSHAPE
39f5	WORDS	XSHAPE
39f7	WORDS	PAINT
39f9	WORDS	CPOINT  (= ?SN Error!)
39fb	WORDS	NPLOT
39fd	WORDS	SOUND
39ff	WORDS	CHAR
3a01	WORDS	RENUM
3a03	WORDS	SWAP
3a05	WORDS	FKEY
3a07	WORDS	CALL
3a09	WORDS	VERIFY
3a0b	WORDS	BGRD
3a0d	WORDS	NBGRD
3a0f	CODE	; X = KEYPAD1	 KEYPAD2	 or KEYPAD(n)
3a0f	CODE	A = char from program text
3a10	CODE	PTP + 1
3a11	CODE	Save PTP
3a12	CODE	Is it a '1' ? (KEYPAD1)
3a14	CODE	Yes: continue at 3AD8H
3a17	CODE	Is it a '2' ? (KEYPAD2)
3a19	CODE	Yes: continue at 3ADCH
3a1c	CODE	Check if (n) set
3a1f	CODE	; X = JOY1X	 JOY1Y	 JOY2X	 JOY2Y or JOY(n)
3a1f	CODE	A = character at PTP
3a20	CODE	Is it a '('
3a22	CODE	Yes: continue at 3A4AH
3a26	CODE	Is it a '2' ? (JOY2)
3a28	CODE	Yes: continue at 3A31H
3a2a	CODE	D = D / 2
3a2c	CODE	Is it a '1' ? (JOY1)
3a2e	CODE	No: ?SN Error
3a31	CODE	Get next non-space character
3a32	CODE	Char = 'Y' ? (JOY1Y	JOY2Y)
3a34	CODE	Yes: continue at 3A3BH
3a36	CODE	D = D - 1
3a37	CODE	Char = 'X' ? (JOY1X	JOY2X)
3a39	CODE	No: ?SN Error JOY1X: D = 1   JOY1Y: D = 2 JOY2X: D = 3   JOY2Y: D = 4
3a3b	CODE	PTP + 1
3a3c	CODE	Save PTP
3a3d	CODE	Get joystick value
3a40	CODE	Set to value between  0-63
3a42	CODE	Adjust to 1 to 64
3a43	CODE	Put A in X as INT and return
3a45	CODE	; Not used
3a45	CODE	Get joystick value
3a47	CODE	--
3a4a	CODE	; JOY (n)
3a4a	CODE	PTP + 1
3a4b	CODE	Get parameter
3a4e	CODE	In range (0-7)
3a50	CODE	No: ?FC Error
3a53	CODE	Parameter in D
3a54	CODE	Next character must be
3a55	ASCII	a ')'
3a56	CODE	D + 1
3a57	CODE	Save PTP
3a58	CODE	Get joystick value
3a5b	CODE	Put A in X as INT and return
3a5e	CODE	; Get joystick value
*		; I: D = parameter with joystick ID (range: 1 to 8)
*		;        D = 1: JOY1X / D = 2: JOY1Y / D = 3: JOY2X / D = 4: JOY2Y
*		;        The remaining values (5 to 8) can be used for a second pair
*		;        of joysticks (or 4 other analogue inputs)
*		; O: Value return by joystick
3a5e	CODE	Set port A to output	 port B to input
3a61	CODE	A = 0;
3a62	CODE	E	7 = 1
3a64	CODE	Set bit in A
3a65	CODE	L = A
3a66	CODE	Select PSG port A
3a68	CODE	Write A to port A
3a6b	CODE	Select PSG Port B
3a6c	CODE	A = contents of port B
3a6f	CODE	Save counter D
3a70	CODE	Shift required bit into C-flag
3a71	CODE	Required bit in C-flag ?
3a72	CODE	No: shift again
3a74	CODE	Restore counter
3a75	CODE	Last output value in A Required bit = '1' ?
3a76	CODE	Yes: continue at 3A7BH
3a78	CODE	A = bitmask
3a79	CODE	Invert it
3a7a	CODE	And with L
3a7b	CODE	Shift E 1 bit to the right All 8 bits done ?
3a7d	CODE	No: loop
3a80	CODE	; Old KEYPAD routine (now at 3A0FH)
3a80	CODE	Was: KEYPAD1
3a83	CODE	--
3a84	CODE	Was: KEYPAD2
3a87	CODE	; KEYPAD routine
*		; Read value from keypad and store in A
*		;
*		; I: D = keypad bit mask (FEH for KEYPAD1	 F7H for KEYPAD2)
*		; O: A = value from keypad
3a87	CODE	Set port A to output	 port B to input
3a8a	CODE	E = LSB of start address of KEYPAD table
3a8c	CODE	Test 2 columns
3a8e	CODE	L = keypad address
3a8f	CODE	Select port A
3a91	CODE	Select keypad
3a94	CODE	Next PSG register
3a95	CODE	Get keypad value
3a98	CODE	Test 4 rows
3a9a	CODE	Shift next bit into C-flag Key pressed ?
3a9b	CODE	Yes: continue at 3AA5H
3a9d	CODE	Table offset + 1
3a9e	CODE	Row counter - 1
3a9f	CODE	Check next row
3aa1	CODE	Address next column
3aa3	CODE	Read next column
3aa5	CODE	DE -> keypad table at proper offset
3aa7	CODE	A = keypad value
3aa9	CODE	; Prepare port A for output and port B for input
3aa9	CODE	Select PSG enable register
3aab	CODE	A = contents of PSG register
3aae	CODE	Set port A to output (bit 7)
3ab0	CODE	and port B to input (bit 6)
3ab2	CODE	; Write A into PSG register addressed by H
*		;
*		; I: H = PSG register number
*		;    A = data to write into register
3ab2	CODE	L = A
3ab5	CODE	Select PSG register
3ab8	CODE	Write new contents in PSG
3abb	CODE	; Read PSG register addressed by H
*		;
*		; I: H = PSG register number
*		; O: A = contents of data register
3abb	CODE	C = PSG select register
3abd	CODE	Select register H
3abf	CODE	C = PSG data register
3ac0	CODE	A = data from data register
3ac3	CODE	; KEYPAD(n)
3ac3	CODE	Restore PTP
3ac4	CODE	Adjust PTP
3ac5	CODE	Next character must be
3ac6	ASCII	a '('
3ac7	CODE	Get n - 1
3aca	CODE	In range (1 or 2)
3acc	CODE	No: ?FC Error
3acf	CODE	save n
3ad0	CODE	Next character must be
3ad1	ASCII	a ')'
3ad2	CODE	Restore parameter
3ad3	CODE	Save PTP
3ad4	CODE	n = 1 ?
3ad6	CODE	Yes: continue at 3ADCH
3ad8	CODE	; KEYPAD1
3ad8	CODE	Set bitmask for keypad 1
3ada	CODE	Continue at 3ADEH
3adc	CODE	; KEYPAD2
3adc	CODE	Set bitmask for keypad 2
3ade	CODE	A = value from keypad
3ae1	CODE	Put A in X and return
3ae4	BYTES	; Keypad table with the return values for the 12 keys on the keypad
3ae4	BYTES	'3'
3ae5	BYTES	'6'
3ae6	BYTES	'9'
3ae7	BYTES	Fire button (right)
3ae8	BYTES	'2'
3ae9	BYTES	'5'
3aea	BYTES	'8'
3aeb	BYTES	'0'
3aec	BYTES	'1'
3aed	BYTES	'4'
3aee	BYTES	'7'
3aef	BYTES	Fire button (left)
3af0	BYTES	No key pressed
3af1	CODE	; SCALE statement
*		; ---------------
3af1	CODE	Get new scale value
3af4	CODE	and save it in system RAM
3af8	CODE	; CIRCLE statement
*		; ----------------
3af8	CODE	Get X-coordinate
3afb	CODE	Save X-coordinate
3afc	CODE	Next character must be
3afd	ASCII	a comma
3afe	CODE	Get Y-coordinate
3b01	CODE	Save Y-coordinate
3b02	CODE	Next character must be
3b03	ASCII	a comma
3b04	CODE	Get radius
3b07	CODE	D = Y-coordinate
3b08	CODE	B = X-coordinate
3b09	CODE	C = Y-coordinate
3b0a	CODE	; B = X-coordinate	 C = Y-coordinate	 A = radius
3b0a	CODE	Save PTP
3b0b	CODE	Radius in D = Y-distance
3b0c	CODE	X-distance = 0
3b0e	CODE	H = step value Y-distance < X-distance (circle is closed) ?
3b10	CODE	; Plot next 8 points
3b10	CODE	Yes: restore PTP and return
3b13	CODE	Plot 4 points and swap X- and Y-distance
3b16	CODE	Plot 4 points and swap back
3b19	CODE	Negate distances
3b1c	CODE	Save registers
3b1f	CODE	Bit 7 of L = 1: This causes an overflow with the first ADD HL	HL to bit 0 of H
3b21	CODE	H = X-distance
3b22	CODE	Process 8 bits
3b24	CODE	E = 0	 D = Y-distance
3b26	CODE	; Calculate next step for Y distance
3b26	CODE	Shift next bit from H to C-flag
3b27	CODE	HL = HL - DE - C-flag
3b29	CODE	Jump when underflow. Because E = 0	 this can only happen when H < D.
3b2b	CODE	HL + 1 (= L + 1)
3b2c	CODE	Loop
3b2e	CODE	Reverse subtract
3b2f	CODE	Loop
3b31	CODE	A = L
3b32	CODE	Restore registers
3b35	CODE	A = A + step value C-flag = 1 if A + H > 255
3b36	CODE	H = new step value
3b37	CODE	A = Y-distance
3b38	CODE	L = 0;
3b3a	CODE	A = Y-distance - C-flag
3b3b	CODE	D = new Y-distance
3b3c	CODE	X-distance + 1
3b3d	CODE	A = Y-distance
3b3e	CODE	X-distance > Y-distance ?
3b3f	CODE	Continue at 3B10H
3b42	CODE	; PLOT B + E 	 C + D
3b42	CODE	Save registers
3b45	CODE	A = X-distance
3b46	CODE	+ centre-coordinates
3b47	CODE	Results in X-coordinate
3b48	CODE	A = Y-distance
3b49	CODE	+ centre-coordinates
3b4a	CODE	Results in Y-coordinate
3b4b	CODE	PLOT L 	 H
3b4e	CODE	Restore registers
3b52	CODE	; End CIRCLE
3b52	CODE	Restore PTP
3b54	CODE	; Negate X-distance (E = -E)
3b54	CODE	A = E
3b55	CODE	A = -A
3b57	CODE	new value back in E
3b59	CODE	; Negate Y-distance (D = -D)
3b59	CODE	A = D
3b5a	CODE	A = -A
3b5c	CODE	new value back in D
3b5e	CODE	; Negate X- and Y-distance
3b5e	CODE	Negate X-distance
3b61	CODE	Negate Y-distance
3b65	CODE	; PLOT B - E 	 C + D
3b65	CODE	Negate X-distance
3b68	CODE	PLOT B + E 	 C + D
3b6c	CODE	; PLOT B + E 	 C - D
3b6c	CODE	Negate Y-distance
3b6f	CODE	PLOT B + E 	 C + D
3b73	CODE	; Swap X- and Y-distance
3b73	CODE	L = E
3b75	CODE	E = D
3b77	CODE	D = L
3b7a	CODE	; Plot 4 points and exchange X- and Y-distance
3b7a	CODE	PLOT B + E	 C + D (bottom right)
3b7d	CODE	PLOT B - E	 C + D (bottom left)
3b80	CODE	PLOT B - E	 C - D (top left)
3b83	CODE	PLOT B + E	 C - D (top right)
3b86	CODE	Exchange distances for second call	 see 3B13H)
3b8a	CODE	; SUB for PLOT	 PAINT	 SHAPE and CIRCLE
*		; PLOT L 	 H (AF	BC	DE	HL)
*		;
*		; I: L = X-coordinate
*		;    H = Y-coordinate
*		;    (4313H) = FCOLOUR value
3b8a	CODE	A = FCOLOUR value
3b8d	CODE	Clear unused bits
3b8f	CODE	; PLOT L 	 H
*		; just as 3B8AH	 but A = FCOLOUR value
3b8f	CODE	C = FCOLOUR value
3b90	CODE	A = X-max. (159)
3b92	CODE	Beyond X-max ?
3b93	CODE	Yes: done
3b94	CODE	A = Y-max (101)
3b96	CODE	Beyond Y-max ?
3b97	CODE	Yes: done
3b98	CODE	A = X-coordinate
3b99	CODE	L = Y-coordinate
3b9a	CODE	HL = Y-coordinate
3b9c	CODE	DE = HL
3b9e	CODE	HL = HL * 40
3b9f	CODE	(one row in FGR mode
3ba0	CODE	corresponds with 40 bytes
3ba1	CODE	in FGR screen memory)
3ba4	CODE	E = X-coordinate
3ba5	CODE	E = E * 4
3ba7	CODE	(one byte in FGR memory contains 4 pixels)
3ba9	CODE	DE = start of FGR memory + X-coordinate * 4
3bab	CODE	Add Y-coordinate * 40 to get the byte in FGR screen memory that has to be used
3bac	CODE	Compute position of pixel
3bae	CODE	inside byte
3baf	CODE	B = X-coordinate MOD 4
3bb0	CODE	A = 11111100 (2 bits/pixel)
3bb2	CODE	Shift the 2 zero bits to the
3bb3	CODE	required position
3bb4	CODE	Shift FCOLOUR code along
3bb8	CODE	Repeat until counter = 0
3bba	CODE	Get byte of required pixel
3bbb	CODE	and set new colour
3bbc	CODE	Save new byte value
3bbe	CODE	; NPLOT statement
*		; ---------------
3bbe	CODE	Set NPLOT
3bc0	CODE	--
3bc1	ENTRY	; PLOT statement
*		; --------------
3bc1	ENTRY	Set PLOT
3bc3	CODE	A = FCOLOUR value
3bc6	CODE	Save it on stack
3bc7	CODE	And it with B to get either black (NPLOT) or the current value (PLOT)
3bc8	CODE	Save new FCOLOUR to use
3bcb	CODE	'TO' token indicated ?
3bce	CODE	No: continue at 3BFFH
3bd0	CODE	Get last X-value and
3bd3	CODE	save it on stack
3bd4	CODE	Get last Y-value and
3bd7	CODE	save it on stack
3bd8	CODE	Get next X-value and
3bdb	CODE	save it in system RAM
3bde	CODE	and on stack
3bdf	CODE	Next character must be
3be0	ASCII	a comma
3be1	CODE	Get next Y-value and
3be4	CODE	save it in system RAM
3be7	CODE	switch register set
3be8	CODE	L' = Y2
3be9	CODE	Restore X-value
3bea	CODE	H' = X2
3beb	CODE	Restore last Y-value
3bec	CODE	Restore last X-value
3bed	CODE	E' = Y1	 D' = X1
3bee	CODE	Switch register set
3bef	CODE	Save PTP
3bf0	CODE	Switch register set
3bf1	CODE	PLOT  D 	 E  TO  H 	 L
3bf4	CODE	Restore PTP
3bf5	CODE	'TO' indicated ?
3bf8	CODE	Yes	 get next X	Y-coordinates
3bfa	CODE	Restore old FCOLOUR value
3bfb	CODE	and store it in system RAM
3bff	CODE	; Get new X	Y-coordinates ('TO' not at the start)
3bff	CODE	Get X-coordinate
3c02	CODE	Save X-coordinate
3c03	CODE	Next character must be
3c04	ASCII	a comma
3c05	CODE	Get Y-coordinate
3c08	CODE	Save Y-coordinate
3c09	CODE	'TO' indicated ?
3c0c	CODE	Yes: get second pair of X	Y-coordinates
3c0e	CODE	No: Restore Y-coordinate
3c0f	CODE	Save it in system RAM
3c12	CODE	D = Y-coordinate
3c13	CODE	Restore X-coordinate
3c14	CODE	Save it in system RAM
3c17	CODE	E = X-coordinate
3c18	CODE	DE = PTP	 H = Y-	 L = X-coor.
3c19	CODE	Save PTP
3c1a	CODE	PLOT  L 	 H
3c1d	CODE	Restore PTP and previous FCOLOUR value
3c1f	CODE	; SUB for PLOT
*		; PLOT  D 	 E  TO  H 	 L  (AF	BC	DE	HL)
*		; I: D = X-Coordinate of starting point
*		;    E = Y-Coordinate of starting point
*		;    H = X-Coordinate of ending point
*		;    L = Y-Coordinate of ending point
3c1f	CODE	PLOT  H 	 L (plot end point)
3c22	CODE	HL = DE ? (start and end are identical)
3c23	CODE	Yes: done.
3c24	CODE	--
3c26	CODE	Save X1	Y1
3c27	CODE	A = Y1
3c28	CODE	A = Y1 - Y2 Negative result ?
3c29	CODE	Yes: negate result and set C-flag = 1
3c2c	CODE	Put C-flag in bit 7 of C
3c2e	CODE	Shift C to the right
3c30	CODE	B = Y-diff (always positive!)
3c31	CODE	Shift C to the right
3c33	CODE	Shift C to the right
3c35	CODE	A = X1
3c36	CODE	A = X1 - X2 Negative result ?
3c37	CODE	Yes: negate result and set C-flag = 1
3c3a	CODE	Put C-flag in bit 7 of C
3c3c	CODE	C-flag = 1
3c3d	CODE	Shift C to the right	 bit 7=1
3c3f	CODE	X-diff < Y-diff ?
3c40	CODE	Yes: swap lower and upper nibble of C	 E = X-diff	 D = Y-diff
3c42	CODE	No: D = X-diff
3c44	CODE	E = Y-diff
3c45	CODE	; D now contains the bigger difference and E contains the smaller difference.
*		; Both nibbles of C indicate the angle; the upper nibble for D
*		; and the lower nibble for E
3c45	CODE	Save angle
3c46	CODE	Save X2	Y2
3c47	CODE	A = bigger difference
3c48	CODE	C = A
3c49	CODE	A = 0
3c4b	CODE	D = 0
3c4c	CODE	B = 0	 so BC = bigger diff.
3c4d	CODE	H = 0
3c4e	CODE	A = smaller difference
3c4f	CODE	L = A	 so HL = smaller diff
3c50	CODE	HL = HL * 2
3c54	CODE	HL = smaller difference * 2 - bigger difference
3c56	CODE	BC = BC * 2
3c5a	CODE	E = smaller difference * 2
3c5c	CODE	D = bigger difference * 2
3c5e	CODE	A = H
3c5f	CODE	Switch register sets
3c60	CODE	Restore X2	Y2
3c61	CODE	Restore angle
3c62	CODE	Restore X1	Y1
3c63	CODE	; Calculate and plot next point
3c63	CODE	A	7 into C-flag C-flag = 1 ?
3c65	CODE	No: change X2 and Y2 according to the angle of the smaller difference
3c68	CODE	Change X2 and Y2 according to the angle of the bigger diff.
3c6b	CODE	PLOT  H 	 L
3c6e	CODE	A = X1
3c6f	CODE	X1 = X2 ?
3c70	CODE	No: set next point
3c72	CODE	A = Y1
3c73	CODE	Y1 = Y2 ?
3c74	CODE	Yes: done.
3c75	CODE	Switch register sets
3c76	CODE	HL' = HL' + DE'
3c77	CODE	A = H'
3c78	CODE	Switch register sets
3c79	CODE	Set next point
3c7b	CODE	; 'TO' indicated ?
3c7b	CODE	A = next character
3c7c	CODE	'TO' token ?
3c7e	CODE	No: C-flag = 1
3c80	CODE	PTP + 1
3c81	CODE	C-flag = 0
3c83	CODE	; FCLS statement
*		; --------------
3c83	CODE	Adjust PTP
3c84	CODE	Get next non-space character
3c85	CODE	A = 00H
3c87	CODE	Continue ar 384AH
3c8a	CODE	--
3c8b	CODE	; A = -A	 C-flag = 1
3c8b	CODE	A = -A
3c8d	CODE	C-flag = 1
3c8f	CODE	; Swap upper and lower nibble of C	 E = X-diff	 D = Y-diff (see 3C40H)
3c8f	CODE	Swap nibbles of C
3c92	CODE	E = X-diff
3c93	CODE	A = Y-diff
3c94	CODE	D = A
3c95	CODE	Back to 3C45H
3c97	CODE	; Swap upper and lower nibble of C
3c97	CODE	Rotate C left 4 times
3ca0	CODE	; Change X2 and Y2 according to the angle of the smaller difference
3ca0	CODE	Swap nibbles of C
3ca3	CODE	Change X2 and Y2
3ca6	CODE	Swap nibbles of C
3ca9	CODE	Switch register sets
3caa	CODE	C-flag = 0
3cab	CODE	HL' = HL' - BC'
3cad	CODE	Switch register sets
3caf	CODE	; Change X2 and Y2 according to the angle of the bigger difference
3caf	CODE	Change Y2 ?
3cb1	CODE	Yes: continue at 3CBDH
3cb4	CODE	Increase X2 ?
3cb6	CODE	No: continue at 3CBBH
3cb9	CODE	X2 + 1
3cbb	CODE	X2 - 1
3cbd	CODE	Increment Y2 ?
3cbf	CODE	No: continue at 3CC4H
3cc2	CODE	Y2 + 1
3cc4	CODE	Y2 - 1
3cc6	CODE	; SUB for PLOT
*		; PLOT  H 	 L  (AF)
*		;
*		; I: H = X-coordinate
*		;    L = Y-coordinate
3cc6	CODE	Save registers
3cc9	CODE	Swap H and L
3ccc	CODE	PLOT  H 	 L
3ccf	CODE	Restore registers
3cd3	CODE	; XSHAPE statement
*		; ----------------
3cd3	CODE	Set bit mask for XSHAPE
3cd6	CODE	Continue at 3CE0H
3cd8	CODE	; NSHAPE statement
*		; ----------------
3cd8	CODE	Set bit mask for NSHAPE
3cdb	CODE	Continue at 3CE0H
3cdd	CODE	; SHAPE statement
*		; ---------------
3cdd	CODE	Set bit mask for SHAPE
3ce0	CODE	Save bit mask
3ce4	CODE	Adjust PTP
3ce5	CODE	Get next non-space character
3ce6	CODE	Get X coordinate
3ce9	CODE	Save X coordinate
3cea	CODE	Next character must be
3ceb	ASCII	a comma
3cec	CODE	Get Y coordinate
3cef	CODE	D = X coordinate
3cf0	CODE	E = Y coordinate
3cf1	CODE	Save PTP
3cf2	CODE	Continue at 35A2H
3cf5	CODE	B = length of SHAPE table
3cf6	CODE	Update SHAPE table pointer
3cf7	CODE	A = SCALE factor
3cfa	CODE	SCALE = 0 ?
3cfb	CODE	Yes: done.
3cfd	CODE	C = SCALE factor
3cfe	CODE	A = entry from SHAPE table
3cff	CODE	Take upper nibble
3d08	CODE	A' = 1 = flag for processing of first segment (every table entry contains 2 segments)
3d0b	CODE	Save table value
3d0c	CODE	Direction: vertical ? (bit0=1)
3d0e	CODE	Yes: continue at 3D4DH
3d10	CODE	Direction: left ? (bit1=1)
3d12	CODE	Yes: continue at 3D4AH
3d14	CODE	X + 1 (direction: right)
3d15	CODE	Save registers
3d18	CODE	L = table value
3d19	CODE	A = FCOLOUR value
3d1c	CODE	Save it
3d1d	CODE	Table value back to A
3d1e	CODE	Take bit mask for operation
3d21	CODE	Mask colour value
3d23	CODE	Store as new FCOLOUR value
3d26	CODE	Coordinates in HL
3d28	CODE	PLOT  L 	 H
3d2b	CODE	Restore original FCOLOUR value
3d2c	CODE	Store it in system RAM
3d2f	CODE	Restore registers
3d32	CODE	Restore table value
3d33	CODE	SCALE factor > 1 ?
3d34	CODE	Yes: process same table value again (C times)
3d36	CODE	Save table counter
3d38	CODE	Flag = 1 ?
3d39	CODE	B = flag - 1
3d3b	CODE	B = 0 ?
3d3c	CODE	(then flag was 1)
3d3d	CODE	Restore table counter
3d3e	CODE	A = SCALE factor
3d41	CODE	C = SCALE factor
3d42	CODE	A = table value Flag was 1 ?
3d43	CODE	Yes: process second segment
3d45	CODE	Table pointer + 1
3d46	CODE	Next entry in SHAPE table
3d48	CODE	Restore PTP
3d4a	CODE	; Direction: left
3d4a	CODE	X-coordinate - 1
3d4b	CODE	Back to SCALE routine
3d4d	CODE	; Direction: vertical
3d4d	CODE	Direction: up ? (Bit1=1)
3d4f	CODE	Yes: continue at 3D45H
3d51	CODE	Y-coordinate + 1 (down)
3d52	CODE	Back to SCALE routine
3d54	CODE	; Direction: up
3d54	CODE	Y-coordinate - 1
3d55	CODE	Back to SCALE routine
3d57	CODE	; SUB for tokenizing (see 392AH)
*		; Store Colour-Token into coded line.
3d57	CODE	Character counter + 1
3d58	CODE	Buffer pointer + 1
3d59	CODE	DE = buffer pointer (on coded text) HL = text pointer (on uncoded text)
3d5a	CODE	Text pointer + 1
3d5b	CODE	Store token in buffer
3d5c	CODE	Buffer pointer + 1
3d5d	CODE	Character counter + 1
3d5e	CODE	Continue at 1BCCH
3d61	CODE	; PLAY statement
*		; --------------
3d61	CODE	Next character must be
3d62	ASCII	a '('
3d63	CODE	Get channel number - 1
3d66	CODE	In range (1 to 3) ?
3d68	CODE	No: ?FC Error
3d6b	CODE	Save channel number
3d6c	CODE	Next character must be
3d6d	ASCII	a comma.
3d6e	CODE	Get octave number - 1
3d71	CODE	In range (1 to 8) ?
3d73	CODE	No: ?FC Error
3d75	CODE	Adjust octave number
3d76	CODE	Save octave number
3d77	CODE	Next character must be
3d78	ASCII	a comma
3d79	CODE	Get note number
3d7c	CODE	Note number zero ?
3d7d	CODE	Yes: continue at 3DBEH
3d7f	CODE	In range (1 to 29)
3d81	CODE	No: ?FC Error
3d83	CODE	A * 2 to get offset
3d85	CODE	DE = note table offset
3d88	CODE	Next character must be
3d89	ASCII	a comma
3d8a	CODE	Save PTP
3d8b	CODE	HL -> note table
3d8e	CODE	Add offset
3d8f	CODE	DE = note frequency
3d92	CODE	Restore PTP
3d93	CODE	B = octave number
3d94	CODE	Adjust to use as counter Counter zero ?
3d95	CODE	Yes: continue at 3D9DH
3d97	CODE	Do DE = DE / 2 for every
3d99	CODE	octave: double frequency
3d9b	CODE	Loop
3d9d	CODE	A = channel number
3d9e	CODE	Save it again
3d9f	CODE	Calculate register address
3da1	CODE	A = A * 2 + 1
3da2	CODE	Write note freq. into PSG
3da5	CODE	Get volume value
3da8	CODE	In range (0 to 16) ?
3daa	CODE	No: ?FC Error
3dac	CODE	Save frequency setting
3dad	CODE	Select:
3daf	CODE	A = PSG register 7
3db1	CODE	Write to PSG
3db4	CODE	Restore frequency setting
3db5	CODE	Restore channel number
3db6	CODE	Calculate register address
3db8	CODE	Write to PSG
3dbb	CODE	Next character must be
3dbc	ASCII	a ')'
3dbe	CODE	Next character must be
3dbf	ASCII	a comma
3dc0	CODE	Get amplitude value
3dc3	CODE	In range (0 to 16) ?
3dc5	CODE	No: ?FC Error
3dc8	CODE	Correct stack
3dc9	CODE	Get channel number
3dca	CODE	Amplitude = 0
3dcc	CODE	Continue at 3DB6H
3dcf	WORDS	; Note table containing the frequency register values for the PSG
3e0b	CODE	--
3e0e	CODE	; SUB for ? (not used)
*		; Write DE in X. If DE > 0 then VT = INT else VT = SNG
3e0e	CODE	D negative ?
3e10	CODE	No: Write DE in X as INT
3e12	CODE	VT = SNG
3e15	CODE	A <- D <- E <- 00H
3e16	CODE	(Shift DE 8 bits to the left
3e17	CODE	overflow in A)
3e19	CODE	C-flag = 0
3e1a	CODE	ADE back 1 bit to the right
3e1f	CODE	B = Exp for 2 ^ 17
3e21	CODE	SFLOAT (X)
3e25	CODE	HL = DE
3e26	CODE	Write HL to X as INT
3e2a	CODE	; SUB for PSG programming
*		; Writes the 16 bit value in DE into PSG registers addressed by A
*		;
*		; I: A = register number of MSB data register
*		;    DE = register data
3e2a	CODE	Save register number in B
3e2b	CODE	Select PSG register
3e2d	CODE	Register data from D to A
3e2e	CODE	Write data in PSG register
3e30	CODE	register number - 1
3e31	CODE	Put it in A
3e32	CODE	; Now write LSB register with value in E
3e32	CODE	Select PSG register
3e34	CODE	Register data from E to A
3e35	CODE	Write data in PSG register
3e38	CODE	; PAINT statement
*		; ---------------
3e38	CODE	Number of parameters = 0
3e39	CODE	Adjust PTP
3e3a	CODE	Number of parameters + 1
3e3b	CODE	A' = counter
3e3c	CODE	Get next non-space character
3e3d	CODE	Get next parameter
3e40	CODE	Save parameter on stack
3e41	CODE	Adjust PTP
3e42	CODE	Get next non-space character End reached ?
3e43	CODE	Yes: continue at 3E51H
3e45	CODE	Comma ?
3e47	CODE	No: ?SN Error
3e49	CODE	A = counter
3e4a	CODE	Maximum number of parameters (4) exceeded ?
3e4c	CODE	No: continue at 3E3AH
3e4e	CODE	?SN Error
3e51	CODE	; Evaluate the parameters on stack
3e51	CODE	A = counter
3e52	CODE	At least 2 parameters ?
3e54	CODE	No: ?SN error
3e56	CODE	Correct A to get the number
3e57	CODE	border colours
3e58	CODE	Store this in A
3e5b	CODE	DE -> system RAM area for PAINT statement
3e5e	CODE	Number of border colours
3e5f	CODE	DE -> last byte in
3e60	CODE	system RAM area for PAINT
3e61	CODE	Get value from stack
3e62	CODE	-1
3e63	CODE	Colour value in range ?
3e65	CODE	No: ?FC Error
3e68	CODE	Store in system RAM
3e69	CODE	pointer - 1
3e6a	CODE	Next parameter
3e6c	CODE	A = Y coordinate
3e6d	CODE	Y coordinate in range ?
3e6f	CODE	No: ?FC Error
3e71	CODE	D = Y coordinate
3e72	CODE	A = X coordinate
3e73	CODE	X coordinate in range ?
3e75	CODE	No: ?FC Error
3e77	CODE	E = X coordinate
3e78	CODE	Save PTP
3e79	CODE	HL = -1 (flag for routine end)
3e7c	CODE	Save flag
3e7d	CODE	HL = Y	X
3e7e	CODE	; Set next point
3e7e	CODE	Save coordinates in system RAM
3e81	CODE	Set FCOLOUR if border not reached
3e84	CODE	Continue at 3E8CH when border has been reached
3e86	CODE	X - 1
3e87	CODE	A = -1
3e89	CODE	X = -1 ?
3e8a	CODE	No: next point
3e8c	CODE	X + 1
3e8d	CODE	A = X-coordinate
3e8e	CODE	Save it (left edge)
3e91	CODE	Last coordinates to HL
3e94	CODE	X + 1
3e95	CODE	A = 160
3e97	CODE	X = 160 ?
3e98	CODE	Yes: continue at 3E9FH
3e9a	CODE	Set FCOLOUR if border not reached
3e9d	CODE	If border not reached: next point
3e9f	CODE	X - 1
3ea0	CODE	A = X-coordinate
3ea1	CODE	Save it (right edge)
3ea4	CODE	A = Y-coordinate
3ea7	CODE	Y = 0 ?
3ea8	CODE	Yes: continue at 3EB6H
3eaa	CODE	Y - 1
3eab	CODE	H = Y-coordinate
3eac	CODE	Check Y-coordinate
3eaf	CODE	A = Y-coordinate
3eb2	CODE	Y = 102 ?
3eb4	CODE	Yes: continue at 3EBBH
3eb6	CODE	Y + 1
3eb7	CODE	H = Y-coordinate
3eb8	CODE	Check Y-coordinate
3ebb	CODE	A = -1
3ebd	CODE	Restore Y-coordinate
3ebe	CODE	Flag reached ?
3ebf	CODE	No: next point
3ec1	CODE	Restore PTP
3ec3	CODE	; Check Y-coordinate
*		;
*		; I: H = Y-coordinate
3ec3	CODE	C = 255 (flag)
3ec5	CODE	A = X-coordinate of left edge
3ec8	CODE	L = left edge
3ec9	CODE	A = X-coordinate right edge
3ecc	CODE	A = distance between left and right edge
3ecd	CODE	B = distance
3ece	CODE	B + 1
3ecf	CODE	Done when both edges are identical
3ed0	CODE	; Check complete line of new Y-coordinate
3ed0	CODE	Save register
3ed2	CODE	Border colour at L	H reached ?
3ed5	CODE	Restore registers
3ed7	CODE	No: continue at 3EDFH
3ed9	CODE	Yes: flag = 255
3edb	CODE	X + 1
3edc	CODE	Check next X-coordinate
3edf	CODE	; Border colour not reaches at new Y-coordinate
3edf	CODE	A = 0
3ee0	CODE	Flag = 0 ? (This area already recognized)
3ee1	CODE	Yes: continue at 3EDBH
3ee3	CODE	C = 2 (for 1963H)
3ee5	CODE	Save BC
3ee6	CODE	Stack has still room enough ?
3ee9	CODE	Restore BC
3eea	CODE	RET address to DE
3eeb	CODE	Save X	Y coordinates
3eec	CODE	Put RET address back on stack
3eed	CODE	Flag = 0
3eef	CODE	Continue at 3EDBH
3ef1	CODE	; Border colour reached at point L	H ?
*		; Z-flag = 0: No
*		; Z-flag = 1: Yes
3ef1	CODE	A = CPOINT( L	H )
3ef4	CODE	Save coordinated
3ef5	CODE	HL -> number of border colours
3ef8	CODE	B = number of border colours
3ef9	CODE	HL -> border colour table
3efc	CODE	Border colour reached ?
3efd	CODE	Yes: done.
3eff	CODE	Pointer + 1
3f00	CODE	Check next colour
3f02	CODE	Restore coordinates
3f04	CODE	; Set new colour for point L	H in case border colour is not reached yet.
3f04	CODE	Save coordinates
3f05	CODE	Border colour reached ?
3f08	CODE	Save flags
3f09	CODE	B = X MOD 4 (from CPOINT)
3f0a	CODE	A = new FCOLOUR
3f0d	CODE	C = A
3f0e	CODE	If border colour not reached: set new colour
3f11	CODE	Restore flags
3f12	CODE	Restore coordinates
3f14	CODE	; Old KEYPAD1 routine (no longer used)
3f18	CODE	; Old KEYPAD2 routine (no longer used)
3f21	CODE	; SUB for processing expressions (at 2337H)
*		; Continuation of 3F7AH: interception of Colour-BASIC functions
3f21	CODE	Token for SOUND ?
3f23	CODE	Yes: continue at 36F4H
3f26	CODE	Token for SCALE ?
3f28	CODE	Yes: continue at 370AH
3f2b	CODE	Token for COLOUR ?
3f2d	CODE	Yes: continue at 3661H
3f30	CODE	Continue at 2505H
3f33	CODE	; VERIFY statement
*		; ----------------
3f33	CODE	PTP + 1
3f34	CODE	Continue at 2C29H
3f37	CODE	--
3f3a	CODE	; SUB for CPOINT and PAINT
*		; This routine takes the colour value for pixel at (X	Y)
*		;
*		; I: L = X coordinate
*		;    H = Y coordinate
*		; O: A = colour value (1 to 4) - 1
3f3a	CODE	A = X coordinate
3f3b	CODE	HL = Y coordinate
3f3e	CODE	DE = Y coordinate
3f40	CODE	Multiply Y coordinate by 40
3f41	CODE	(40 bytes/ line)
3f42	CODE	Result in HL
3f43	CODE	HL = offset from start of FGR
3f44	CODE	page to start of line (Y)
3f46	CODE	Multiply X coordinate by 4
3f47	CODE	(4 pixels/byte)
3f49	CODE	E = offset from start of line to X
3f4b	CODE	DE = start of FGR page + E
3f4d	CODE	HL -> FGR memory location that contains (X	Y)
3f4e	CODE	Now make counter for
3f50	CODE	getting the proper 2 bits for
3f51	CODE	X coordinate within the byte
3f52	CODE	Result in B as counter
3f53	CODE	Load byte from FGR memory
3f54	CODE	Rotate until the proper 2
3f55	CODE	bits are in bit 1 and 0
3f58	CODE	Clear bits 7 to 2
3f5b	CODE	--
3f5c	CODE	; X = CPOINT(x-coordinate	y-coordinate)
3f5c	CODE	Next character must be
3f5d	ASCII	a '('
3f5e	CODE	Get X coordinate
3f61	CODE	and put it on stack
3f62	CODE	Next character must be
3f63	ASCII	a comma
3f64	CODE	Get Y coordinate
3f67	CODE	and put it on stack
3f68	CODE	Next character must be
3f69	ASCII	a ')'
3f6a	CODE	D = Y coordinate
3f6b	CODE	A = X coordinate
3f6c	CODE	H = Y coordinate	 DE = PTP
3f6d	CODE	Save PTP
3f6e	CODE	L = X coordinate
3f6f	CODE	Get FGR memory contents for specified coordinate
3f72	CODE	HL = A
3f75	CODE	Write HL to X as INT
3f78	CODE	Restore PTP
3f7a	CODE	; SUB for processing of expressions
*		; Interception of Colour-BASIC functions
3f7a	CODE	USR token found: Continue at 27FEH
3f7d	CODE	Colour-BASIC token ?
3f7f	CODE	No: continue at 2504H
3f82	CODE	Increase PTP	 next token in A
3f83	CODE	PTP + 1
3f84	CODE	Token for KEYPAD ?
3f86	CODE	Yes: continue at 3A0FH
3f89	CODE	Token for CPOINT ?
3f8b	CODE	Yes: continue at 3F5CH
3f8d	CODE	Token for JOY ?
3f8f	CODE	Yes: continue at 3A1FH
3f92	CODE	Continue at 3F21H
3f95	CODE	; SOUND statement
*		; ---------------
3f95	CODE	Get PSG register number
3f98	CODE	In range (0 to 15) ?
3f9a	CODE	No: ?FC Error
3f9d	CODE	Save PSG register number
3f9e	CODE	Next character must be
3f9f	ASCII	a comma
3fa0	CODE	Get register data
3fa3	CODE	E = register data
3fa4	CODE	A = PSG register number
3fa8	CODE	; CHAR statement
*		; --------------
3fa8	CODE	A = char value - 1
3fab	CODE	Value in range (1 to 4) ?
3fad	CODE	No: ?FC Error
3fb0	CODE	Mask bits
3fb2	CODE	Rotate to proper position
3fb5	CODE	Put it in B
3fb6	CODE	A = port 255 output status
3fb9	CODE	Clear the old bits for CHAR
3fbb	CODE	Set the new bits
3fbc	CODE	Activate new CHAR
3fbe	CODE	and store status in system RAM
3fc2	CODE	; Process expression at (HL) and return result - 1 in A
*		;
*		; I: HL = PTP on BASIC expression
*		; O: A = result - 1
3fc2	CODE	PTP - 1
3fc3	CODE	Get next non-space character
3fc4	CODE	Get result
3fc7	CODE	A - 1
3fc9	CODE	; Set character and cursor colour (not used)
3fd2	CODE	; SUB for LIST (see 2B91H)
*		; No token found. Output a text-constant ?
3fd2	CODE	Text-constant ?
3fd4	CODE	No: return to LIST
3fd7	CODE	Buffer pointer + 1
3fd8	CODE	Counter - 1
3fd9	CODE	Return when line buffer full
3fda	CODE	Get character
3fdb	CODE	End of text reached ?
3fdd	CODE	Text pointer + 1
3fde	CODE	Put character in buffer
3fdf	CODE	Yes: return to LIST
3fe2	CODE	Next character
3fe4	CODE	; BGRD statement
*		; --------------
3fe4	CODE	Adjust PTP
3fe5	CODE	Get next non-space character
3fe6	CODE	Set BGRD value to 4 parameter present after BGRD ?
3fe8	CODE	No: continue at 38BDH
3feb	CODE	A = bgrd value - 1
3fee	CODE	Value in range (1 to 4) ?
3ff0	CODE	No: ?FC Error
3ff3	CODE	Mask bits
3ff5	CODE	Rotate to proper position
3ff7	CODE	Put result in B
3ff8	CODE	A = port 255 output status
3ffb	CODE	Clear old bits for BGRD n
3ffd	CODE	OR with B and write to port 0FFH


4040	BYTES	DOS time tick
4041	BYTES	DOS time sec
4042	BYTES	DOS time min
4043	BYTES	DOS time hour
4044	BYTES	DOS time year
4045	BYTES	DOS time month
4046	BYTES	DOS time day
4050	WORDS	DOS timer chain pointer
4052	BYTES	DOS timer chain count
408e	BYTES	DOS number of files

4400	SPACE	; video RAM (LGR)
4800	CODE	; video RAM (FGR)
5800	CODE	; DOS sector buffer #1
5900	SPACE	; DOS sector buffer #2
5A00	BYTE	Current track drive #0
5A01	BYTE	Current track drive #1
5A02	BYTE	Current track drive #2
5A03	BYTE	Current track drive #3
5A04	BYTE	
5A05	BYTE	
5A06	BYTE	
5A07	BYTE	
5A08	BYTES	Currently selected floppy drive number
5A09	BYTES	Floppy drive motor control byte
5A0A	BYTES	; Currently selected floppy's drive parameters
5A0A	BYTES	; DDSL   Disk Directory Start Lump (lump number of GAT)
5A0B	BYTES	; GATL   Granule Allocation Table Length (in sectors)
5A0C	BYTES	; STEPRT step rate and density flag ...
5A0D	BYTES	; TRACKS total number of tracks
5A0E	BYTES	; SPT    sectors per track (both sides on DS media!)
5A0F	BYTES	; GATM   GAT mask (number of meaningful bits per byte in GAT)
5A10	BYTES	; P7     ???? always zero
5A11	BYTES	; FLAGS  ???? some flags (bit 6 = density)
5A12	BYTES	; GPL    Granules Per Lump (5 is the default)
5A13	BYTES	; DDGA   Disk Directory Granule Allocation (dir granules)

5A71	BYTES	; Floppy drive parameters for drive #0
5A71	BYTES	#0 DDSL
5A72	BYTES	#0 GATL
5A73	BYTES	#0 STEPRT
5A74	BYTES	#0 TRACKS
5A75	BYTES	#0 SPT
5A76	BYTES	#0 GATM
5A77	BYTES	#0 P7
5A78	BYTES	#0 FLAGS
5A79	BYTES	#0 GPL
5A7A	BYTES	#0 DDGA

5A7b	BYTES	; Floppy drive parameters for drive #1
5A7B	BYTES	#1 DDSL
5A7C	BYTES	#1 GATL
5A7D	BYTES	#1 STEPRT
5A7E	BYTES	#1 TRACKS
5A7F	BYTES	#1 SPT
5A80	BYTES	#1 GATM
5A81	BYTES	#1 P7
5A82	BYTES	#1 FLAGS
5A83	BYTES	#1 GPL
5A84	BYTES	#1 DDGA

5A85	BYTES	; Floppy drive parameters for drive #2
5A85	BYTES	#2 DDSL
5A86	BYTES	#2 GATL
5A87	BYTES	#2 STEPRT
5A88	BYTES	#2 TRACKS
5A89	BYTES	#2 SPT
5A8A	BYTES	#2 GATM
5A8B	BYTES	#2 P7
5A8C	BYTES	#2 FLAGS
5A8D	BYTES	#2 GPL
5A8E	BYTES	#2 DDGA

5A8f	BYTES	; Floppy drive parameters for drive #3
5A8F	BYTES	#3 DDSL
5A90	BYTES	#3 GATL
5A91	BYTES	#3 STEPRT
5A92	BYTES	#3 TRACKS
5A93	BYTES	#3 SPT
5A94	BYTES	#3 GATM
5A95	BYTES	#3 P7
5A96	BYTES	#3 FLAGS
5A97	BYTES	#3 GPL
5A98	BYTES	#3 DDGA

5A99	WORDS	Pointer to drive parameter table

5a9b	SPACE	free space (?)

c000	ASCII	DOS ROM signature
c001	CODE	;DOS ROM entry
c001	CODE	Get return address into DE
c002	CODE	Called from address 03E6H ?
c005	CODE	Compare HL with DE
c006	CODE	Restore return address to the stack
c007	CODE	Yes: continue at 0C231H
c00a	CODE	No: get keyboard row #6
c00d	CODE	Is the <Break> key pressed?
c00f	CODE	Yes: don't install COLOUR-DOS vectors
c010	CODE	Initialize 4040H to 407FH
c013	CODE	With all 0s
c01b	CODE	Set interrupt mode 1
c01d	CODE	Print DISK-BASIC FILES? message
c023	CODE	Wait for keypress
c026	CODE	Was it <Enter>?
c028	CODE	No: assume it was '0' to '9'
c02a	CODE	Yes: use '3' for 3 disk files
c02e	CODE	The input was > '9'?
c030	CODE	Yes: try again
c032	CODE	No: store number of files
c035	CODE	Copy jump to interrupt service routine
c038	CODE	to 4012H (RST 38H jumps there)
c03b	CODE	Copy 3 bytes
c040	CODE	Copy to 402FH
c043	CODE	Some initialization data
c046	CODE	Copy 7 bytes
c04b	CODE	Copy to 402FH
c04e	CODE	Some initialization data
c046	CODE	Copy 7 bytes

c0d9	CODE	Get Extension ROM signature
c0dc	CODE	is it 'N' ?
c0de	CODE	Yes: jump to Extension ROM
c0e2	CODE	; Jump table for COLOUR-DOS functions
c0e2	CODE	Interrupt service routine (copied to 4012H)
c0e5	CODE	; DOS function vectors copied to 4152H ...
c0e5	CODE	function  1
c0e8	CODE	function  2
c0eb	CODE	function  3
c0ee	CODE	function  4
c0f1	CODE	function  5
c0f4	CODE	function  6
c0f7	CODE	function  7
c0fa	CODE	function  8
c0fd	CODE	function  9
c100	CODE	function 10
c103	CODE	function 11
c106	CODE	function 12
c109	CODE	function 13
c10c	CODE	function 14
c10f	CODE	function 15
c112	CODE	function 16
c115	CODE	function 17
c118	CODE	function 18
c11b	CODE	function 19
c11e	CODE	function 20
c121	CODE	function 21
c124	CODE	function 22
c127	CODE	function 23
c12a	CODE	function 24
c12d	CODE	function 25
c130	CODE	function 26
c133	CODE	function 27
c136	CODE	function 28
c139	CODE	function 29
c13c	CODE	function 30
c13f	CODE	function 31
c142	CODE	function 32
c145	CODE	function 33
c148	CODE	function 34
c14b	CODE	function 35
c14e	CODE	function 36
c151	CODE	function 37
c154	CODE	function 38
c157	CODE	function 39
c15a	CODE	function 40
c15d	CODE	function 41
c160	CODE	function 42
c163	CODE	function 43
c166	CODE	function 44
c169	CODE	function 45
c16c	CODE	function 46
c16f	CODE	function 47
c172	CODE	function 48
c175	CODE	function 49
c178	WORDS	; CMD"<char> jump table
c178	WORDS	CMD";" - extension
c17a	WORDS	CMD"<{drive}={format}" - set PDRIVE parameters
c17c	WORDS	CMD"=" - extension
c17e	WORDS	CMD">" - extension
c180	WORDS	CMD"?
c182	WORDS	CMD"@" - extension
c184	WORDS	CMD"A" - extension
c186	WORDS	CMD"B" - extension
c188	WORDS	CMD"C
c18a	WORDS	CMD"D
c18c	WORDS	CMD"E
c18e	WORDS	CMD"F" - format disk
c190	WORDS	CMD"G
c192	WORDS	CMD"H
c194	WORDS	CMD"I[{drive}] - disk inventory
c196	WORDS	CMD"JKL" - print screen
c198	WORDS	CMD"K" - extension
c19a	WORDS	CMD"L[filename[/ext[:drive]]]" - load program file
c19c	WORDS	CMD"M" - extension
c19e	WORDS	CMD"N
c1a0	WORDS	CMD"O" - extension
c1a2	WORDS	CMD"P" - extension
c1a4	WORDS	CMD"Q" - extension
c1a6	WORDS	CMD"R
c1a8	WORDS	CMD"S[filename[/ext[:drive]]]" - start program
c1aa	WORDS	CMD"T" - disable timer interrupts
c1ac	WORDS	CMD"U
c1ae	WORDS	CMD"V
c1b0	WORDS	CMD"W
c1b2	WORDS	CMD"X
c1b4	WORDS	CMD"Y
c1b6	WORDS	CMD"Z
c1b8	CODE	; 7 (07H) bytes copied to 402FH ...
c1b9	CODE	Cold boot
c1bc	CODE	Cold boot
c1bf	BYTES	; 23 (17H) bytes copied to 404BH ...
c1c8	CODE	; Jump to ?
c1cb	BYTES	?
c1cf	CODE	; Jump to display time function
c1d2	BYTES	?
c1d6	CODE	; Error entries
c1d6	CODE	Error 29H entry
c1d8	CODE	--
c1d9	ENTRY	Error 16H entry
c1db	CODE	--
c1dc	ENTRY	Error 17H entry
c1de	CODE	--
c1df	ENTRY	Error 1DH entry
c1e1	CODE	--
c1e2	ENTRY	Error 0AH entry
c1e4	CODE	--
c1e5	ENTRY	Error 13H entry
c1e7	ENTRY	Store error code in 43E3H
c1ef	CODE	; Error intercepted from BASIC
c1f5	CODE	Display "DISK: " prior to error message
c1f9	CODE	Print message at HL
c1fb	CODE	Discard return address
c202	ASCII	; 'DISK-BASIC FILES ?' message shown at cold boot
c217	ASCII	; Copyright message (appears whenever H+J+N are pressed at once)
c22a	ASCII	; Unused message 'DISK: '
c231	CODE	; Intercept BASIC line input
c231	CODE	Get keyboard row #1
c234	CODE	Test for keys H+J+N
c236	CODE	Yes: print copyright message
c238	CODE	Test for keys J+K+L
c23a	CODE	Yes: send screen to printer
c23d	CODE	No: eturn to BASIC
c23e	CODE	; Print the copyright message
c244	CODE	; Print the current time in the top	 right corner
c244	CODE	Video RAM + 30 characters -> HL
c247	CODE	; Convert current time to a string at HL ...
c247	CODE	Time seconds location -> DE
c24a	CODE	Colon ':' character -> B
c24c	CODE	Three times 2 decimal digits -> C
c24e	CODE	'0' - 1 -> (HL)
c250	CODE	Get date/time value -> A
c251	CODE	Increment tens digit
c252	CODE	Subtract 10 from value
c254	CODE	Repeat until underflow occurs
c257	CODE	Undo underflow and add '0'
c259	CODE	Store unit digit
c25b	CODE	Next date/time location
c25c	CODE	Anything left to print?
c25d	CODE	No: return to caller
c25e	CODE	Yes: store the separator character
c260	CODE	Convert next digit pair
c262	CODE	; Convert current date to a string at HL ...
c262	CODE	Time day of month location -> DE
c265	CODE	Period '.' character -> B
c267	CODE	Continue conversion function
c269	CODE	; TIME$ function
*		; --------------
c26a	CODE	Save PTP on the stack
c26b	CODE	17 characters temporary string space
c26d	CODE	Get string space address to DE
c270	CODE	String address -> HL
c271	CODE	Convert date to string at HL ...
c274	CODE	Store a blank between date and time
c277	CODE	Convert time to string at HL ...
c27a	CODE	Set VT to STR
c27d	CODE	; CMD"C statement
*		; ----------------
c27e	ASCII	CR
c27f	CODE
c2c5	CODE	; CMD"H statement
*		; ----------------
c2c6	ASCII	CR
c2c7	CODE
c2d6	CODE	; ? function
c2d6	CODE	A != 0
c2d7	ENTRY	; ? function
c2d7	CODE	A = 0
c2d9	CODE	CRTC start address register MSB -> A
c2db	CODE	Get CRTC register pair -> HL
c2df	CODE	Save start address on stack
c2e3	CODE	CRTC cursor address register MSB -> A
c2e5	CODE	Get CRTC register pair -> HL
c2e8	CODE	Save cursor address on stack
c2e9	CODE	X = CINT (X)
c2ec	CODE	Restore cursor address -> DE
c2ed	CODE	Restore start address -> BC
c2ee	CODE	HL + start
c2ef	CODE	Position address -> DE	 cursor address -> HL
c2f1	CODE	Position - cursor -> HL
c2f3	CODE	Write HL to X as INT
c2f6	CODE	; Flash background on	 then restore to previous BGRD
c2f6	CODE	Get current port 0FFH value
c2f9	CODE	Save for later
c2fa	CODE	Call old BGRD subroutine
c2fd	CODE	17.3 ms delay (1536 * 11.3 us)
c300	CODE	Call delay subroutine
c303	CODE	Restore old port 0FFH value
c304	CODE	Write to port 0FFH
c308	CODE	; Input H and L from CRTC ports A and A+1
c317	CODE	; CMD statement
*		; -------------
c318	BYTES	'"' double quote
c319	CODE	';'
c354	BYTES	'"' double quote
c355	CODE
c371	CODE	; DEF statement
*		; -------------
c398	BYTES	= token
c399	CODE
c3ae	CODE	; USR function
*		; ------------
c3e2	ASCII	'('
c3e3	CODE
c41b	ASCII	'	'
c41c	CODE
c421	BYTES	= token
c422	CODE
c474	CODE	; INSTR function
*		; --------------
c493	ASCII	')'
c494	CODE
c4e0	ASCII	'	'
c4e1	CODE
c4f8	CODE	; MID$ function
*		; -------------
c4fa	ASCII	'('
c4fb	CODE
c511	ASCII	'	'
c512	CODE
c527	ASCII	')'
c528	CODE
c529	BYTES	= token
c52a	CODE
c566	CODE	; MKD$ function
*		; -------------
c569	CODE	; MKS$ function
*		; -------------
c56c	CODE	; MKI$ function
*		; -------------
c57d	CODE	; CVD function
*		; -------------
c580	CODE	; CVS function
*		; -------------
c59c	CODE	; LSET statement
*		; --------------
c59d	CODE	; RSET statement
*		; --------------
c5bb	BYTES	= token
c5bc	CODE
c5ee	CODE	; FIELD statement
*		; ---------------
c648	CODE	; PRINT statement
*		; ---------------
c616	ASCII	'A'
c617	CODE
c618	ASCII	'S'
c619	CODE
c654	CODE	; CMD"R statement
*		; ----------------
c65b	CODE	; CMD"T statement
*		; ----------------
c662	BYTES	CR
c663	CODE
c664	CODE	; CMD"E statement
*		; ----------------
c665	BYTES	CR
c666	CODE
c677	CODE	; CMD"D statement
*		; ----------------
c679	CODE	; LINE statement
*		; --------------
c67b	BYTES	INPUT token
c67c	CODE
c6ab	CODE	; INPUT statement
*		; ---------------
c6d9	CODE	; LINE INPUT statement
*		; --------------------
c710	CODE	; display character
c7b3	ASCII	'	'
c7b4	CODE
c8f1	CODE	; RUN statement
*		; -------------
c8f4	CODE	; LOAD statement
*		; --------------
c904	ASCII	'	'
c905	CODE
c906	ASCII	'R'
c907	CODE	?SN error
c980	CODE	; MERGE statement
*		; ---------------
c9ba	CODE	; SAVE statement
*		; --------------
c9c4	ASCII	'	'
c9c5	CODE
c9c6	ASCII	'A'
c9c7	CODE
c9e2	CODE	; CLOSE statement
*		; ---------------
ca1d	CODE	; LOF function
*		; ------------
ca28	CODE	; LOC function
*		; ------------
cae9	CODE	; EOF function
*		; ------------
cab4	CODE	; PUT statement
*		; -------------
cab5	CODE	; GET statement
*		; -------------
cb70	CODE	; OPEN statement
*		; --------------
cba5	ASCII	'	'
cba6	CODE
cbb0	ASCII	'	'
cbb1	CODE
cbff	CODE	; KILL statement
*		; --------------
cc22	CODE	; NAME statement
*		; --------------
cc2a	CODE	; SYSTEM statement
*		; ----------------
cc2b	CODE	; CMD"< statement
*		; ----------------
cc39	ASCII	'='
cc3a	CODE
cc5f	CODE	; CMD"? statement
*		; ----------------
cc75	CODE	; CMD"G statement
*		; ----------------
cc9f	ASCII	CR
cca0	CODE
cca2	CODE	; CMD"I statement
*		; ----------------
cd2e	CODE	; CMD"JKL statement
*		; ----------------
cd2f	ASCII	'K'
cd30	CODE
cd31	ASCII	'L'
cd32	CODE
cd33	ASCII	CR
cd34	CODE
cd6f	CODE	; CMD"L statement
*		; ----------------
cd79	CODE	; CMD"S statement
*		; ----------------
cd7f	CODE	; CMD"Y statement
*		; ----------------
cd80	CODE	; CMD"V statement
*		; ----------------
cd8b	CODE	; CMD"U statement
*		; ----------------
cd9c	CODE	; CMD"X statement
*		; ----------------
cdab	CODE	; CMD"Z statement
*		; ----------------
cde2	ASCII	; DIR/SYS entry
cded	BYTES
cdf4	BYTES	Timer max seconds (59)
cdf5	BYTES	Timer max minutes (59)
cdf5	BYTES	Timer max hours (23)
cdf7	CODE	; Convert to upper case
ce67	CODE	Print message from (HL)
ce7c	CODE	Print DE as hexadecimal
ce80	BYTES	; Bitmap block for BOOT/SYS
cea0	BYTES	; parameters for 'PDRIVE' format A
cea0	BYTES	DDSL
cea1	BYTES	GATL
cea2	BYTES	STEPRT
cea3	BYTES	TRACKS
cea4	BYTES	SPT
cea5	BYTES	GATM
cea6	BYTES	P7
cea7	BYTES	FLAGS
cea8	BYTES	GPL
cea9	BYTES	DDGA

ceaa	BYTES	; parameters for 'PDRIVE' format B
ceaa	BYTES	DDSL
ceab	BYTES	GATL
ceac	BYTES	STEPRT
cead	BYTES	TRACKS
ceae	BYTES	SPT
ceaf	BYTES	GATM
ceb0	BYTES	P7
ceb1	BYTES	FLAGS
ceb2	BYTES	GPL
ceb3	BYTES	DDGA

ceb4	BYTES	; parameters for 'PDRIVE' format C
ceb4	BYTES	DDSL
ceb5	BYTES	GATL
ceb6	BYTES	STEPRT
ceb7	BYTES	TRACKS
ceb8	BYTES	SPT
ceb9	BYTES	GATM
ceba	BYTES	P7
cebb	BYTES	FLAGS
cebc	BYTES	GPL
cebd	BYTES	DDGA

cebe	BYTES	; parameters for 'PDRIVE' format D
cebe	BYTES	DDSL
cebf	BYTES	GATL
cec0	BYTES	STEPRT
cec1	BYTES	TRACKS
cec2	BYTES	SPT
cec3	BYTES	GATM
cec4	BYTES	P7
cec5	BYTES	FLAGS
cec6	BYTES	GPL
cec7	BYTES	DDGA

cec8	BYTES	; parameters for 'PDRIVE' format E
cec8	BYTES	DDSL
cec9	BYTES	GATL
ceca	BYTES	STEPRT
cecb	BYTES	TRACKS
cecc	BYTES	SPT
cecd	BYTES	GATM
cece	BYTES	P7
cecf	BYTES	FLAGS
ced0	BYTES	GPL
ced1	BYTES	DDGA

ced2	BYTES	; parameters for 'PDRIVE' format F
ced2	BYTES	DDSL
ced3	BYTES	GATL
ced4	BYTES	STEPRT
ced5	BYTES	TRACKS
ced6	BYTES	SPT
ced7	BYTES	GATM
ced8	BYTES	P7
ced9	BYTES	FLAGS
ceda	BYTES	GPL
cedb	BYTES	DDGA

cedc	BYTES	; parameters for 'PDRIVE' format G
cedc	BYTES	DDSL
cedd	BYTES	GATL
cede	BYTES	STEPRT
cedf	BYTES	TRACKS
cee0	BYTES	SPT
cee1	BYTES	GATM
cee2	BYTES	P7
cee3	BYTES	FLAGS
cee4	BYTES	GPL
cee5	BYTES	DDGA

cee6	BYTES	; parameters for 'PDRIVE' format H
cee6	BYTES	DDSL
cee7	BYTES	GATL
cee8	BYTES	STEPRT
cee9	BYTES	TRACKS
ceea	BYTES	SPT
ceeb	BYTES	GATM
ceec	BYTES	P7
ceed	BYTES	FLAGS
ceee	BYTES	GPL
ceef	BYTES	DDGA

cef0	BYTES	; parameters for 'PDRIVE' format I
cef0	BYTES	DDSL
cef1	BYTES	GATL
cef2	BYTES	STEPRT
cef3	BYTES	TRACKS
cef4	BYTES	SPT
cef5	BYTES	GATM
cef6	BYTES	P7
cef7	BYTES	FLAGS
cef8	BYTES	GPL
cef9	BYTES	DDGA

cefa	BYTES	; parameters for 'PDRIVE' format J
cefa	BYTES	DDSL
cefb	BYTES	GATL
cefc	BYTES	STEPRT
cefd	BYTES	TRACKS
cefe	BYTES	SPT
ceff	BYTES	GATM
cf00	BYTES	P7
cf01	BYTES	FLAGS
cf02	BYTES	GPL
cf03	BYTES	DDGA

cf04	BYTES	; parameters for 'PDRIVE' format K
cf04	BYTES	DDSL
cf05	BYTES	GATL
cf06	BYTES	STEPRT
cf07	BYTES	TRACKS
cf08	BYTES	SPT
cf09	BYTES	GATM
cf0a	BYTES	P7
cf0b	BYTES	FLAGS
cf0c	BYTES	GPL
cf0d	BYTES	DDGA

cf0e	BYTES	; parameters for 'PDRIVE' format L
cf0e	BYTES	DDSL
cf0f	BYTES	GATL
cf10	BYTES	STEPRT
cf11	BYTES	TRACKS
cf12	BYTES	SPT
cf13	BYTES	GATM
cf14	BYTES	P7
cf15	BYTES	FLAGS
cf16	BYTES	GPL
cf17	BYTES	DDGA

cf18	CODE	; Interrupt service routine
cf35	CODE	; Jump to interrupt function
cf38	CODE	; Timer interrupt handler
cf38	CODE	Timer memory at 4040H
cf3b	CODE	Tick count + 1
cf3c	CODE	Timer function chain
cf42	CODE	Get next function address LSB -> E
cf44	CODE	Get next function address MSB -> D
cf45	CODE	Save next function address to the stack
cf47	CODE	Get next restart value -> B
cf49	CODE	Count this timer down - expired?
cf4a	CODE	Yes: jump to timer function
cf4d	CODE	Restore next function address -> HL
cf4e	CODE	Check next timer in chain
cf50	CODE	; ? function
d0a4	CODE	; ? function
d0b2	CODE	; ? function
d0c2	CODE	; Select floppy drive (IX+6)
d0c7	CODE	; Reselect current floppy drive
d0ca	CODE	; Select floppy drive A (0-3)
d13c	CODE	; Floppy disk timer interrupt
d59d	CODE	; CMD"N statement
*		; ----------------
da20	CODE	; ? function
da2e	CODE	; ? function
da49	CODE	; ? function
dc8b	CODE	; CMD"W statement
*		; ----------------
dd88	CODE	; CMD"F statement
*		; ----------------
dfb5	BYTES	; Single density format
dfec	ASCII	; Allocation bitmap pseudo file NCW1983/JHL
dff7	BYTES
ffed	BYTES	track register
ffff	0
