/* ed:set tabstop=8 noexpandtab: */
/*****************************************************************************
 *
 *  osd.c	Operating System Dependencies for audio/video/keyboard I/O
 *
 * Copyright Juergen Buchmueller <pullmoll@t-online.de>
 * Copyright 2015 Andreas MÃ¼ller <schnitzeltony@googlemail.com>
 *
 *****************************************************************************/
#include "osd.h"
#include "osd_bitmap.h"
#include "osd_font.h"


osd_bitmap_t *frame = NULL;

static int32_t throttle = 1;
/*static int32_t fullscreen = 0;*/
static int32_t frameskip = 0;
static int32_t autoframeskip = 1;
static int32_t max_autoframeskip = 8;
static int32_t start_video = 0;

static int32_t mousex;
static int32_t mousey;
static int32_t mouseb;

static SDL_AudioSpec *audio_spec_desired;
static SDL_AudioSpec *audio_spec_obtained;
static uint32_t sample_rate = 48000;
static double refresh_rate = 50.0;

#define	SBUFF_SIZE	16384
typedef struct sbuff_s {
	ssize_t size;
	ssize_t head;
	ssize_t tail;
	int16_t buffer[SBUFF_SIZE];
}	sbuff_t;

static sbuff_t *sbuff;

static char osd_title[256];

static SDL_Window *window = NULL;
static uint32_t windowID = 0;
static SDL_Renderer *renderer = NULL;
static uint32_t renderer_flags = 0;
static SDL_Cursor *cursor = NULL;

typedef enum osd_vmod_e {
	VMODE_MONITOR = 0,
	VMODE_TV
} osd_vmod_t;

osd_vmod_t vmod = VMODE_TV;
static void (*vmod_callback)(void) = NULL;


static void (*keydn_callback)(void *cookie, osd_key_t *) = NULL;
static void (*keyup_callback)(void *cookie, osd_key_t *) = NULL;
static void *cookie_callback = NULL;

static void (*keydn_osd_local)(void *cookie, osd_key_t *) = NULL;
static void (*keyup_osd_local)(void *cookie, osd_key_t *) = NULL;
static void *cookie_local = NULL;

/*static osd_bitmap_t *font;

static osd_bitmap_t *ctrl_panel;
static int32_t ctrl_panel_on = 0;

static osd_bitmap_t *cpu_panel;
static int32_t cpu_panel_on = 0;*/

static size_t xngsize;

#define	FONT_W	6
#define	FONT_H	10

typedef enum {
	WID_NONE,
	WID_RESET,
	WID_THROTTLE,
	WID_SNAPSHOT,
	WID_VIDEO,
	WID_CPU_PANEL,
	WID_CASSETTE,
	WID_FLOPPY,
	WID_FREQUENCY
}	widget_id_ctrl_t;

typedef struct {
	osd_bitmap_t *bitmap;
	widget_id_ctrl_t id;
}	cookie_local_t;

/****************************************
 * forward declarations
 ****************************************/
/*static void keydn_edit(void *cookie, osd_key_t *key);
static void keyup_edit(void *cookie, osd_key_t *key);*/


/** @brief hardcoded 6x10 character generator */
static const uint8_t chargen_6x10[] = {
	0x00,  0x00,0xa8,0x00,0x88,0x00,0x88,0x00,0xa8,0x00,0x00,
	0x20,  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x21,  0x00,0x20,0x20,0x20,0x20,0x20,0x00,0x20,0x00,0x00,
	0x22,  0x00,0x50,0x50,0x50,0x00,0x00,0x00,0x00,0x00,0x00,
	0x23,  0x00,0x50,0x50,0xf8,0x50,0xf8,0x50,0x50,0x00,0x00,
	0x24,  0x00,0x20,0x70,0xa0,0x70,0x28,0x70,0x20,0x00,0x00,
	0x25,  0x00,0x48,0xa8,0x50,0x20,0x50,0xa8,0x90,0x00,0x00,
	0x26,  0x00,0x40,0xa0,0xa0,0x40,0xa8,0x90,0x68,0x00,0x00,
	0x27,  0x00,0x20,0x20,0x20,0x00,0x00,0x00,0x00,0x00,0x00,
	0x28,  0x00,0x10,0x20,0x40,0x40,0x40,0x20,0x10,0x00,0x00,
	0x29,  0x00,0x40,0x20,0x10,0x10,0x10,0x20,0x40,0x00,0x00,
	0x2a,  0x00,0x00,0x88,0x50,0xf8,0x50,0x88,0x00,0x00,0x00,
	0x2b,  0x00,0x00,0x20,0x20,0xf8,0x20,0x20,0x00,0x00,0x00,
	0x2c,  0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x20,0x40,0x00,
	0x2d,  0x00,0x00,0x00,0x00,0xf8,0x00,0x00,0x00,0x00,0x00,
	0x2e,  0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x70,0x20,0x00,
	0x2f,  0x00,0x08,0x08,0x10,0x20,0x40,0x80,0x80,0x00,0x00,
	0x30,  0x00,0x20,0x50,0x88,0x88,0x88,0x50,0x20,0x00,0x00,
	0x31,  0x00,0x20,0x60,0xa0,0x20,0x20,0x20,0xf8,0x00,0x00,
	0x32,  0x00,0x70,0x88,0x08,0x30,0x40,0x80,0xf8,0x00,0x00,
	0x33,  0x00,0xf8,0x08,0x10,0x30,0x08,0x88,0x70,0x00,0x00,
	0x34,  0x00,0x10,0x30,0x50,0x90,0xf8,0x10,0x10,0x00,0x00,
	0x35,  0x00,0xf8,0x80,0xb0,0xc8,0x08,0x88,0x70,0x00,0x00,
	0x36,  0x00,0x30,0x40,0x80,0xb0,0xc8,0x88,0x70,0x00,0x00,
	0x37,  0x00,0xf8,0x08,0x10,0x10,0x20,0x40,0x40,0x00,0x00,
	0x38,  0x00,0x70,0x88,0x88,0x70,0x88,0x88,0x70,0x00,0x00,
	0x39,  0x00,0x70,0x88,0x98,0x68,0x08,0x10,0x60,0x00,0x00,
	0x3a,  0x00,0x00,0x20,0x70,0x20,0x00,0x20,0x70,0x20,0x00,
	0x3b,  0x00,0x00,0x20,0x70,0x20,0x00,0x30,0x20,0x40,0x00,
	0x3c,  0x00,0x08,0x10,0x20,0x40,0x20,0x10,0x08,0x00,0x00,
	0x3d,  0x00,0x00,0x00,0xf8,0x00,0xf8,0x00,0x00,0x00,0x00,
	0x3e,  0x00,0x40,0x20,0x10,0x08,0x10,0x20,0x40,0x00,0x00,
	0x3f,  0x00,0x70,0x88,0x10,0x20,0x20,0x00,0x20,0x00,0x00,
	0x40,  0x00,0x70,0x88,0x98,0xa8,0xb0,0x80,0x70,0x00,0x00,
	0x41,  0x00,0x20,0x50,0x88,0x88,0xf8,0x88,0x88,0x00,0x00,
	0x42,  0x00,0xf0,0x48,0x48,0x70,0x48,0x48,0xf0,0x00,0x00,
	0x43,  0x00,0x70,0x88,0x80,0x80,0x80,0x88,0x70,0x00,0x00,
	0x44,  0x00,0xf0,0x48,0x48,0x48,0x48,0x48,0xf0,0x00,0x00,
	0x45,  0x00,0xf8,0x80,0x80,0xf0,0x80,0x80,0xf8,0x00,0x00,
	0x46,  0x00,0xf8,0x80,0x80,0xf0,0x80,0x80,0x80,0x00,0x00,
	0x47,  0x00,0x70,0x88,0x80,0x80,0x98,0x88,0x70,0x00,0x00,
	0x48,  0x00,0x88,0x88,0x88,0xf8,0x88,0x88,0x88,0x00,0x00,
	0x49,  0x00,0x70,0x20,0x20,0x20,0x20,0x20,0x70,0x00,0x00,
	0x4a,  0x00,0x38,0x10,0x10,0x10,0x10,0x90,0x60,0x00,0x00,
	0x4b,  0x00,0x88,0x90,0xa0,0xc0,0xa0,0x90,0x88,0x00,0x00,
	0x4c,  0x00,0x80,0x80,0x80,0x80,0x80,0x80,0xf8,0x00,0x00,
	0x4d,  0x00,0x88,0x88,0xd8,0xa8,0x88,0x88,0x88,0x00,0x00,
	0x4e,  0x00,0x88,0x88,0xc8,0xa8,0x98,0x88,0x88,0x00,0x00,
	0x4f,  0x00,0x70,0x88,0x88,0x88,0x88,0x88,0x70,0x00,0x00,
	0x50,  0x00,0xf0,0x88,0x88,0xf0,0x80,0x80,0x80,0x00,0x00,
	0x51,  0x00,0x70,0x88,0x88,0x88,0x88,0xa8,0x70,0x08,0x00,
	0x52,  0x00,0xf0,0x88,0x88,0xf0,0xa0,0x90,0x88,0x00,0x00,
	0x53,  0x00,0x70,0x88,0x80,0x70,0x08,0x88,0x70,0x00,0x00,
	0x54,  0x00,0xf8,0x20,0x20,0x20,0x20,0x20,0x20,0x00,0x00,
	0x55,  0x00,0x88,0x88,0x88,0x88,0x88,0x88,0x70,0x00,0x00,
	0x56,  0x00,0x88,0x88,0x88,0x50,0x50,0x50,0x20,0x00,0x00,
	0x57,  0x00,0x88,0x88,0x88,0xa8,0xa8,0xd8,0x88,0x00,0x00,
	0x58,  0x00,0x88,0x88,0x50,0x20,0x50,0x88,0x88,0x00,0x00,
	0x59,  0x00,0x88,0x88,0x50,0x20,0x20,0x20,0x20,0x00,0x00,
	0x5a,  0x00,0xf8,0x08,0x10,0x20,0x40,0x80,0xf8,0x00,0x00,
	0x5b,  0x00,0x70,0x40,0x40,0x40,0x40,0x40,0x70,0x00,0x00,
	0x5c,  0x00,0x80,0x80,0x40,0x20,0x10,0x08,0x08,0x00,0x00,
	0x5d,  0x00,0x70,0x10,0x10,0x10,0x10,0x10,0x70,0x00,0x00,
	0x5e,  0x00,0x20,0x50,0x88,0x00,0x00,0x00,0x00,0x00,0x00,
	0x5f,  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xf8,0x00,
	0x60,  0x20,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x61,  0x00,0x00,0x00,0x70,0x08,0x78,0x88,0x78,0x00,0x00,
	0x62,  0x00,0x80,0x80,0xb0,0xc8,0x88,0xc8,0xb0,0x00,0x00,
	0x63,  0x00,0x00,0x00,0x70,0x88,0x80,0x88,0x70,0x00,0x00,
	0x64,  0x00,0x08,0x08,0x68,0x98,0x88,0x98,0x68,0x00,0x00,
	0x65,  0x00,0x00,0x00,0x70,0x88,0xf8,0x80,0x70,0x00,0x00,
	0x66,  0x00,0x30,0x48,0x40,0xf0,0x40,0x40,0x40,0x00,0x00,
	0x67,  0x00,0x00,0x00,0x78,0x88,0x88,0x78,0x08,0x88,0x70,
	0x68,  0x00,0x80,0x80,0xb0,0xc8,0x88,0x88,0x88,0x00,0x00,
	0x69,  0x00,0x20,0x00,0x60,0x20,0x20,0x20,0x70,0x00,0x00,
	0x6a,  0x00,0x08,0x00,0x18,0x08,0x08,0x08,0x48,0x48,0x30,
	0x6b,  0x00,0x80,0x80,0x88,0x90,0xe0,0x90,0x88,0x00,0x00,
	0x6c,  0x00,0x60,0x20,0x20,0x20,0x20,0x20,0x70,0x00,0x00,
	0x6d,  0x00,0x00,0x00,0xd0,0xa8,0xa8,0xa8,0x88,0x00,0x00,
	0x6e,  0x00,0x00,0x00,0xb0,0xc8,0x88,0x88,0x88,0x00,0x00,
	0x6f,  0x00,0x00,0x00,0x70,0x88,0x88,0x88,0x70,0x00,0x00,
	0x70,  0x00,0x00,0x00,0xb0,0xc8,0x88,0xc8,0xb0,0x80,0x80,
	0x71,  0x00,0x00,0x00,0x68,0x98,0x88,0x98,0x68,0x08,0x08,
	0x72,  0x00,0x00,0x00,0xb0,0xc8,0x80,0x80,0x80,0x00,0x00,
	0x73,  0x00,0x00,0x00,0x70,0x80,0x70,0x08,0xf0,0x00,0x00,
	0x74,  0x00,0x40,0x40,0xf0,0x40,0x40,0x48,0x30,0x00,0x00,
	0x75,  0x00,0x00,0x00,0x88,0x88,0x88,0x98,0x68,0x00,0x00,
	0x76,  0x00,0x00,0x00,0x88,0x88,0x50,0x50,0x20,0x00,0x00,
	0x77,  0x00,0x00,0x00,0x88,0x88,0xa8,0xa8,0x50,0x00,0x00,
	0x78,  0x00,0x00,0x00,0x88,0x50,0x20,0x50,0x88,0x00,0x00,
	0x79,  0x00,0x00,0x00,0x88,0x88,0x98,0x68,0x08,0x88,0x70,
	0x7a,  0x00,0x00,0x00,0xf8,0x10,0x20,0x40,0xf8,0x00,0x00,
	0x7b,  0x00,0x18,0x20,0x10,0x60,0x10,0x20,0x18,0x00,0x00,
	0x7c,  0x00,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x00,0x00,
	0x7d,  0x00,0x60,0x10,0x20,0x18,0x20,0x10,0x60,0x00,0x00,
	0x7e,  0x00,0x48,0xa8,0x90,0x00,0x00,0x00,0x00,0x00,0x00,
	0xa0,  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0xa1,  0x00,0x20,0x00,0x20,0x20,0x20,0x20,0x20,0x00,0x00,
	0xa2,  0x00,0x00,0x20,0x78,0xa0,0xa0,0xa0,0x78,0x20,0x00,
	0xa3,  0x00,0x30,0x48,0x40,0xe0,0x40,0x48,0xb0,0x00,0x00,
	0xa4,  0x00,0x00,0x00,0x88,0x70,0x50,0x70,0x88,0x00,0x00,
	0xa5,  0x00,0x88,0x88,0x50,0x20,0xf8,0x20,0x20,0x20,0x00,
	0xa6,  0x00,0x20,0x20,0x20,0x00,0x20,0x20,0x20,0x00,0x00,
	0xa7,  0x00,0x70,0x80,0xe0,0x90,0x48,0x38,0x08,0x70,0x00,
	0xa8,  0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0xa9,  0x00,0x70,0x88,0xa8,0xc8,0xa8,0x88,0x70,0x00,0x00,
	0xaa,  0x00,0x38,0x48,0x58,0x28,0x00,0x78,0x00,0x00,0x00,
	0xab,  0x00,0x00,0x00,0x24,0x48,0x90,0x48,0x24,0x00,0x00,
	0xac,  0x00,0x00,0x00,0x00,0x78,0x08,0x00,0x00,0x00,0x00,
	0xad,  0x00,0x00,0x00,0x00,0x78,0x00,0x00,0x00,0x00,0x00,
	0xae,  0x00,0x70,0x88,0xe8,0xc8,0xc8,0x88,0x70,0x00,0x00,
	0xaf,  0xf8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0xb0,  0x00,0x20,0x50,0x20,0x00,0x00,0x00,0x00,0x00,0x00,
	0xb1,  0x00,0x00,0x20,0x20,0xf8,0x20,0x20,0xf8,0x00,0x00,
	0xb2,  0x30,0x48,0x10,0x20,0x78,0x00,0x00,0x00,0x00,0x00,
	0xb3,  0x70,0x08,0x30,0x08,0x70,0x00,0x00,0x00,0x00,0x00,
	0xb4,  0x10,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0xb5,  0x00,0x00,0x00,0x88,0x88,0x88,0xc8,0xb0,0x80,0x00,
	0xb6,  0x00,0x78,0xe8,0xe8,0x68,0x28,0x28,0x28,0x00,0x00,
	0xb7,  0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,
	0xb8,  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x20,
	0xb9,  0x20,0x60,0x20,0x20,0x70,0x00,0x00,0x00,0x00,0x00,
	0xba,  0x00,0x30,0x48,0x48,0x30,0x00,0x78,0x00,0x00,0x00,
	0xbb,  0x00,0x00,0x00,0x90,0x48,0x24,0x48,0x90,0x00,0x00,
	0xbc,  0x40,0xc0,0x40,0x40,0xe4,0x0c,0x14,0x3c,0x04,0x00,
	0xbd,  0x40,0xc0,0x40,0x40,0xe8,0x14,0x04,0x08,0x1c,0x00,
	0xbe,  0xc0,0x20,0x40,0x20,0xc8,0x18,0x28,0x78,0x08,0x00,
	0xbf,  0x00,0x20,0x00,0x20,0x20,0x40,0x88,0x70,0x00,0x00,
	0xc0,  0x40,0x20,0x70,0x88,0x88,0xf8,0x88,0x88,0x00,0x00,
	0xc1,  0x10,0x20,0x70,0x88,0x88,0xf8,0x88,0x88,0x00,0x00,
	0xc2,  0x20,0x50,0x70,0x88,0x88,0xf8,0x88,0x88,0x00,0x00,
	0xc3,  0x48,0xb0,0x70,0x88,0x88,0xf8,0x88,0x88,0x00,0x00,
	0xc4,  0x50,0x00,0x70,0x88,0x88,0xf8,0x88,0x88,0x00,0x00,
	0xc5,  0x20,0x50,0x70,0x88,0x88,0xf8,0x88,0x88,0x00,0x00,
	0xc6,  0x00,0x3c,0x50,0x90,0x9c,0xf0,0x90,0x9c,0x00,0x00,
	0xc7,  0x00,0x70,0x88,0x80,0x80,0x80,0x88,0x70,0x20,0x40,
	0xc8,  0x40,0xf8,0x80,0x80,0xf0,0x80,0x80,0xf8,0x00,0x00,
	0xc9,  0x10,0xf8,0x80,0x80,0xf0,0x80,0x80,0xf8,0x00,0x00,
	0xca,  0x20,0xf8,0x80,0x80,0xf0,0x80,0x80,0xf8,0x00,0x00,
	0xcb,  0x50,0xf8,0x80,0x80,0xf0,0x80,0x80,0xf8,0x00,0x00,
	0xcc,  0x40,0x20,0x70,0x20,0x20,0x20,0x20,0x70,0x00,0x00,
	0xcd,  0x10,0x20,0x70,0x20,0x20,0x20,0x20,0x70,0x00,0x00,
	0xce,  0x20,0x50,0x70,0x20,0x20,0x20,0x20,0x70,0x00,0x00,
	0xcf,  0x50,0x00,0x70,0x20,0x20,0x20,0x20,0x70,0x00,0x00,
	0xd0,  0x00,0xf0,0x48,0x48,0xe8,0x48,0x48,0xf0,0x00,0x00,
	0xd1,  0x28,0x50,0x88,0xc8,0xa8,0x98,0x88,0x88,0x00,0x00,
	0xd2,  0x40,0x20,0x70,0x88,0x88,0x88,0x88,0x70,0x00,0x00,
	0xd3,  0x10,0x20,0x70,0x88,0x88,0x88,0x88,0x70,0x00,0x00,
	0xd4,  0x20,0x50,0x70,0x88,0x88,0x88,0x88,0x70,0x00,0x00,
	0xd5,  0x28,0x50,0x70,0x88,0x88,0x88,0x88,0x70,0x00,0x00,
	0xd6,  0x50,0x00,0x70,0x88,0x88,0x88,0x88,0x70,0x00,0x00,
	0xd7,  0x00,0x00,0x00,0x88,0x50,0x20,0x50,0x88,0x00,0x00,
	0xd8,  0x00,0x70,0x98,0x98,0xa8,0xc8,0xc8,0x70,0x00,0x00,
	0xd9,  0x40,0x20,0x88,0x88,0x88,0x88,0x88,0x70,0x00,0x00,
	0xda,  0x10,0x20,0x88,0x88,0x88,0x88,0x88,0x70,0x00,0x00,
	0xdb,  0x20,0x50,0x00,0x88,0x88,0x88,0x88,0x70,0x00,0x00,
	0xdc,  0x50,0x00,0x88,0x88,0x88,0x88,0x88,0x70,0x00,0x00,
	0xdd,  0x10,0x20,0x88,0x88,0x50,0x20,0x20,0x20,0x00,0x00,
	0xde,  0x00,0x80,0xf0,0x88,0xf0,0x80,0x80,0x80,0x00,0x00,
	0xdf,  0x00,0x70,0x88,0x90,0xa0,0x90,0x88,0xb0,0x00,0x00,
	0xe0,  0x40,0x20,0x00,0x70,0x08,0x78,0x88,0x78,0x00,0x00,
	0xe1,  0x10,0x20,0x00,0x70,0x08,0x78,0x88,0x78,0x00,0x00,
	0xe2,  0x20,0x50,0x00,0x70,0x08,0x78,0x88,0x78,0x00,0x00,
	0xe3,  0x28,0x50,0x00,0x70,0x08,0x78,0x88,0x78,0x00,0x00,
	0xe4,  0x00,0x50,0x00,0x70,0x08,0x78,0x88,0x78,0x00,0x00,
	0xe5,  0x20,0x50,0x20,0x70,0x08,0x78,0x88,0x78,0x00,0x00,
	0xe6,  0x00,0x00,0x00,0x78,0x14,0x7c,0x90,0x7c,0x00,0x00,
	0xe7,  0x00,0x00,0x00,0x70,0x88,0x80,0x88,0x70,0x20,0x40,
	0xe8,  0x40,0x20,0x00,0x70,0x88,0xf8,0x80,0x70,0x00,0x00,
	0xe9,  0x10,0x20,0x00,0x70,0x88,0xf8,0x80,0x70,0x00,0x00,
	0xea,  0x20,0x50,0x00,0x70,0x88,0xf8,0x80,0x70,0x00,0x00,
	0xeb,  0x00,0x50,0x00,0x70,0x88,0xf8,0x80,0x70,0x00,0x00,
	0xec,  0x40,0x20,0x00,0x60,0x20,0x20,0x20,0x70,0x00,0x00,
	0xed,  0x20,0x40,0x00,0x60,0x20,0x20,0x20,0x70,0x00,0x00,
	0xee,  0x20,0x50,0x00,0x60,0x20,0x20,0x20,0x70,0x00,0x00,
	0xef,  0x00,0x50,0x00,0x60,0x20,0x20,0x20,0x70,0x00,0x00,
	0xf0,  0x00,0xc0,0x30,0x70,0x88,0x88,0x88,0x70,0x00,0x00,
	0xf1,  0x28,0x50,0x00,0xb0,0xc8,0x88,0x88,0x88,0x00,0x00,
	0xf2,  0x40,0x20,0x00,0x70,0x88,0x88,0x88,0x70,0x00,0x00,
	0xf3,  0x10,0x20,0x00,0x70,0x88,0x88,0x88,0x70,0x00,0x00,
	0xf4,  0x20,0x50,0x00,0x70,0x88,0x88,0x88,0x70,0x00,0x00,
	0xf5,  0x28,0x50,0x00,0x70,0x88,0x88,0x88,0x70,0x00,0x00,
	0xf6,  0x00,0x50,0x00,0x70,0x88,0x88,0x88,0x70,0x00,0x00,
	0xf7,  0x00,0x00,0x20,0x00,0xf8,0x00,0x20,0x00,0x00,0x00,
	0xf8,  0x00,0x00,0x00,0x78,0x98,0xa8,0xc8,0xf0,0x00,0x00,
	0xf9,  0x40,0x20,0x00,0x88,0x88,0x88,0x98,0x68,0x00,0x00,
	0xfa,  0x10,0x20,0x00,0x88,0x88,0x88,0x98,0x68,0x00,0x00,
	0xfb,  0x20,0x50,0x00,0x88,0x88,0x88,0x98,0x68,0x00,0x00,
	0xfc,  0x00,0x50,0x00,0x88,0x88,0x88,0x98,0x68,0x00,0x00,
	0xfd,  0x00,0x10,0x20,0x88,0x88,0x98,0x68,0x08,0x88,0x70,
	0xfe,  0x00,0x00,0x80,0xf0,0x88,0x88,0x88,0xf0,0x80,0x80,
	0xff,  0x00,0x50,0x00,0x88,0x88,0x98,0x68,0x08,0x88,0x70
};

#define	FRAMESKIP_LEVELS 12

#define	UCLOCKS_PER_SEC 1000000

typedef long uclock_t;

uclock_t uclock(void)
{
	static uclock_t init_sec = 0;
	struct timeval tv;
	gettimeofday(&tv, 0);
	if (0 == init_sec)
		init_sec = tv.tv_sec;
	return (uclock_t)UCLOCKS_PER_SEC * (tv.tv_sec - init_sec) +
		tv.tv_usec;
}

/**
 * @brief exit after printing some message to stderr
 * @param fmt format string and optional parameters following
 */
void osd_die(const char *fmt, ...)
{
	va_list ap;

	va_start(ap, fmt);
	vfprintf(stderr, fmt, ap);
	va_end(ap);
	exit(1);
}

static const char *humanize(size_t size)
{
	static char buff[32];
	size_t rem;
	if (size < 1024) {
		snprintf(buff, sizeof(buff), "%u", (unsigned)size);
		return buff;
	}
	size = (size + 1023) / 1024;
	if (size < 1024) {
		snprintf(buff, sizeof(buff), "%uKB", (unsigned)size);
		return buff;
	}
	rem = 100 * (size % 1024) / 1024;;
	size = size / 1024;
	snprintf(buff, sizeof(buff), "%u.%02uMB", (unsigned)size, (unsigned)rem);
	return buff;
}

/**
 * @brief create a cursor pixel and mask array from a string
 *
 * Pixel values are defined using one of 4 characters:
 *  .  pixel is clear, mask is clear (no change)
 *  x  pixel is set, mask is set (solid pixel)
 *  #  pixel is clear, mask is set (transparency)
 *  o  pixel is set, mask is clear (xor)
 *
 * @param pix pointer to pixel array
 * @param msk pointer to mask array
 * @param w width in pixels
 * @param h height in pixels
 * @param src string defining the cursor
 */
static int32_t make_cursor(unsigned char *pix, unsigned char *msk,
	int32_t w, int32_t h, const char *src)
{
	int32_t x, y;

	for (y = 0; y < h; y++) {
		*pix = 0;
		*msk = 0;
		for (x = 0; x < w; x++) {
			switch (*src++) {
			case '.':	/* both 0 */
				break;
			case 'x':
				*pix |= 0x80 >> (x % 8);
				*msk |= 0x80 >> (x % 8);
				break;
			case '#':
				*msk |= 0x80 >> (x % 8);
				break;
			case 'o':
				*pix |= 0x80 >> (x % 8);
				break;
			}
			if (7 == (x & 7)) {
				pix++;
				*pix = 0;
				msk++;
				*msk = 0;
			}
		}
		if (w & 7) {
			pix++;
			msk++;
		}
	}
	return 0;
}

void osd_align_colors_to_mode(uint8_t *r, uint8_t *g, uint8_t *b)
{
	if (VMODE_TV == vmod) {
		*r = *r * 2 + 90;
		*g = *g * 2 + 90;
		*b = *b * 2 + 90;
	}
	else {
		*r = *r * 4;
		*g = *g * 4;
		*b = *b * 4;
	}
}

int32_t osd_open_display(int32_t w, int32_t h, const char *title, void (*update_vmode)(void))
{
	uint8_t bits[128];
	uint8_t mask[128];
	SDL_RendererInfo info;
	/*uint32_t bg, rmask, gmask, bmask, amask;
	uint32_t flags;
	uint32_t i, w, h;*/

	if (NULL != title)
		snprintf(osd_title, sizeof(osd_title), "%s", title);

	/* initial scale 2 */
	window = SDL_CreateWindow(osd_title,
		SDL_WINDOWPOS_UNDEFINED,
		SDL_WINDOWPOS_UNDEFINED,
		w*2, h*2,
		SDL_WINDOW_RESIZABLE);
	if (NULL == window) {
		osd_die("SDL_CreateWindow() failed\n");
	}
	windowID = SDL_GetWindowID(window);

	renderer = SDL_CreateRenderer(window, -1, 0);
	if (NULL == renderer) {
		osd_die("SDL_CreateRenderer() failed\n");
	}
	SDL_GetRendererInfo(renderer, &info);
	renderer_flags = info.flags;
	if ((renderer_flags & SDL_RENDERER_ACCELERATED) == 0)
		vmod = VMODE_MONITOR;
	vmod_callback = update_vmode;

	if (VMODE_MONITOR == vmod) {
		SDL_RenderSetScale(renderer, 2.0, 2.0);
	}
	else {
		SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "linear");
		SDL_RenderSetLogicalSize(renderer, w, h);
	}

	/* clear screen */
	SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);
	SDL_RenderClear(renderer);
	SDL_RenderPresent(renderer);

	if (osd_bitmap_alloc(&frame, window, w, h))
		osd_die("osd_bitmap_alloc(&frame,..) failed\n");

	if (osd_bitmap_create_texture(frame, renderer))
		osd_die("osd_bitmap_create_texture(frame, renderer) failed\n");


	/*osd_bitmap_alloc(&font, 16 * FONT_W, 16 * FONT_H, 32);
	for (i = 0, src = chargen_6x10; i < 256; i++) {
		if (i != *src)
			continue;
		src++;
		osd_render_font(font, src, i, 1, FONT_W, FONT_H, FONT_W, FONT_H);
		src += FONT_H;
	}*/

	/*osd_bitmap_alloc(&ctrl_panel, width, 20, 32);
	ctrl_panel->x = 0;
	ctrl_panel->y = 0;
	osd_bitmap_fillrect(ctrl_panel, 0, 0, ctrl_panel->w, ctrl_panel->h,
		osd_color(ctrl_panel, 0xdf, 0xdf, 0xdf));

	osd_bitmap_alloc(&cpu_panel, width, 28, 32);
	cpu_panel->x = 0;
	cpu_panel->y = screen->h - cpu_panel->h;
	osd_bitmap_fillrect(cpu_panel, 0, 0, cpu_panel->w, cpu_panel->h,
		osd_color(cpu_panel, 0xdf, 0xdf, 0xdf));

	x = 4;
	y = 2;
	w = 6;
	h = 16;
	osd_widget_alloc(ctrl_panel, x, y, 7*w, h, 0xef, 0x3f, 0x3f, BT_PUSH, WID_RESET, "Reset");
	x += 7*w + 2;
	x += 4*w + 2;
	x += 4*w + 2;
	x += 4*w + 2;
	x += 4*w + 2;
	osd_widget_alloc(ctrl_panel, x, y, 11*w, h, 0xbf, 0xbf, 0xbf, BT_PUSH, WID_SNAPSHOT, "Snapshot");
	x += 11*w + 2;
	osd_widget_alloc(ctrl_panel, x, y, 11*w, h, 0xbf, 0xbf, 0xbf, BT_CHECK, WID_THROTTLE, "Throttle");
	x += 11*w + 2;
	osd_widget_alloc(ctrl_panel, x, y, 11*w, h, 0xbf, 0xbf, 0xbf, BT_CHECK, WID_VIDEO, "Video");
	x += 11*w + 2;
	osd_widget_alloc(ctrl_panel, x, y, 11*w, h, 0xbf, 0xbf, 0xbf, BT_CHECK, WID_CPU_PANEL, "CPU panel");
	x += 11*w + 2;
#if	0
	osd_widget_alloc(ctrl_panel, x, y, 11*w, h, 0xbf, 0xbf, 0xbf, BT_PUSH, WID_CASSETTE, "Cassette");
	x += 11*w + 2;
	osd_widget_alloc(ctrl_panel, x, y, 11*w, h, 0xbf, 0xbf, 0xbf, BT_PUSH, WID_FLOPPY, "Floppy");
	x += 11*w + 2;
#endif
	if (width > x) {
		x = width - 30*w;
		osd_widget_alloc(ctrl_panel, x, y, 12*w, h, 0xf0, 0xf0, 0xf0, BT_EDIT, WID_CASSETTE, "");

		x = width - 13*w;
		osd_widget_alloc(ctrl_panel, x, y, 12*w, h, 0xbf, 0xbf, 0xbf, BT_STATIC, WID_FREQUENCY, "1 MHz");
	}

	osd_widget_active(ctrl_panel, WID_THROTTLE, throttle);
	osd_widget_active(ctrl_panel, WID_VIDEO, start_video);
	osd_widget_active(ctrl_panel, WID_CPU_PANEL, cpu_panel_on);

	sys_cpu_panel_init(cpu_panel);
	osd_bitmap_update(cpu_panel);*/

	/* fill rect */
	/*bg = SDL_MapRGB(screen->format, 0, 0, 0);
	SDL_FillRect(screen, NULL, bg);
	SDL_UpdateRect(screen, 0, 0, width, height);*/

	make_cursor(bits, mask, 12, 16,
		"xx.........." \
		"x#x........." \
		"x##x........" \
		"x###x......." \
		"x####x......" \
		"x#####x....." \
		"x######x...." \
		"x#######x..." \
		"x########x.." \
		"x#####xxxxx." \
		"x##x##x....." \
		"x#x.x##x...." \
		"xx..x##x...." \
		"x....x##x..." \
		".....x##x..." \
		"......xx....");

	cursor = SDL_CreateCursor(bits, mask, 12, 16, 0, 0);
	SDL_SetCursor(cursor);
	SDL_ShowCursor(1);

	return 0;
}

int32_t osd_close_display(void)
{
	if (NULL != window) {
		SDL_DestroyWindow(window);
		window = NULL;
	}
	/* TODO screen */
	if (NULL != cursor) {
		SDL_FreeCursor(cursor);
		cursor = NULL;
	}
	osd_bitmap_free(&frame);
	/*osd_bitmap_free(&ctrl_panel);
	osd_bitmap_free(&cpu_panel);*/

	return 0;
}



int32_t osd_keys(SDL_KeyboardEvent *key)
{
	/* RCTRL is for OSD keys */
	if (0 == (key->keysym.mod & KMOD_RCTRL))
		return 0;

	/*if (key->keysym.sym == SDLK_RETURN) {
		if (SDL_WM_ToggleFullScreen(screen))
			fullscreen ^= 1;
		SDL_ShowCursor(fullscreen ^ 1);
		return 1;
	}*/

	/* OSD+DELETE = toggle throttle
	if (key->keysym.sym == SDLK_DELETE ||
		key->keysym.sym == SDLK_KP_PERIOD) {
		throttle ^= 1;
		osd_widget_active(ctrl_panel, WID_THROTTLE, throttle);
		return 1;
	}*/

	/* OSD+INSERT = grab/release input */
	if (key->keysym.sym == SDLK_INSERT ||
		key->keysym.sym == SDLK_KP_0) {
		if (SDL_GetRelativeMouseMode()) {
			SDL_SetRelativeMouseMode(SDL_FALSE);
		} else {
			SDL_SetRelativeMouseMode(SDL_TRUE);
		}
		return 1;
	}

	/* OSD+SYSREQ = toggle CPU panel
	if (key->keysym.sym == SDLK_HOME ||
		key->keysym.sym == SDLK_KP_7) {
		cpu_panel_on ^= 1;
		osd_widget_active(ctrl_panel, WID_CPU_PANEL, cpu_panel_on);
		return 1;
	}*/


	/* OSD+END = exit the hard way */
	if (key->keysym.sym == SDLK_END ||
		key->keysym.sym == SDLK_KP_1) {
		exit(1);
		return 1;
	}
	return 0;
}

int32_t osd_update(int32_t skip_this_frame)
{
	/*SDL_Rect dst;*/
	SDL_Event ev;
	osd_key_t key;
	/*int32_t rc;*/
	int32_t new_width, new_height;
	int32_t main_resized = 0;

	while (SDL_PollEvent(&ev)) {
		switch (ev.type) {
		case SDL_WINDOWEVENT:
			if (ev.window.event == SDL_WINDOWEVENT_RESIZED) {
                new_width = ev.window.data1;
                new_height = ev.window.data2;
				if (ev.window.windowID == windowID) {
					main_resized = 1;
				}
				/* TODO ?
				else {
				}*/
			}
			break;

		case SDL_KEYDOWN:
			osd_keys(&ev.key);
			key.sym = ev.key.keysym.sym;
			key.mod = ev.key.keysym.mod;
			if ((key.mod & (KMOD_LSHIFT | KMOD_RSHIFT) != 0) &&
				key.sym >= 'a' && key.sym <= 'z')
				key.sym -= 32;
			if (keydn_osd_local) {
				(*keydn_osd_local)(cookie_local, &key);
			} else if (keydn_callback) {
				(*keydn_callback)(cookie_callback, &key);
			}
			break;

		case SDL_KEYUP:
			key.sym = ev.key.keysym.sym;
			key.mod = ev.key.keysym.mod;
			if ((key.mod & (KMOD_LSHIFT | KMOD_RSHIFT) != 0) &&
				key.sym >= 'a' && key.sym <= 'z')
				key.sym -= 32;
			if (keyup_osd_local) {
				(*keyup_osd_local)(cookie_local, &key);
			} else if (keyup_callback) {
				(*keyup_callback)(cookie_callback, &key);
			}
			break;

		case SDL_MOUSEMOTION:
			mousex = ev.motion.x;
			mousey = ev.motion.y;
			mouseb = (mouseb & ~1) | (ev.motion.state & 1);
			break;

		/*case SDL_MOUSEBUTTONDOWN:
			mouseb |= 1 | (1 << ev.button.button);
			if (3 == ev.button.button)
				ctrl_panel_on ^= 1;
			if (!ctrl_panel_on)
				break;

			rc = osd_hittest(ctrl_panel, mousex, mousey, mouseb);
			switch (rc) {
			case WID_RESET:
				sys_reset(SYS_RST);
				break;
			case WID_THROTTLE:
				throttle ^= 1;
				osd_widget_active(ctrl_panel, WID_THROTTLE, throttle);
				break;
			case WID_SNAPSHOT:
				osd_save_snapshot();
				break;
			case WID_VIDEO:
				break;
			case WID_CPU_PANEL:
				cpu_panel_on ^= 1;
				osd_widget_active(ctrl_panel, WID_CPU_PANEL, cpu_panel_on);
				break;

			case WID_CASSETTE:
				if (NULL == keydn_osd_local) {
					static cookie_local_t cookie;

					cookie.bitmap = ctrl_panel;
					cookie.id = WID_CASSETTE;
					keydn_osd_local = keydn_edit;
					keyup_osd_local = keyup_edit;
					cookie_local = (void *)&cookie;
					osd_widget_active(ctrl_panel, WID_CASSETTE, 1);
				}
				break;
			}
			break;

		case SDL_MOUSEBUTTONUP:
			mouseb &= ~(1 | (1 << ev.button.button));
			if (ctrl_panel_on)
				osd_hittest(ctrl_panel, mousex, mousey, mouseb);
			break;*/

		case SDL_QUIT:
			return -1;
		}
	}

	/*if (ctrl_panel_on)
		osd_hittest(ctrl_panel, mousex, mousey, mouseb);*/

	if (0 == skip_this_frame) {
		/* TODO
		if (ctrl_panel_on) {
			osd_blit(NULL, ctrl_panel, 0, 0, ctrl_panel->w, ctrl_panel->h, ctrl_panel->x, ctrl_panel->y);
			dst.x = ctrl_panel->x;
			dst.y = ctrl_panel->y;
			dst.w = ctrl_panel->w;
			dst.h = ctrl_panel->h;
			osd_bitmap_dirty(frame, &dst);
		}*/
		/* TODO
		if (cpu_panel_on) {
			sys_cpu_panel_update(cpu_panel);
			osd_hittest(cpu_panel, mousex, mousey, mouseb);
			osd_blit(NULL, cpu_panel, 0, 0, cpu_panel->w, cpu_panel->h, cpu_panel->x, cpu_panel->y);
			dst.x = cpu_panel->x;
			dst.y = cpu_panel->y;
			dst.w = cpu_panel->w;
			dst.h = cpu_panel->h;
			osd_bitmap_dirty(frame, &dst);
		}*/

		if (main_resized) {
			/* played around with values > 1 but then we see strange scaling of chars */
			#define SUBSCALE 1.0
			if (VMODE_MONITOR == vmod) {
				int32_t scalex = (int32_t)SUBSCALE * new_width / frame->surface->w;
				int32_t scaley = (int32_t)SUBSCALE * new_height / frame->surface->h;
				float scale = scalex < scaley ? 
					((float) scalex / SUBSCALE) : ((float) scaley / SUBSCALE);
				SDL_Rect rect_viewport;

				if (scale < 1)
					scale = 1;
				SDL_RenderSetScale(renderer, scale, scale);

				rect_viewport.x = (new_width - frame->surface->w * scale) / (2 * scale);
				rect_viewport.y = (new_height - frame->surface->h * scale) / (2 * scale);
				rect_viewport.w = frame->surface->w;
				rect_viewport.h = frame->surface->h;

				SDL_RenderSetViewport(renderer, &rect_viewport);
			}
		}
		SDL_RenderClear(renderer);
		osd_bitmap_render(frame, renderer);
		SDL_RenderPresent(renderer);
	}

	return 0;
}

/*static char *insert_char(char *src, int32_t offs, int32_t ch)
{
	int32_t len = src ? strlen(src) : 0;
	char *dst;

	if (0 == len) {
		dst = calloc(2, sizeof(char));
		dst[0] = ch;
		return dst;
	}
	if (offs < len) {
		dst = realloc(src, len + 2);
		memmove(src + offs + 1, src + offs, len - offs);
		dst[offs] = ch;
		return dst;
	}
	dst = realloc(src, len + 2);
	dst[len + 0] = ch;
	dst[len + 1] = '\0';
	return dst;
}

static char *delete_char(char *src, int32_t offs)
{
	int32_t len = src ? strlen(src) : 0;

	if (0 == len)
		return src;
	if (offs < len) {
		memmove(src + offs, src + offs + 1, len - offs);
		return src;
	}
	return src;
}*/

/*static void keydn_edit(void *cookie, osd_key_t *key)
{
	cookie_local_t *c = (cookie_local_t *)cookie;
	osd_widget_t *e;
	int32_t len, w;

	if (NULL == c)
		return;
	e = osd_widget_find(c->bitmap, c->id);
	len = e->text ? strlen(e->text) : 0;
	w = e->cwidth;

	switch (key->sym) {
	case 13:
		keydn_osd_local = NULL;
		keyup_osd_local = NULL;
		cookie_local = NULL;
		osd_widget_active(c->bitmap, c->id, 0);
		return;
	default:
		if (key->sym < ' ')
			break;
		e->text = insert_char(e->text, e->cursor, key->sym);
		e->cursor++;
		break;
	}
	switch (key->sym) {
	case SDLK_HOME:
		e->cursor = 0;
		e->offset = 0;
		break;

	case SDLK_END:
		e->cursor = len;
		break;

	case SDLK_LEFT:
		if (e->cursor > 0)
			e->cursor--;
		break;

	case SDLK_RIGHT:
		if (e->cursor < len)
			e->cursor++;
		break;

	case SDLK_BACKSPACE:
		if (0 == e->cursor)
			break;
		e->cursor--;
		e->text = delete_char(e->text, e->cursor);
		break;

	case SDLK_DELETE:
		e->text = delete_char(e->text, e->cursor);
		break;
	}
	if (e->cursor < e->offset)
		e->offset = e->cursor;
	if (e->cursor - e->offset >= w - 1)
		e->offset = e->cursor - w + 1;
}

static void keyup_edit(void *cookie, osd_key_t *key)
{
}*/

const char *osd_key_name(osd_key_t *key)
{
	switch (key->sym) {
	case SDLK_BACKSPACE:		return "BACKSPACE";
	case SDLK_TAB:			return "TAB";
	case SDLK_CLEAR:		return "CLEAR";
	case SDLK_RETURN:		return "RETURN";
	case SDLK_PAUSE:		return "PAUSE";
	case SDLK_ESCAPE:		return "ESCAPE";
	case SDLK_SPACE:		return "SPACE";
	case SDLK_EXCLAIM:		return "EXCLAIM";
	case SDLK_QUOTEDBL:		return "QUOTEDBL";
	case SDLK_HASH:			return "HASH";
	case SDLK_DOLLAR:		return "DOLLAR";
	case SDLK_AMPERSAND:		return "AMPERSAND";
	case SDLK_QUOTE:		return "QUOTE";
	case SDLK_LEFTPAREN:		return "LEFTPAREN";
	case SDLK_RIGHTPAREN:		return "RIGHTPAREN";
	case SDLK_ASTERISK:		return "ASTERISK";
	case SDLK_PLUS:			return "PLUS";
	case SDLK_COMMA:		return "COMMA";
	case SDLK_MINUS:		return "MINUS";
	case SDLK_PERIOD:		return "PERIOD";
	case SDLK_SLASH:		return "SLASH";
	case SDLK_0:			return "0";
	case SDLK_1:			return "1";
	case SDLK_2:			return "2";
	case SDLK_3:			return "3";
	case SDLK_4:			return "4";
	case SDLK_5:			return "5";
	case SDLK_6:			return "6";
	case SDLK_7:			return "7";
	case SDLK_8:			return "8";
	case SDLK_9:			return "9";
	case SDLK_COLON:		return "COLON";
	case SDLK_SEMICOLON:		return "SEMICOLON";
	case SDLK_LESS:			return "LESS";
	case SDLK_EQUALS:		return "EQUALS";
	case SDLK_GREATER:		return "GREATER";
	case SDLK_QUESTION:		return "QUESTION";
	case SDLK_AT:			return "AT";
	/* Skip uppercase letters */
	case SDLK_LEFTBRACKET:		return "LEFTBRACKET";
	case SDLK_BACKSLASH:		return "BACKSLASH";
	case SDLK_RIGHTBRACKET:		return "RIGHTBRACKET";
	case SDLK_CARET:		return "CARET";
	case SDLK_UNDERSCORE:		return "UNDERSCORE";
	case SDLK_BACKQUOTE:		return "BACKQUOTE";
	case SDLK_a:			return "a";
	case SDLK_b:			return "b";
	case SDLK_c:			return "c";
	case SDLK_d:			return "d";
	case SDLK_e:			return "e";
	case SDLK_f:			return "f";
	case SDLK_g:			return "g";
	case SDLK_h:			return "h";
	case SDLK_i:			return "i";
	case SDLK_j:			return "j";
	case SDLK_k:			return "k";
	case SDLK_l:			return "l";
	case SDLK_m:			return "m";
	case SDLK_n:			return "n";
	case SDLK_o:			return "o";
	case SDLK_p:			return "p";
	case SDLK_q:			return "q";
	case SDLK_r:			return "r";
	case SDLK_s:			return "s";
	case SDLK_t:			return "t";
	case SDLK_u:			return "u";
	case SDLK_v:			return "v";
	case SDLK_w:			return "w";
	case SDLK_x:			return "x";
	case SDLK_y:			return "y";
	case SDLK_z:			return "z";
	case SDLK_DELETE:		return "DELETE";
	/* End of ASCII mapped keysyms */

	/* Numeric keypad */
	case SDLK_KP_0:			return "KP_0";
	case SDLK_KP_1:			return "KP_1";
	case SDLK_KP_2:			return "KP_2";
	case SDLK_KP_3:			return "KP_3";
	case SDLK_KP_4:			return "KP_4";
	case SDLK_KP_5:			return "KP_5";
	case SDLK_KP_6:			return "KP_6";
	case SDLK_KP_7:			return "KP_7";
	case SDLK_KP_8:			return "KP_8";
	case SDLK_KP_9:			return "KP_9";
	case SDLK_KP_PERIOD:		return "KP_PERIOD";
	case SDLK_KP_DIVIDE:		return "KP_DIVIDE";
	case SDLK_KP_MULTIPLY:		return "KP_MULTIPLY";
	case SDLK_KP_MINUS:		return "KP_MINUS";
	case SDLK_KP_PLUS:		return "KP_PLUS";
	case SDLK_KP_ENTER:		return "KP_ENTER";
	case SDLK_KP_EQUALS:		return "KP_EQUALS";

	/* Arrows + Home/End pad */
	case SDLK_UP:			return "UP";
	case SDLK_DOWN:			return "DOWN";
	case SDLK_RIGHT:		return "RIGHT";
	case SDLK_LEFT:			return "LEFT";
	case SDLK_INSERT:		return "INSERT";
	case SDLK_HOME:			return "HOME";
	case SDLK_END:			return "END";
	case SDLK_PAGEUP:		return "PAGEUP";
	case SDLK_PAGEDOWN:		return "PAGEDOWN";

	/* Function keys */
	case SDLK_F1:			return "F1";
	case SDLK_F2:			return "F2";
	case SDLK_F3:			return "F3";
	case SDLK_F4:			return "F4";
	case SDLK_F5:			return "F5";
	case SDLK_F6:			return "F6";
	case SDLK_F7:			return "F7";
	case SDLK_F8:			return "F8";
	case SDLK_F9:			return "F9";
	case SDLK_F10:			return "F10";
	case SDLK_F11:			return "F11";
	case SDLK_F12:			return "F12";
	case SDLK_F13:			return "F13";
	case SDLK_F14:			return "F14";
	case SDLK_F15:			return "F15";

	/* Key state modifier keys */
	case SDLK_CAPSLOCK:		return "CAPSLOCK";
	case SDLK_RSHIFT:		return "RSHIFT";
	case SDLK_LSHIFT:		return "LSHIFT";
	case SDLK_RCTRL:		return "RCTRL";
	case SDLK_LCTRL:		return "LCTRL";
	case SDLK_RALT:			return "RALT";
	case SDLK_LALT:			return "LALT";
	case SDLK_MODE:			return "MODE";

	/* Miscellaneous function keys */
	case SDLK_HELP:			return "HELP";
	case SDLK_SYSREQ:		return "SYSREQ";
	case SDLK_MENU:			return "MENU";
	case SDLK_POWER:		return "POWER";
	case SDLK_UNDO:			return "UNDO";
	}
	return "UNKNOWN";
}

int32_t osd_mousex(void)
{
	return mousex;
}

int32_t osd_mousey(void)
{
	return mousey;
}

int32_t osd_mouseb(void)
{
	return mouseb;
}

uint32_t osd_get_sample_rate(void)
{
	return sample_rate;
}

void osd_set_sample_rate(uint32_t rate)
{
	sample_rate = rate;
}

void osd_set_refresh_rate(double rate)
{
	refresh_rate = rate;
}

uint32_t osd_update_audio_stream(int16_t *stream)
{
	sbuff_t *sb = (sbuff_t *)sbuff;
	int16_t *src, *dst;
	int32_t size, copy;

	if (NULL == sb)
		return 0;

	SDL_LockAudio();
	src = (int16_t *)stream;
	dst = sb->buffer + sb->head;
	size = sample_rate / refresh_rate;
	copy = sb->size - sb->head;
	sb->head += size;
	if (copy > size)
		copy = size;
	if (sb->head >= sb->size)
		sb->head -= sb->size;
	if (copy > 0) {
		memcpy(dst, src, copy * sizeof(*dst));
		src += copy;
		copy = size - copy;
	}
	if (copy > 0) {
		dst = sb->buffer;
		memcpy(dst, src, copy * sizeof(*dst));
	}
	SDL_UnlockAudio();

	return size;
}

void osd_flush_audio_stream(void *userdata, uint8_t *stream, int32_t len)
{
	sbuff_t *sb = (sbuff_t *)userdata;
	int16_t *src, *dst;
	int32_t size, copy;

	if (NULL == sb)
		return;

	src = sb->buffer + sb->tail;
	dst = (int16_t *)stream;
	size = len / sizeof(*dst);
	copy = sb->size - sb->tail;
	sb->tail += size;
	if (copy > size)
		copy = size;
	if (sb->tail >= sb->size)
		sb->tail -= sb->size;
	if (copy > 0) {
		memcpy(dst, src, copy * sizeof(*dst));
		dst += copy;
		copy = size - copy;
	}
	if (copy > 0) {
		src = sb->buffer;
		memcpy(dst, src, copy * sizeof(*dst));
	}

}

void osd_stop_audio_stream(void)
{
	SDL_PauseAudio(1);

	SDL_LockAudio();
	if (NULL != sbuff) {
		free(sbuff);
		sbuff = NULL;
	}

	if (NULL != audio_spec_obtained) {
		free(audio_spec_obtained);
		audio_spec_obtained = NULL;
	}
	SDL_UnlockAudio();
}

int32_t osd_start_audio_stream(int32_t stereo)
{
	int32_t samples;
	int32_t rc;

	rc = SDL_InitSubSystem(SDL_INIT_AUDIO);
	if (0 != rc) {
		fprintf(stderr, "osd_start_audio_stream: SDL_InitSubSystem(SDL_INIT_AUDIO) failed (%d)\n", rc);
		return -1;
	}

	sbuff = (sbuff_t *)calloc(1, sizeof(sbuff_t));
	if (NULL == sbuff) {
		fprintf(stderr, "osd_start_audio_stream: memory problem (%s)\n",
			strerror(errno));
		return -1;
	}

	audio_spec_desired = (SDL_AudioSpec *)calloc(1, sizeof(SDL_AudioSpec));
	if (NULL == audio_spec_desired) {
		fprintf(stderr, "osd_start_audio_stream: memory problem (%s)\n",
			strerror(errno));
		free(sbuff);
		return -1;
	}
	audio_spec_obtained = (SDL_AudioSpec *)calloc(1, sizeof(SDL_AudioSpec));
	if (NULL == audio_spec_obtained) {
		fprintf(stderr, "osd_start_audio_stream: memory problem (%s)\n",
			strerror(errno));
		free(sbuff);
		return -1;
	}

	audio_spec_desired->freq = sample_rate;
	audio_spec_desired->format = AUDIO_S16SYS;
	audio_spec_desired->channels = stereo ? 2 : 1;
	audio_spec_desired->samples = SBUFF_SIZE / 16;
	audio_spec_desired->callback = osd_flush_audio_stream;
	audio_spec_desired->userdata = sbuff;
	rc = SDL_OpenAudio(audio_spec_desired, audio_spec_obtained);

	if (rc) {
		/* fail */
		free(audio_spec_desired);
		audio_spec_desired = NULL;
		free(audio_spec_obtained);
		audio_spec_obtained = NULL;
		free(sbuff);
		sbuff = NULL;
		fprintf(stderr, "osd_start_audio_stream: SDL_OpenAudio failed (%s)\n",
			strerror(errno));
		return 0;
	}

	/* obtained sample rate */
	sample_rate = audio_spec_obtained->freq;
	samples = sample_rate / refresh_rate;
	sbuff->size = SBUFF_SIZE;
	sbuff->head = 0;
	sbuff->tail = SBUFF_SIZE / 8;

#if	0
	printf("--- rates\n");
	printf("sample_rate:   %d\n", sample_rate);
	printf("refresh_rate:  %g\n", refresh_rate);
	printf("--- audio_spec_obtained\n");
	printf("freq:          %d\n", audio_spec_obtained->freq);
	printf("format:        0x%x\n", audio_spec_obtained->format);
	printf("channels:      %d\n", audio_spec_obtained->channels);
	printf("samples:       %d\n", audio_spec_obtained->samples);
	printf("size:          %d\n", audio_spec_obtained->size);
	printf("callback:      %p\n", audio_spec_obtained->callback);
	printf("userdata:      %p\n", audio_spec_obtained->userdata);

	printf("--- sbuff\n");
	printf("size:          %d\n", sbuff->size);
	printf("head:          %d\n", sbuff->head);
	printf("tail:          %d\n", sbuff->tail);
	printf("--- samples per frame\n");
	printf("samples:       %d\n", samples);
#endif
	SDL_PauseAudio(0);

	return samples;
}

static int32_t frameskip_counter = 0;
static const int32_t skiptable[FRAMESKIP_LEVELS][FRAMESKIP_LEVELS] = {
	{ 0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,1 },
	{ 0,0,0,0,0,1,0,0,0,0,0,1 },
	{ 0,0,0,1,0,0,0,1,0,0,0,1 },
	{ 0,0,1,0,0,1,0,0,1,0,0,1 },
	{ 0,1,0,0,1,0,1,0,0,1,0,1 },
	{ 0,1,0,1,0,1,0,1,0,1,0,1 },
	{ 0,1,0,1,1,0,1,0,1,1,0,1 },
	{ 0,1,1,0,1,1,0,1,1,0,1,1 },
	{ 0,1,1,1,0,1,1,1,0,1,1,1 },
	{ 0,1,1,1,1,1,0,1,1,1,1,1 },
	{ 0,1,1,1,1,1,1,1,1,1,1,1 }
};

static const int32_t waittable[FRAMESKIP_LEVELS][FRAMESKIP_LEVELS] = {
	{ 1,1,1,1,1,1,1,1,1,1,1,1 },
	{ 2,1,1,1,1,1,1,1,1,1,1,0 },
	{ 2,1,1,1,1,0,2,1,1,1,1,0 },
	{ 2,1,1,0,2,1,1,0,2,1,1,0 },
	{ 2,1,0,2,1,0,2,1,0,2,1,0 },
	{ 2,0,2,1,0,2,0,2,1,0,2,0 },
	{ 2,0,2,0,2,0,2,0,2,0,2,0 },
	{ 2,0,2,0,0,3,0,2,0,0,3,0 },
	{ 3,0,0,3,0,0,3,0,0,3,0,0 },
	{ 4,0,0,0,4,0,0,0,4,0,0,0 },
	{ 6,0,0,0,0,0,6,0,0,0,0,0 },
	{12,0,0,0,0,0,0,0,0,0,0,0 }
};

static uclock_t prev_frames[FRAMESKIP_LEVELS] = {0,0,0,0,0,0,0,0,0,0,0,0};
static uclock_t prev = 0;
static int32_t speed = 100;

int32_t should_sleep_idle(void)
{
	return 1;
}

int32_t osd_skip_next_frame(void)
{
	uclock_t curr;
	int32_t i;

	if (skiptable[frameskip][frameskip_counter]) {
		frameskip_counter = (frameskip_counter + 1) % FRAMESKIP_LEVELS;
		return skiptable[frameskip][frameskip_counter];
	}

	/* now wait until it's time to update the screen */
	if (throttle) {
		uclock_t target, target2;

		/* wait until enough time has passed since last frame... */
		target = prev + waittable[frameskip][frameskip_counter] *
			UCLOCKS_PER_SEC / refresh_rate;

		/* ... OR since FRAMESKIP_LEVELS frames ago. This way,
		 * if a frame takes longer than the allotted time,
		 * we can compensate in the following frames.
		 */
		target2 = prev_frames[frameskip_counter] +
			FRAMESKIP_LEVELS * UCLOCKS_PER_SEC / refresh_rate;

		if (target - target2 > 0)
			target = target2;
       		
		curr = uclock();
       		
		/*
		 * If we need to sleep more then half a second,
		 * we've somehow got totally out of sync. So
		 * if this happens we reset all counters
		 */
		if ((target - curr) > (UCLOCKS_PER_SEC / 2)) {
			for (i = 0; i < FRAMESKIP_LEVELS; i++)
				prev_frames[i] = curr;
		} else {
			while ((curr - target) < 0) {
				curr = uclock();
				if ((target - curr) > (UCLOCKS_PER_SEC/100) &&
					should_sleep_idle())
					usleep(100);
			}
		}

	} else {
		curr = uclock();
	}

	if (frameskip_counter == 0 &&
		0 != (curr - prev_frames[frameskip_counter])) {
			int32_t divdr;

			divdr = refresh_rate *
				(curr - prev_frames[frameskip_counter]) /
				(100 * FRAMESKIP_LEVELS);
			speed = (UCLOCKS_PER_SEC + divdr/2) / divdr;
	}

	prev = curr;
	for (i = 0;i < waittable[frameskip][frameskip_counter];i++)
		prev_frames[(frameskip_counter + FRAMESKIP_LEVELS - i) %
			FRAMESKIP_LEVELS] = curr;

	if (throttle && autoframeskip && frameskip_counter == 0) {
		static int32_t frameskipadjust;

		if (speed >= 100) {
			frameskipadjust++;
			if (frameskipadjust > 1) {
				frameskipadjust = 0;
				if (frameskip > 0)
					frameskip--;
			}
		} else {
			if (speed < 80) {
				frameskipadjust -= (90 - speed) / 5;
			} else {
				/*
				 * Don't push frameskip too far,
				 * if we are close to 100% speed
				 */
				if (frameskip < 8)
					frameskipadjust--;
			}

			while (frameskipadjust <= -2) {
				frameskipadjust += 2;
				if (frameskip < max_autoframeskip)
					frameskip++;
			}
		}
	}
	
	frameskip_counter = (frameskip_counter + 1) % FRAMESKIP_LEVELS;
	return skiptable[frameskip][frameskip_counter];
}

void osd_display_frequency(uint64_t frq)
{
	uint32_t mhz = (uint32_t)(frq / 1000000ull);
	uint32_t khz = (uint32_t)((frq / 1000ull) % 1000ull);
	/*if (NULL != ctrl_panel)
		osd_widget_text(ctrl_panel, WID_FREQUENCY, "%u.%03u MHz", mhz, khz);*/
}

void osd_help(int argc, char **argv)
{
	char *program, *slash;
	slash = strrchr(argv[0], '/');
	if (NULL == slash)
		slash = strrchr(argv[0], '\\');
	if (NULL == slash)
		program = argv[0];
	else
		program = slash + 1;
	printf("usage: %s [options]\n", program);
	printf("options can be one or more of:\n");
	printf("-h|--help      display this help\n");
	printf("-f|--fast      disable throttling to original speed\n");
	printf("-v|--video     record MNG video right from the start\n");
	printf("-s|--scale n   scale video display to n times 1:1\n");
}

int32_t osd_init(void *cookie,
	void (*keydn)(void *cookie, osd_key_t *),
	void (*keyup)(void *cookie, osd_key_t *),
	int argc, char **argv)
{
	int i;

	for (i = 1; i < argc; i++) {
		if (!strcmp(argv[i], "-h") || !strcmp(argv[i], "--help")) {
			osd_help(argc, argv);
			return -1;
		}
		if (!strcmp(argv[i], "-f") || !strcmp(argv[i], "--fast")) {
			throttle = 0;
			continue;
		}
		if (!strcmp(argv[i], "-v") || !strcmp(argv[i], "--video")) {
			start_video = 1;
			continue;
		}
	}

	cookie_callback = cookie;
	keydn_callback = keydn;
	keyup_callback = keyup;

	SDL_Init(SDL_INIT_VIDEO | SDL_INIT_TIMER | SDL_INIT_NOPARACHUTE);
	atexit(SDL_Quit);

	SDL_EventState(SDL_KEYDOWN, SDL_ENABLE);
	SDL_EventState(SDL_KEYUP, SDL_ENABLE);
	SDL_EventState(SDL_QUIT, SDL_ENABLE);

	return 0;
}

void osd_exit(void)
{
	osd_close_display();
	SDL_Quit();
}
